<!DOCTYPE html><html lang="zh-CN"><head hexo-theme="https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1"><meta charset="utf-8"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="preload" href="/css/first.css" as="style"><title>[原创]数论各种小定理 - tabris的博客</title><meta name="keywords" content="CSDN,数论"><meta name="description" content="[原创]数论各种小定理
2016-05-24 10:54:37  Tabris_ 阅读数：1852

博客爬取于2020-06-14 22:39:18以下为正文
版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。https://blog.csdn.net/qq_33184171/article/de..."><link rel="alternate" href="/atom.xml" title="tabris的博客" type="application/atom+xml"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon-16x16.png"><link rel="manifest" href="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/site.webmanifest"><link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/safari-pinned-tab.svg" color="#5bbad5"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon.ico"><link rel="stylesheet" href="/css/first.css"><link rel="stylesheet" href="/css/style.css" media="print" onload='this.media="all",this.onload=null'><noscript><link rel="stylesheet" href="/css/style.css"></noscript><script>window.MSInputMethodContext&&document.documentMode&&document.write('<style>html{overflow-x: hidden !important;overflow-y: hidden !important;}.kill-ie{text-align:center;height: 100%;margin-top: 15%;margin-bottom: 5500%;}</style><div class="kill-ie"><h1><b>抱歉，您的浏览器无法访问本站</b></h1><h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/><a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>了解详情 ></strong></a></div>')</script><noscript><style>html{overflow-x:hidden!important;overflow-y:hidden!important}.kill-noscript{text-align:center;height:100%;margin-top:15%;margin-bottom:5500%}</style><div class="kill-noscript"><h1><b>抱歉，您的浏览器无法访问本站</b></h1><h3>本页面需要浏览器支持（启用）JavaScript</h3><br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a></div></noscript></head><body><header id="l_header" class="l_header auto shadow blur show" style="opacity:0"><div class="container"><div id="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h m-phone" id="pjax-header-nav-list"><li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/"><i class="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/avatar/avatar.jpg"></i> Tabris</a><div class="menu navigation"><ul class="nav-list-h m-pc"><li><a class="menuitem flat-box faa-parent animated-hover" href="/" id="home"><i class="fas fa-home fa-fw"></i> 首页</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i> 分类</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i> 标签</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i> 归档</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友链</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i> 关于</a></li><li><a class="menuitem flat-box faa-parent animated-hover"><i class="fas fa-book fa-fw"></i> 待整理</a><ul class="list-v"><li><a class="menuitem flat-box header toggle-mode-btn"><i class="fas fa-moon fa-fw"></i> 暗黑模式</a></li><li></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i> 分类</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i> 标签</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i> 归档</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友链</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i> 关于</a></li></ul></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="Search..."></form></div><ul class="switcher nav-list-h m-phone"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="menuitem flat-box faa-parent animated-hover" href="/" id="home"><i class="fas fa-home fa-fw"></i> 首页</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i> 分类</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i> 标签</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i> 归档</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友链</a></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i> 关于</a></li><li><a class="menuitem flat-box faa-parent animated-hover"><i class="fas fa-book fa-fw"></i> 待整理</a><ul class="list-v"><li><a class="menuitem flat-box header toggle-mode-btn"><i class="fas fa-moon fa-fw"></i> 暗黑模式</a></li><li></li><li><a class="menuitem flat-box faa-parent animated-hover" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i> 分类</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i> 标签</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i> 归档</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i> 友链</a></li><hr><li><a class="menuitem flat-box faa-parent animated-hover" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i> 关于</a></li></ul></li></ul></li></ul></div></div></div></header><div id="l_body"><div id="l_cover"><div id="none" class="cover-wrapper post dock" style="display:none"><div id="parallax-window"></div><div class="cover-body"><div class="top"><p class="title">tabris blog</p><p class="subtitle">A Low Blog</p></div><div class="bottom"><div class="menu navigation"><div class="list-h"><a href="/" id="home"><i class="fas fa-home fa-fw"></i><p>首页</p></a><a href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i><p>分类</p></a><a href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i><p>标签</p></a><a href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i><p>归档</p></a><a href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i><p>友链</p></a><a href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i><p>关于</p></a></div></div></div></div><div id="scroll-down" style="display:none"><i class="fa fa-chevron-down scroll-down-effects"></i></div></div></div><div id="safearea"><div class="body-wrapper" id="pjax-container"><div id="l_main" class><article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost"><div class="article-meta" id="top"><h1 class="title"> [原创]数论各种小定理</h1><div class="new-meta-box"><div class="new-meta-item author"> <a class="author" href="/" rel="nofollow"><img no-lazy src="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/avatar/avatar.jpg"><p>Tabris</p></a></div><div class="new-meta-item category"><a class="notlink"><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i> <a class="category-link" href="/categories/csdn/">CSDN</a><span class="sep"></span><a class="category-link" href="/categories/csdn/%E6%A8%A1%E6%9D%BF/">模板</a><span class="sep"></span><a class="category-link" href="/categories/csdn/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E8%AE%BA/">数论</a></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>发布于：2016年5月24日</p></a></div><div class="new-meta-item browse leancloud"><a class="notlink"><div id="lc-pv" data-title="[原创]数论各种小定理" data-path="/2016-05-24-51488462/"><i class="fas fa-eye fa-fw" aria-hidden="true"></i><span id="number"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次浏览</div></a></div></div></div><p>[原创]数论各种小定理</p><p>2016-05-24 10:54:37 <a href="https://me.csdn.net/qq_33184171" target="_blank" rel="external nofollow noopener noreferrer">Tabris_</a> 阅读数：1852</p><hr><p>博客爬取于<code>2020-06-14 22:39:18</code><br><em><strong>以下为正文</strong></em></p><p>版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。<br><a href="https://blog.csdn.net/qq_33184171/article/details/51488462" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/qq_33184171/article/details/51488462</a></p><span id="more"></span><hr><p>#<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/D" target="_blank" rel="external nofollow noopener noreferrer">这里是数论入门题目了 很全面</a>&lt;&lt;-- 戳这里</p><p><strong>欧拉降幂</strong><br><img src="http://img.blog.csdn.net/20160507152606333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" class="lazyload" data-srcset="http://img.blog.csdn.net/20160507152606333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>$A^x%C=A^{x%\phi(C)+\phi(C)}%C,(x≥\phi(C))$</p><p>O(1)解决快速乘取膜</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLu qmodx(LLu a,LLu b,LLu c)</span><br><span class="line">&#123;</span><br><span class="line">    a%&#x3D;c,b%&#x3D;c;</span><br><span class="line">    if(c&lt;&#x3D;1000000000) return a*b%c;</span><br><span class="line">    return (a*b-(LLu)(a&#x2F;(long double)c*b+1e-8)*c+c)%c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n = p1^a1<em>p2^a2</em>p3^a3<em>…</em>pk^ak 约束和s = (p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak）</p><p>lucas 定理 快速求大组合数 (省内存&amp;省时间)<br><a href="http://blog.csdn.net/skywalkert/article/details/52553048" target="_blank" rel="external nofollow noopener noreferrer">组合数求模</a><br><a href="http://picks.logdown.com/posts/245545-binomial-coefficient-modulo-prime" target="_blank" rel="external nofollow noopener noreferrer">组合数求模</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;cstdio&gt;</span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line"># include &lt;cmath&gt;</span><br><span class="line"># include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"># define lld  __int64</span><br><span class="line"></span><br><span class="line">lld  n, m, p;</span><br><span class="line"></span><br><span class="line">lld Ext_gcd(lld a,lld b,lld &amp;x,lld &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">   if(b&#x3D;&#x3D;0) &#123; x&#x3D;1, y&#x3D;0; return a; &#125;</span><br><span class="line">   lld ret&#x3D; Ext_gcd(b,a%b,y,x);</span><br><span class="line">   y-&#x3D; a&#x2F;b*x;</span><br><span class="line">   return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lld Inv(lld a,int m)   &#x2F;&#x2F;&#x2F;求逆元</span><br><span class="line">&#123;</span><br><span class="line">   lld d,x,y,t&#x3D; (lld)m;</span><br><span class="line">   d&#x3D; Ext_gcd(a,t,x,y);</span><br><span class="line">   if(d&#x3D;&#x3D;1) return (x%t+t)%t;</span><br><span class="line">   return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lld Cm(lld n, lld m, lld p)  &#x2F;&#x2F;&#x2F;组合数学</span><br><span class="line">&#123;</span><br><span class="line">    lld a&#x3D;1, b&#x3D;1;</span><br><span class="line">    if(m&gt;n) return 0;</span><br><span class="line">    while(m)</span><br><span class="line">    &#123;</span><br><span class="line">        a&#x3D;(a*n)%p;</span><br><span class="line">        b&#x3D;(b*m)%p;</span><br><span class="line">        m--;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    return (lld)a*Inv(b,p)%p;  &#x2F;&#x2F;&#x2F;（a&#x2F;b）%p 等价于 a*（b，p）的逆元</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Lucas(lld n, lld m, lld p)  &#x2F;&#x2F;&#x2F;把n分段递归求解相乘</span><br><span class="line">&#123;</span><br><span class="line">    if(m&#x3D;&#x3D;0) return 1;</span><br><span class="line">    return (lld)Cm(n%p,m%p,p)*(lld)Lucas(n&#x2F;p,m&#x2F;p,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int  T;</span><br><span class="line">    while(~scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">    	n--,m--;</span><br><span class="line">        m--;</span><br><span class="line">        __int64 p&#x3D;1000000007;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\n&quot;,Lucas(n+m-1,m,p));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;****************************************&#x2F;</span><br><span class="line">LL qmul(LL a,LL b,LL c)</span><br><span class="line">&#123;</span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) res&#x3D;(res+a)%c;</span><br><span class="line">        a&#x3D;(a+a)%c;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">LL qmod(LL a,LL b,LL c)</span><br><span class="line">&#123;</span><br><span class="line">    LL res&#x3D;1;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) res&#x3D;qmul(res,a,c)%c;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;qmul(a,a,c)%c;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y) &#x2F;&#x2F;ax+by&#x3D;d</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x&#x3D;1;</span><br><span class="line">        y&#x3D;0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        LL r&#x3D;exgcd(b,a%b,x,y);</span><br><span class="line">        LL t &#x3D; x;</span><br><span class="line">        x &#x3D; y;</span><br><span class="line">        y&#x3D;t-a&#x2F;b*x;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL CRT(LL a[],LL m[],LL len) &#x2F;&#x2F;x%m[i]&#x3D;a[i]</span><br><span class="line">&#123;</span><br><span class="line">    LL i,x,y,M,n&#x3D;1,ret&#x3D;0;</span><br><span class="line">    for(i&#x3D;0; i&lt;len; ++i) n*&#x3D;m[i];</span><br><span class="line">    for(i&#x3D;0; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        M&#x3D;n&#x2F;m[i];</span><br><span class="line">        exgcd(M,m[i],x,y);</span><br><span class="line">        ret&#x3D;(ret+qmul(qmul(x,M,n),a[i],n))%n;</span><br><span class="line">    &#125;</span><br><span class="line">    return (ret+n)%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LL C(LL n,LL m,LL p)&#x2F;&#x2F;组合数模素数P</span><br><span class="line">&#123;</span><br><span class="line">    if(m&gt;n||m&lt;0) return 0;</span><br><span class="line">    if(n-m&lt;m) m&#x3D;n-m;</span><br><span class="line">    LL a&#x3D;1,b&#x3D;1;</span><br><span class="line">    for(int i&#x3D;0; i&lt;m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a&#x3D;a*(n-i)%p;</span><br><span class="line">        b&#x3D;b*(m-i)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return a*qmod(b,p-2,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Lucas(LL n,LL m,LL p)</span><br><span class="line">&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(n&amp;&amp;m&amp;&amp;ans)</span><br><span class="line">    &#123;</span><br><span class="line">        ans&#x3D;ans*C(n%p,m%p,p)%p;</span><br><span class="line">        n&#x2F;&#x3D;p,m&#x2F;&#x3D;p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="余数问题"><a href="#余数问题" class="headerlink" title="余数问题"></a>余数问题</h1><p><a href="http://vjudge.net/contest/132006#overview" target="_blank" rel="external nofollow noopener noreferrer">这里是余数问题的练习题目</a></p><h3 id="余数定理"><a href="#余数定理" class="headerlink" title="余数定理"></a>余数定理</h3><blockquote><p>计算$\left(\dfrac {a}{b}\right)\mod{c}$ 其中b能整除a<br>如果b与c互素，则$(a/b)%c=a*b^{phi(c)-1}%c$<br>如果b与c不互素，则$(a/b)%c=(a%bc)/b$<br>对于b与c互素和不互素都有$(a/b)%c=(a%bc)/b$成立</p></blockquote><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>这里是扩展欧几里德入门的题目了 做完这些我觉得才明白了扩展欧几里德的应用 <a href="http://acm.hust.edu.cn/vjudge/contest/117544#overview" target="_blank" rel="external nofollow noopener noreferrer">传送阵&lt;&lt;---</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line"># include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"># define LL long long int</span><br><span class="line"># define _LL __int64</span><br><span class="line"></span><br><span class="line">LL exgcd_euclid(LL a,LL b,LL &amp;x,LL &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    if(b&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        x&#x3D;1;</span><br><span class="line">        y&#x3D;0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL r&#x3D;exgcd_euclid(b,a%b,x,y);</span><br><span class="line">    LL t&#x3D;x;</span><br><span class="line">    x&#x3D;y;</span><br><span class="line">    y&#x3D;t-a&#x2F;b*y;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LL exgcd(LL m,LL &amp;x,LL n,LL &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    LL x1,x0,y1,y0;</span><br><span class="line">    x0&#x3D;1,y0&#x3D;0;</span><br><span class="line">    x1&#x3D;0,y1&#x3D;1;</span><br><span class="line">    LL r&#x3D;(m%n+n)%n;</span><br><span class="line">    LL q&#x3D;(m-r)&#x2F;n;</span><br><span class="line">    x&#x3D;0,y&#x3D;1;</span><br><span class="line">    while(r)</span><br><span class="line">    &#123;</span><br><span class="line">        x&#x3D;x0-q*x1,y&#x3D;y0-q*y1,x0&#x3D;x1,y0&#x3D;y1;</span><br><span class="line">        x1&#x3D;x,y1&#x3D;y;</span><br><span class="line">        m&#x3D;n,n&#x3D;r,r&#x3D;m%n;</span><br><span class="line">        q&#x3D;(m-r)&#x2F;n;</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LL ar,br,cr;</span><br><span class="line">    LL x,y,m,n,l;</span><br><span class="line">    while(~scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;m,&amp;n,&amp;l))</span><br><span class="line">    &#123;</span><br><span class="line">        LL M&#x3D;exgcd(n-m,ar,l,br);</span><br><span class="line">        if((x-y)%M||m&#x3D;&#x3D;n)</span><br><span class="line">            printf(&quot;Impossible\n&quot;);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            LL s&#x3D;l&#x2F;M;</span><br><span class="line">            ar&#x3D;ar*((x-y)&#x2F;M);</span><br><span class="line">            ar&#x3D;(ar%s+s)%s;</span><br><span class="line">            printf(&quot;%lld\n&quot;,ar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>定义:$a\times x \equiv{1}( \mod{m})$,称x为a关于m的逆元<br>对于方程$\left(\dfrac {a}{x}\right)\mod{c}$ 我们可以转化为求$\left({a}\times{x^{-1} }\right)\mod{c}$<br>由于${x}\times {x^{-1} } \equiv{1}( \mod{m})$恒成立,所以除法取模就可以将被除数转化为乘上被除数的逆元即可.</p><h5 id="求逆元的两种方法"><a href="#求逆元的两种方法" class="headerlink" title="求逆元的两种方法"></a>求逆元的两种方法</h5><ol><li>扩展欧几里德<br>$\left(\dfrac {a}{x}\right) \equiv ? (\mod{c})\=&gt; a \equiv ? \times x (\mod{c}) \ =&gt; a = ?\times {x} + k\times{c}$<br>通过公式的推到，最后得到一个明显的同余式<br>而?的最小正整数解就是x的逆元<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if(b&#x3D;&#x3D;0) &#123;</span><br><span class="line">        x &#x3D; 1,y &#x3D; 0,d&#x3D;a;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b,d,x,y);</span><br><span class="line">    int t &#x3D; x;</span><br><span class="line">    x &#x3D; y;</span><br><span class="line">    y &#x3D; t - ( a &#x2F; b ) * y;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int inv(int a)&#123;</span><br><span class="line">    int x,y,d;</span><br><span class="line">    exgcd(a,MOD,d,x,y);</span><br><span class="line">    if(d&#x3D;&#x3D;1)  return (x%MOD+MOD)%MOD;   &#x2F;&#x2F;返回最小正整数解</span><br><span class="line">    return -1;  &#x2F;&#x2F;不存在逆元</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">注意只有当a与mod互质即 gcd(a,mod) 时才有逆元,否则不存在逆元</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></li><li>费马小定理<blockquote><p>费马小定理 :${a}^{p-1} \equiv 1 (\mod p)$.</p></blockquote></li></ol><p>可以转化为${a}\times{a}^{p-2} \equiv 1 (\mod p)$.所以${a}^{p-2}$就是a关于p的逆元(!!!!!p必须为素数)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int qmod(int a,int b)&#123;</span><br><span class="line">    int res &#x3D; 1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) res&#x3D;res*a%MOD;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int inv(int a)&#123;</span><br><span class="line">    return qmod(a,MOD-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求解高次同余方程"><a href="#求解高次同余方程" class="headerlink" title="求解高次同余方程"></a>求解高次同余方程</h3><p>还是用 babystep_gaintstep算法求解。但是这题并不能用POJ_2417的算法，直接套该<br>算法，下面简要说明一下不能用的原因。首先我们有必要归纳一下用babystep算法解题<br>的步骤：<br>(1) 求M = ceil( sqrt(C) ) ；<br>(2) for(i=0;i&lt; M;i++) hash( i , A^i ) ；<br>(3) 求D = A^M%C；<br>(4) r = 1 ; for( i = 0 ; i &lt; M ; i++ ) ex_gcd(r , C , x , y ) ; res = x * B % C ; jj = find( res)<br>如果找到了这时候的jj，则答案就是i*M+jj，如果没有找到，则res = res * D % C，继续循<br>环查找，如果最终都没有找到，则输出无解。 在上述的步骤中，如果题目中没有告诉我们<br>gcd(A , C) = 1，则我们上述的方法是错误的，原因就在于第4步，求res的时候。因为如果<br>我们无法保证gcd(A , C) = 1 ，也就不能保证gcd(r ,C) = 1（因为D=A^M, r = D^i），所有在<br>用 扩展欧几里得求出r*x + C*y = gcd(r,C ) 的一个解x0之后，原方程:r*x+C*y = B的解<br>x = x0 * B / gcd(r,C) + i*C / gcd(r,C) ，但是我们这个时候并不能计算出gcd(r,C)，因为此时<br>的r本来就是经过取余之后得出的，并不能直接用来求gcd，因此我们上述的普通babystep<br>算法就会出错了。<br> 这样我们就要换一种处理的方法了，这里介绍一种AC大牛博客上的一种“消因子”的方法，<br>具体内容请看这里：AC大牛。经过上面的分析我们很清楚接下去的处理应该从哪方面着<br>手，就是应该从不能求出gcd(r , C)入手。一种思想就是既然无法求， 那我每次只要保证<br>gcd(r, C) = 1那样就可以想普通babystep一样求解了，既然要保证gcd(r,C) =1 ，而<br>r = (A^M)^i,因此归根到底还是要求gcd( A , C ) = 1。下面就是从AC大牛博客上参考的“消因子”<br>法了，每次我们 都消去A,C的一个因子，然后对B,C, D进行如下的处理：B/=tmp;C/=tmp ;<br>D = D* A/tmp%C ，这样经过b轮的消因子之后，gcd(A,C) = 1， 接下去我们就可以用普通<br>的babystep求解出方程：A^x = B&#39;( mod C&#39; ) 的解 res1， 原方程的解就是 res = res1 + b。<br>下面给出这种方法正确的简要证明；一开始我们要求的方程是：A^x = B( mod C )，也就是<br>求一个最小的x，使得A^x + C*y = B，通过消因子， 我们不断在方程两遍消去gcd(A,C)，这<br>样方程就可以变成 D*A^x1 + C&#39;*y1 = B&#39;，很简单就可以证明上式中 x = x1 + b ; y = y1 的（只要<br>在方程的两边分别将消去的因子乘回去等式还是保持不变的）。这样我们的问题就转化为了<br>求x1和y1，即D*A^x1 = B&#39;( mod C&#39; )，此时gcd( A , C&#39;) = 1，这样我们就可以用普通的babystep<br>求出上述式子的解x1，同时也就求出了x，这样本题就解决了。<br> 但是上述的方法还是有一个bug的，也就是说，我们用babystep求出的x1&gt;=0，所以上述的<br>方法只能求出x &gt;= b的解，这样我们自然就会想到如果有一个解x &lt; b怎么办，上述方法就会出<br>先错误了，因此我们这里还需要改进。考虑b的最大值是多少，考虑每次我们消去的因子数都<br>最小也就是2，这样我们就可以得到b的最大值就是log(C)，这样我们只要保证每次log(C)之内的<br>解都特判一下， 就不会出现我们刚才的问题了， 所以我们要在进行上述处理之前进行一次for<br>循环 ，特判0 - log(C)直接的x是否能成为解，接下去再用上述的“消因子”算法。<br> 最后不得不佩服发明这种算法的人的神奇，将O(C)复杂度的判断，分两级判断将复杂度降低<br>到O( sqrt(C) )，所以就是为什么叫&quot; babystep_gaintstep &quot;了， 哈哈。</p><h4 id="babystep算法模板"><a href="#babystep算法模板" class="headerlink" title="babystep算法模板"></a>babystep算法模板</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># define CC(m ,what) memset(m , what , sizeof(m))</span><br><span class="line">LL A, B ,C ;</span><br><span class="line">const int NN &#x3D; 99991 ;</span><br><span class="line">bool has[NN] ;</span><br><span class="line">int idx[NN] , val[NN] ;</span><br><span class="line"></span><br><span class="line">void insert_(int id , LL vv)</span><br><span class="line">&#123;</span><br><span class="line">    LL v &#x3D; vv % NN ;</span><br><span class="line">    while( has[v] &amp;&amp; val[v]!&#x3D;vv)</span><br><span class="line">    &#123;</span><br><span class="line">        v++ ;</span><br><span class="line">        if(v &#x3D;&#x3D; NN) v-&#x3D;NN ;</span><br><span class="line">    &#125;</span><br><span class="line">    if( !has[v] )</span><br><span class="line">    &#123;</span><br><span class="line">        has[v] &#x3D; 1;</span><br><span class="line">        val[v] &#x3D; vv ;</span><br><span class="line">        idx[v] &#x3D; id ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int findi(LL vv)</span><br><span class="line">&#123;</span><br><span class="line">    LL v &#x3D; vv % NN ;</span><br><span class="line">    while( has[v] &amp;&amp; val[v]!&#x3D;vv)</span><br><span class="line">    &#123;</span><br><span class="line">        v++ ;</span><br><span class="line">        if(v &#x3D;&#x3D; NN) v-&#x3D;NN ;</span><br><span class="line">    &#125;</span><br><span class="line">    if( !has[v] )  return -1;</span><br><span class="line">    return idx[v] ;</span><br><span class="line">&#125;</span><br><span class="line">void ex_gcd(LL a , LL b , LL&amp; x , LL&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    if(b &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        x &#x3D; 1 ;</span><br><span class="line">        y &#x3D; 0 ;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    ex_gcd(b , a%b , x, y) ;</span><br><span class="line">    LL t &#x3D; x ;</span><br><span class="line">    x &#x3D; y;</span><br><span class="line">    y &#x3D; t - a&#x2F;b*y ;</span><br><span class="line">&#125;</span><br><span class="line">LL gcd(LL a,LL b)</span><br><span class="line">&#123;</span><br><span class="line">    while( a%b !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        LL c &#x3D; a ;</span><br><span class="line">        a &#x3D; b ;</span><br><span class="line">        b &#x3D; c % b ;</span><br><span class="line">    &#125;</span><br><span class="line">    return b ;</span><br><span class="line">&#125;</span><br><span class="line">LL baby_step(LL A, LL B , LL C)</span><br><span class="line">&#123;</span><br><span class="line">    LL ans &#x3D; 1 ;</span><br><span class="line">    for(LL i&#x3D;0; i&lt;&#x3D;50; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ans &#x3D;&#x3D; B)    return i ;</span><br><span class="line">        ans &#x3D; ans * A % C ;</span><br><span class="line">    &#125;</span><br><span class="line">    LL tmp , d &#x3D; 0 ;</span><br><span class="line">    LL D &#x3D; 1 % C ;</span><br><span class="line">    while( (tmp&#x3D;gcd(A,C)) !&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        if(B % tmp) return -1 ;</span><br><span class="line">        d++ ;</span><br><span class="line">        B&#x2F;&#x3D;tmp ;</span><br><span class="line">        C&#x2F;&#x3D;tmp ;</span><br><span class="line">        D &#x3D; D*A&#x2F;tmp%C ;</span><br><span class="line">    &#125;</span><br><span class="line">    CC( has , 0) ;</span><br><span class="line">    CC( idx, -1) ;</span><br><span class="line">    CC(val , -1) ;</span><br><span class="line">    LL M &#x3D; ceil( sqrt(C*1.0) ) ;</span><br><span class="line">    LL rr &#x3D; 1 ;</span><br><span class="line">    for(int i&#x3D;0; i&lt;M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_(i, rr) ;</span><br><span class="line">        rr &#x3D; rr * A % C ;</span><br><span class="line">    &#125;</span><br><span class="line">    LL x, y ;</span><br><span class="line">    for(int i&#x3D;0; i&lt;M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ex_gcd(D, C , x, y) ;</span><br><span class="line">        LL r &#x3D; x * B % C;</span><br><span class="line">        r &#x3D; (r % C + C) % C ;</span><br><span class="line">        int jj &#x3D; findi( r ) ;</span><br><span class="line">        if(jj !&#x3D; -1)</span><br><span class="line">        &#123;</span><br><span class="line">            return  LL(i)*M + LL(jj) + d ;</span><br><span class="line">        &#125;</span><br><span class="line">        D &#x3D; D * rr % C ;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="素数测试"><a href="#素数测试" class="headerlink" title="素数测试"></a>素数测试</h1><h3 id="线性筛法打素数表"><a href="#线性筛法打素数表" class="headerlink" title="线性筛法打素数表"></a>线性筛法打素数表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int prime[20000],kp&#x3D;0;</span><br><span class="line">int Is_or[65536];</span><br><span class="line">void Prime()</span><br><span class="line">&#123;</span><br><span class="line">    int n &#x3D;65536; &#x2F;&#x2F;2~n之间的素数</span><br><span class="line">    kp&#x3D;0;</span><br><span class="line">    memset(Is_or,1,sizeof(Is_or));</span><br><span class="line">    Is_or[0]&#x3D;Is_or[1]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;2;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(Is_or[i])    prime[kp++]&#x3D;i;</span><br><span class="line"></span><br><span class="line">        for(int j&#x3D;0;j&lt;kp&amp;&amp;i*prime[j]&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Is_or[i*prime[j]]&#x3D;0;</span><br><span class="line">            if(i%prime[j]&#x3D;&#x3D;0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机性素数测试-miller-rabbin"><a href="#随机性素数测试-miller-rabbin" class="headerlink" title="随机性素数测试    miller-rabbin"></a>随机性素数测试 miller-rabbin</h3><p>普通的素数测试我们有O(√ n)的试除算法。事实上，我们有O(slog³n)的算法。</p><p>定理一：假如p是质数，且(a,p)=1，那么a^(p-1)≡1(mod p)。即假如p是质数，且a,p互质，那么a的(p-1)次方除以p的余数恒等于1。（费马小定理）</p><p>该定理的逆命题是不一定成立的，但是令人可喜的是大多数情况是成立的。</p><p>于是我们就得到了一个定理的直接应用，对于待验证的数p，我们不断取a∈［1，p-1]且a∈Z，验证a^(p-1) mod p是否等于1，不是则p果断不是素数，共取s次。其中a^(p-1) mod p可以通过把p-1写成二进制，由(a*b)mod c=(a mod c)*b mod c，可以在t=log(p-1)的时间内计算出解，如考虑整数相乘的复杂度，则一次计算的总复杂度为log³(p-1)。这个方法叫快速幂取模。</p><p>为了提高算法的准确性，我们又有一个可以利用的定理。<br>定理二：对于0 &lt; x &lt; p，x^2 mod p =1 =&gt; x=1或p-1。</p><p>我们令p-1=(2^t)*u，即p-1为u二进制表示后面跟t个0。我们先计算出x[0]=a^u mod p ，再平方t次并在每一次模p，每一次的结果记为x[i]，最后也可以计算出a^(p-1) mod p。若发现x[i]=1而x[i-1]不等于1也不等于p-1，则发现p果断不是素数。</p><p>可以证明，使用以上两个定理以后，检验s次出错的概率至多为2^(-s)，所以这个算法是很可靠的。</p><p>需要注意的是，为了防止溢出（特别大的数据），a*b mod c 也应用类似快速幂取模的方法计算。当然，数据不是很大就可以免了。</p><p>下面是我的程序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;****************************************************************</span><br><span class="line">&#x2F;&#x2F; Miller_Rabin 算法进行素数测试</span><br><span class="line">&#x2F;&#x2F;速度快，而且可以判断 &lt;2^63的数</span><br><span class="line">&#x2F;&#x2F;****************************************************************</span><br><span class="line">const int S&#x3D;20;&#x2F;&#x2F;随机算法判定次数，S越大，判错概率越小</span><br><span class="line">&#x2F;&#x2F;计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的</span><br><span class="line">&#x2F;&#x2F;  a,b,c &lt;2^63</span><br><span class="line">long long mult_mod(long long a,long long b,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    a%&#x3D;c;</span><br><span class="line">    b%&#x3D;c;</span><br><span class="line">    long long ret&#x3D;0;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1)&#123;ret+&#x3D;a;ret%&#x3D;c;&#125;</span><br><span class="line">        a&lt;&lt;&#x3D;1;</span><br><span class="line">        if(a&gt;&#x3D;c)a%&#x3D;c;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算  x^n %c</span><br><span class="line">long long pow_mod(long long x,long long n,long long mod)&#x2F;&#x2F;x^n%c</span><br><span class="line">&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1)return x%mod;</span><br><span class="line">    x%&#x3D;mod;</span><br><span class="line">    long long tmp&#x3D;x;</span><br><span class="line">    long long ret&#x3D;1;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1) ret&#x3D;mult_mod(ret,tmp,mod);</span><br><span class="line">        tmp&#x3D;mult_mod(tmp,tmp,mod);</span><br><span class="line">        n&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以a为基,n-1&#x3D;x*2^t      a^(n-1)&#x3D;1(mod n)  验证n是不是合数</span><br><span class="line">&#x2F;&#x2F;一定是合数返回true,不一定返回false</span><br><span class="line">bool check(long long a,long long n,long long x,long long t)</span><br><span class="line">&#123;</span><br><span class="line">    long long ret&#x3D;pow_mod(a,x,n);</span><br><span class="line">    long long last&#x3D;ret;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret&#x3D;mult_mod(ret,ret,n);</span><br><span class="line">        if(ret&#x3D;&#x3D;1&amp;&amp;last!&#x3D;1&amp;&amp;last!&#x3D;n-1) return true;&#x2F;&#x2F;合数</span><br><span class="line">        last&#x3D;ret;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ret!&#x3D;1) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Miller_Rabin()算法素数判定</span><br><span class="line">&#x2F;&#x2F;是素数返回true.(可能是伪素数，但概率极小)</span><br><span class="line">&#x2F;&#x2F;合数返回false;</span><br><span class="line"></span><br><span class="line">bool Miller_Rabin(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;2)return false;</span><br><span class="line">    if(n&#x3D;&#x3D;2)return true;</span><br><span class="line">    if((n&amp;1)&#x3D;&#x3D;0) return false;&#x2F;&#x2F;偶数</span><br><span class="line">    long long x&#x3D;n-1;</span><br><span class="line">    long long t&#x3D;0;</span><br><span class="line">    while((x&amp;1)&#x3D;&#x3D;0)&#123;x&gt;&gt;&#x3D;1;t++;&#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;S;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        long long a&#x3D;rand()%(n-1)+1;&#x2F;&#x2F;rand()需要stdlib.h头文件</span><br><span class="line">        if(check(a,n,x,t))</span><br><span class="line">            return false;&#x2F;&#x2F;合数</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pollard-rho-longlong质因子分解"><a href="#pollard-rho-longlong质因子分解" class="headerlink" title="pollard_rho(longlong质因子分解)"></a>pollard_rho(longlong质因子分解)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;************************************************</span><br><span class="line">&#x2F;&#x2F;pollard_rho 算法进行质因数分解</span><br><span class="line">&#x2F;&#x2F;************************************************</span><br><span class="line">long long factor[100];&#x2F;&#x2F;质因数分解结果（刚返回时是无序的）</span><br><span class="line">int tol;&#x2F;&#x2F;质因数的个数。数组小标从0开始</span><br><span class="line"></span><br><span class="line">long long gcd(long long a,long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a&#x3D;&#x3D;0)return 1;&#x2F;&#x2F;???????</span><br><span class="line">    if(a&lt;0) return gcd(-a,b);</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        long long t&#x3D;a%b;</span><br><span class="line">        a&#x3D;b;</span><br><span class="line">        b&#x3D;t;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Pollard_rho(long long x,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    long long i&#x3D;1,k&#x3D;2;</span><br><span class="line">    long long x0&#x3D;rand()%x;</span><br><span class="line">    long long y&#x3D;x0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        x0&#x3D;(mult_mod(x0,x0,x)+c)%x;</span><br><span class="line">        long long d&#x3D;gcd(y-x0,x);</span><br><span class="line">        if(d!&#x3D;1&amp;&amp;d!&#x3D;x) return d;</span><br><span class="line">        if(y&#x3D;&#x3D;x0) return x;</span><br><span class="line">        if(i&#x3D;&#x3D;k)&#123;y&#x3D;x0;k+&#x3D;k;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对n进行素因子分解</span><br><span class="line">void findfac(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(Miller_Rabin(n))&#x2F;&#x2F;素数</span><br><span class="line">    &#123;</span><br><span class="line">        factor[tol++]&#x3D;n; &#x2F;&#x2F;值得注意的是 这里的factor并不是有序的!!!!!</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    long long p&#x3D;n;</span><br><span class="line">    while(p&gt;&#x3D;n)p&#x3D;Pollard_rho(p,rand()%(n-1)+1);</span><br><span class="line">    findfac(p);</span><br><span class="line">    findfac(n&#x2F;p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算数基本定理展开"><a href="#算数基本定理展开" class="headerlink" title="算数基本定理展开"></a>算数基本定理展开</h3><p>对于任意一个$N$我们可以写成$N=P_1^{a_1}*P_2^{a_2}<em>P_3^{a_3}</em>...*P_n^{a_n}$<br>我们求解的时候只要先讲素数筛出来,然后直接一个个的除就行了,这样的理想复杂度是$O(min{(小于log_2^n),kp}),kp为筛出的素数个数$<br>但是注意一种情况,可能展开的数N就是一个很大的素数,比如$99997$,这样的数如果有$1e6$个的话就不能简单快速的展开了.于是我们可以在判定数是否为素数的数组中在开一维记录其为第几个素数.这样一来复杂度就会降低很多$小于O(log_2^n)$</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int prime[N],kp;</span><br><span class="line">int Is_or[N][2];</span><br><span class="line">void Prime()&#123;</span><br><span class="line">    kp &#x3D; 0;</span><br><span class="line">    memset(Is_or,true,sizeof(Is_or));</span><br><span class="line">    Is_or[0][0]&#x3D;Is_or[1][0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;100000;i++)&#123;</span><br><span class="line">        if(Is_or[i][0]) Is_or[i][1]&#x3D;kp,prime[kp++]&#x3D;i;&#x2F;&#x2F;记录其为第几个素数</span><br><span class="line">        for(int j&#x3D;0;j&lt;kp&amp;&amp;prime[j]*i&lt;&#x3D;100000;j++)&#123;</span><br><span class="line">            Is_or[prime[j]*i][0]&#x3D;0;</span><br><span class="line">            if(0&#x3D;&#x3D;i%prime[j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int tem;</span><br><span class="line">    cin&gt;&gt;tem;</span><br><span class="line">    for(int j&#x3D;0;j&lt;kp&amp;&amp;tem&gt;&#x3D;prime[j];j++)&#123;</span><br><span class="line">        if(Is_or[tem][0]) &#123;a[Is_or[tem][1]]++;break;&#125;</span><br><span class="line">        &#x2F;&#x2F;if(0&#x3D;&#x3D;tem%prime[j]) ;</span><br><span class="line">        while(0&#x3D;&#x3D;tem%prime[j]) a[j]++,tem&#x2F;&#x3D;prime[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乘性函数"><a href="#乘性函数" class="headerlink" title="乘性函数"></a>乘性函数</h1><h3 id="欧拉函数表"><a href="#欧拉函数表" class="headerlink" title="欧拉函数表"></a>欧拉函数表</h3><p>--------------------------.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void phi_table()  &#x2F;&#x2F;欧拉函数。。。</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i&#x3D;2; i&lt;&#x3D;5e6; i++)</span><br><span class="line">        phi[i]&#x3D;0;</span><br><span class="line">    phi[1]&#x3D;1;</span><br><span class="line">    for(i&#x3D;2; i&lt;&#x3D;5e6; i++)</span><br><span class="line">        if(!phi[i])</span><br><span class="line">            for(j&#x3D;i; j&lt;&#x3D;5e6; j+&#x3D;i)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!phi[j])phi[j]&#x3D;j;</span><br><span class="line">                phi[j]&#x3D;phi[j]&#x2F;i*(i-1);</span><br><span class="line">            &#125;</span><br><span class="line">    phi[0]&#x3D;0;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void phi_table(int maxn)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;maxn;i++)</span><br><span class="line">    phi[i]&#x3D;i;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;maxn;i+&#x3D;2)</span><br><span class="line">    phi[i]&#x2F;&#x3D;2;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;maxn;i+&#x3D;2)</span><br><span class="line">    if(phi[i]&#x3D;&#x3D;i)</span><br><span class="line">        for(int j&#x3D;i;j&lt;&#x3D;maxn;j+&#x3D;i)</span><br><span class="line">            phi[j]&#x3D;phi[j]&#x2F;i*(i-1);</span><br><span class="line"></span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  以上是打表的形式  这是求单个的</span><br><span class="line">void Prime()</span><br><span class="line">&#123;</span><br><span class="line">    int n&#x3D;200;</span><br><span class="line">    int k&#x3D;0;</span><br><span class="line">    memset(Is_or,1,sizeof(Is_or));</span><br><span class="line">    Is_or[0]&#x3D;Is_or[1]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;2; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(Is_or[i])</span><br><span class="line">        &#123;</span><br><span class="line">        prime[k++]&#x3D;i;</span><br><span class="line">            for(int j&#x3D;i+i; j&lt;n; j+&#x3D;i)</span><br><span class="line">            &#123;</span><br><span class="line">                Is_or[j]&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Phi(LL n)</span><br><span class="line">&#123;</span><br><span class="line">    LL rea&#x3D;n;</span><br><span class="line">    for(int i&#x3D;0; prime[i]*prime[i]&lt;&#x3D;n&amp;&amp;i&lt;kp; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n%prime[i]&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            rea&#x3D;rea-rea&#x2F;prime[i];</span><br><span class="line">            while(n%prime[i]&#x3D;&#x3D;0)</span><br><span class="line">                n&#x2F;&#x3D;prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n&gt;1)    rea&#x3D;rea-rea&#x2F;n;</span><br><span class="line">    return rea;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;************************&#x2F;</span><br><span class="line">O(n)求素数+欧拉函数</span><br><span class="line">用最小的素因子筛掉每个数</span><br><span class="line">int prime[N],phi[N],cnt;&#x2F;&#x2F; prime:记录质数，phi记录欧拉函数</span><br><span class="line">int Min_factor[N];&#x2F;&#x2F; i的最小素因子</span><br><span class="line">bool vis[N];</span><br><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">    cnt&#x3D;0;</span><br><span class="line">    phi[1]&#x3D;1;</span><br><span class="line">    int x;</span><br><span class="line">    for(int i&#x3D;2;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt]&#x3D;i;</span><br><span class="line">            phi[i]&#x3D;i-1;</span><br><span class="line">            Min_factor[i]&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k&#x3D;1;k&lt;&#x3D;cnt&amp;&amp;prime[k]*i&lt;N;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            x&#x3D;prime[k]*i;</span><br><span class="line">            vis[x]&#x3D;true;</span><br><span class="line">            Min_factor[x]&#x3D;prime[k];</span><br><span class="line">            if(i%prime[k]&#x3D;&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[x]&#x3D;phi[i]*prime[k];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else phi[x]&#x3D;phi[i]*(prime[k]-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h1><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Matrix</span><br><span class="line">&#123;</span><br><span class="line">    LL m[M][M];</span><br><span class="line">    void clearO()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;M; i++) &#x2F;&#x2F;初始化矩阵</span><br><span class="line">            for(int j&#x3D;0; j&lt;M; j++)</span><br><span class="line">                m[i][j]&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void clearE()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;M; i++) &#x2F;&#x2F;初始化矩阵</span><br><span class="line">            for(int j&#x3D;0; j&lt;M; j++)</span><br><span class="line">                m[i][j]&#x3D; (i&#x3D;&#x3D;j);</span><br><span class="line">    &#125;</span><br><span class="line">    void display()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;M; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j&#x3D;0; j&lt;M; j++)</span><br><span class="line">                printf(&quot;%d &quot;,m[i][j]);</span><br><span class="line">                puts(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix operator * (Matrix a,Matrix b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    c.clearO();</span><br><span class="line"></span><br><span class="line">    for(int k&#x3D;0; k&lt;M; k++)</span><br><span class="line">        for(int i&#x3D;0; i&lt;M; i++) &#x2F;&#x2F;实现矩阵乘法</span><br><span class="line">        &#123;</span><br><span class="line">            if(a.m[i][k] &lt;&#x3D; 0)  continue;</span><br><span class="line">            for(int j&#x3D;0; j&lt;M; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(b.m[k][j] &lt;&#x3D; 0)    continue;</span><br><span class="line">                c.m[i][j]&#x3D;(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix operator ^ (Matrix a,LL b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    c.clearE();</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) c&#x3D; c * a ;</span><br><span class="line">        b &gt;&gt;&#x3D; 1;</span><br><span class="line">        a &#x3D; a * a ;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line"># include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"># define INF 0x3f3f3f3f</span><br><span class="line"># define pb push_back</span><br><span class="line"># define abs(a) (a)&gt;0?(a):-(a)</span><br><span class="line"># define min(a,b) (a)&gt;(b)?(a):(b)</span><br><span class="line"># define lalal puts(&quot;*******&quot;);</span><br><span class="line">typedef long long int LL ;</span><br><span class="line">&#x2F;*******************************&#x2F;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 100+5;</span><br><span class="line">int MOD ;</span><br><span class="line"></span><br><span class="line">struct Matrix</span><br><span class="line">&#123;</span><br><span class="line">    LL m[N][N];</span><br><span class="line">    int row,culumn;</span><br><span class="line">    void clearE()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;row; i++)</span><br><span class="line">            for(int j&#x3D;0; j&lt;culumn; j++)</span><br><span class="line">                m[i][j]&#x3D;(i&#x3D;&#x3D;j);</span><br><span class="line">    &#125;</span><br><span class="line">    void clearO()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;row; i++)</span><br><span class="line">            for(int j&#x3D;0; j&lt;culumn; j++)</span><br><span class="line">                m[i][j]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    void display()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0; j&lt;culumn; j++)</span><br><span class="line">                printf(&quot;%d &quot;,m[i][j]);</span><br><span class="line">            puts(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;循环矩阵 * 的写法。。对于循环矩阵来说 行和列是一样都循环的 并不用特意区分</span><br><span class="line">Matrix operator *(Matrix &amp;a,Matrix &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    c.row&#x3D;a.row,c.culumn&#x3D;b.culumn,c.clearO();</span><br><span class="line"></span><br><span class="line">    for (int k &#x3D; 0; k &lt; a.culumn; k++)</span><br><span class="line">        if (a.m[0][k])</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; b.culumn; j++)</span><br><span class="line">                if (b.m[k][j])</span><br><span class="line">                    c.m[0][j] &#x3D; (c.m[0][j] + a.m[0][k] * b.m[k][j]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; c.culumn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c.m[i][0] &#x3D; c.m[i - 1][c.culumn - 1];</span><br><span class="line">        for (int j &#x3D; 1; j &lt; c.culumn; j++)</span><br><span class="line">            c.m[i][j] &#x3D; c.m[i - 1][j - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix operator ^(Matrix &amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    c.row&#x3D;a.row,c.culumn&#x3D;a.culumn,c.clearE();</span><br><span class="line"></span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1) c&#x3D;c*a;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL n,m,L,R,M;</span><br><span class="line">        scanf(&quot;%I64d%I64d%I64d%I64d%I64d&quot;,&amp;n,&amp;m,&amp;L,&amp;R,&amp;M);</span><br><span class="line"></span><br><span class="line">        MOD&#x3D;M;</span><br><span class="line">        Matrix a,b;</span><br><span class="line">        a.row&#x3D;1,b.row&#x3D;a.culumn&#x3D;b.culumn&#x3D;n,a.clearO(),b.clearO();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%I64d&quot;,&amp;a.m[0][i]);</span><br><span class="line">            a.m[0][i]%&#x3D;MOD;</span><br><span class="line">            b.m[(i-1+n)%n][i]&#x3D;R%MOD;</span><br><span class="line">            b.m[(i+1)%n][i]&#x3D;L%MOD;</span><br><span class="line">            b.m[i][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        b&#x3D;b^(m);</span><br><span class="line">        a&#x3D;a*b;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i)printf(&quot; &quot;);</span><br><span class="line">            printf(&quot;%I64d&quot;,a.m[0][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FFT-NTT"><a href="#FFT-NTT" class="headerlink" title="FFT/NTT"></a>FFT/NTT</h3><p>用于快速求卷积$c=a⊗b$<br>卷积可以类比两个多项式相乘<br>正常暴力求卷积的复杂度是$O(n^2)$ ,但是通过FFT加速 求卷积的复杂度能降到$O(nlog_{2}n)$<br><a href="http://www.gatevin.moe/acm/fft%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external nofollow noopener noreferrer">算法学习笔记</a><br>FFT模板</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Complex&#123;</span><br><span class="line">    double real, image;</span><br><span class="line">    Complex(double _real, double _image)&#123;</span><br><span class="line">        real &#x3D; _real;</span><br><span class="line">        image &#x3D; _image;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Complex operator + (const Complex &amp;tmp)&#123;</span><br><span class="line">        return Complex(real + tmp.real, image + tmp.image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex operator - (const Complex &amp;tmp)&#123;</span><br><span class="line">        return Complex(real - tmp.real, image - tmp.image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex operator * (const Complex &amp;tmp)&#123;</span><br><span class="line">        return Complex(real*tmp.real - image*tmp.image, real*tmp.image + image*tmp.real);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int rev(int id, int len)&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; (1 &lt;&lt; i) &lt; len; i++)&#123;</span><br><span class="line">        ret &lt;&lt;&#x3D; 1;</span><br><span class="line">        if(id &amp; (1 &lt;&lt; i)) ret |&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">Complex A[N];</span><br><span class="line">void FFT(Complex *a, int len, int DFT)&#123;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        A[rev(i, len)] &#x3D; a[i];</span><br><span class="line">    for(int s &#x3D; 1; (1 &lt;&lt; s) &lt;&#x3D; len; s++)&#123;</span><br><span class="line">        int m &#x3D; (1 &lt;&lt; s);</span><br><span class="line">        Complex wm &#x3D; Complex(cos(DFT*2*PI&#x2F;m), sin(DFT*2*PI&#x2F;m));</span><br><span class="line">        for(int k &#x3D; 0; k &lt; len; k +&#x3D; m)&#123;</span><br><span class="line">            Complex w &#x3D; Complex(1, 0);</span><br><span class="line">            for(int j &#x3D; 0; j &lt; (m &gt;&gt; 1); j++)&#123;</span><br><span class="line">                Complex t &#x3D; w*A[k + j + (m &gt;&gt; 1)];</span><br><span class="line">                Complex u &#x3D; A[k + j];</span><br><span class="line">                A[k + j] &#x3D; u + t;</span><br><span class="line">                A[k + j + (m &gt;&gt; 1)] &#x3D; u - t;</span><br><span class="line">                w &#x3D; w*wm;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(DFT &#x3D;&#x3D; -1) for(int i &#x3D; 0; i &lt; len; i++) A[i].real &#x2F;&#x3D; len, A[i].image &#x2F;&#x3D; len;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; len; i++) a[i] &#x3D; A[i];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    求卷积c&#x3D;a⊗b</span><br><span class="line">    la为a的长度</span><br><span class="line">    lb为b的长度</span><br><span class="line">    len为最后结果的长度.</span><br><span class="line">    **&#x2F;</span><br><span class="line">    int sa,sb;</span><br><span class="line">    sa&#x3D;sb&#x3D;0;</span><br><span class="line">    while((1&lt;&lt;sa)&lt;la) sa++;</span><br><span class="line">    while((1&lt;&lt;sb)&lt;lb) sb++;</span><br><span class="line">    int len &#x3D; (1&lt;&lt;(max(sa,sb)+1));</span><br><span class="line">    A &#x3D; FFT(A,len,1);</span><br><span class="line">    B &#x3D; FFT(B,len,1);</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)  A[i]&#x3D;A[i]*B[i],ans[i]&#x3D;0;</span><br><span class="line">    A &#x3D; FFT(A,len,-1);</span><br><span class="line">    &#x2F;**</span><br><span class="line">    这是最后的卷积的结果.</span><br><span class="line">    **&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NTT</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int Maxn&#x3D;50000;</span><br><span class="line"></span><br><span class="line">LL A[Maxn&lt;&lt;2],B[Maxn&lt;&lt;2];</span><br><span class="line">int ans[Maxn&lt;&lt;2];</span><br><span class="line"></span><br><span class="line">inline LL qmod(LL a, LL b,LL P) &#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    for(; b; b&gt;&gt;&#x3D;1, a&#x3D;a*a%P)</span><br><span class="line">        if(b&amp;1) ans&#x3D;ans*a%P;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">struct NTT &#123;</span><br><span class="line">    int pos[Maxn&lt;&lt;2],k,G,Mod;</span><br><span class="line">    inline void init(int len) &#123;</span><br><span class="line">        Mod &#x3D; 998244353,G &#x3D; 3;</span><br><span class="line">        for(k&#x3D;1; k&lt;&#x3D;len; k&lt;&lt;&#x3D;1);</span><br><span class="line">        for(int i&#x3D;1; i&lt;k; i++)</span><br><span class="line">            pos[i]&#x3D;(i&amp;1)?((pos[i&gt;&gt;1]&gt;&gt;1)^(k&gt;&gt;1)):(pos[i&gt;&gt;1]&gt;&gt;1);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void dft(LL *a) &#123;</span><br><span class="line">        for(int i&#x3D;1; i&lt;k; i++)if(pos[i]&gt;i)swap(a[pos[i]],a[i]);</span><br><span class="line">        for(int m1&#x3D;1; m1&lt;k; m1&lt;&lt;&#x3D;1) &#123;</span><br><span class="line">            int m2&#x3D;m1&lt;&lt;1;</span><br><span class="line">            LL wn&#x3D;qmod(G,(Mod-1)&#x2F;m2,Mod)%Mod;</span><br><span class="line">            for(int i&#x3D;0; i&lt;k; i+&#x3D;m2) &#123;</span><br><span class="line">                LL w&#x3D;1;</span><br><span class="line">                for(int j&#x3D;0; j&lt;m1; j++) &#123;</span><br><span class="line">                    LL &amp;A&#x3D;a[i+j],&amp;B&#x3D;a[i+j+m1],t&#x3D;B*w%Mod;</span><br><span class="line">                    B&#x3D;(A-t+Mod)%Mod;</span><br><span class="line">                    A&#x3D;(A+t)%Mod;</span><br><span class="line">                    w&#x3D;w*wn%Mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inline void mui(LL *A,LL *B,int m) &#123;</span><br><span class="line">        init(m);</span><br><span class="line">        dft(A);dft(B);</span><br><span class="line">        for(int i&#x3D;0; i&lt;k; i++)A[i]&#x3D;A[i]*B[i]%Mod;</span><br><span class="line">        dft(A);</span><br><span class="line">        reverse(A+1,A+k);</span><br><span class="line">        int inv&#x3D;qmod(k,Mod-2,Mod)%Mod;</span><br><span class="line">        for(int i&#x3D;0; i&lt;k; i++)A[i]&#x3D;inv*A[i]%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ntt;</span><br></pre></td></tr></table></figure><h3 id="牛顿迭代法-线性开根"><a href="#牛顿迭代法-线性开根" class="headerlink" title="牛顿迭代法 线性开根"></a>牛顿迭代法 线性开根</h3><blockquote><p>下面这种方法可以很有效地求出根号a的近似值：首先随便猜一个近似值x，然后不断令x等于x和a/x的平均数，迭代个六七次后x的值就已经相当精确了。<br> ( 4 + 2/ 4 ) / 2 = 2.25<br> ( 2.25 + 2/ 2.25 ) / 2 = 1.56944..<br> ( 1.56944..+ 2/1.56944..) / 2 = 1.42189..<br> ( 1.42189..+ 2/1.42189..) / 2 = 1.41423..<br> 这种算法的原理很简单，我们仅仅是不断用(x,f(x))的切线来逼近方程x^2-a=0的根。根号a实际上就是x^2-a=0的一个正实根，这个函数的导数是2x。也就是说，函数上任一点(x,f(x))处的切线斜率是2x。那么，x-f(x)/(2x)就是一个比x更接近的近似值。代入f(x)=x^2-a得到x-(x^2-a)/(2x)，也就是(x+a/x)/2。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const float EPS &#x3D; 1e-5;</span><br><span class="line">int sqrt(double x) &#123;</span><br><span class="line">    if(x &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    double result &#x3D; x; &#x2F;*Use double to avoid possible overflow*&#x2F;</span><br><span class="line">    double lastValue;</span><br><span class="line">    do&#123;</span><br><span class="line">        lastValue &#x3D; result;</span><br><span class="line">        result &#x3D; result &#x2F; 2.0f + x &#x2F; 2.0f &#x2F; result;</span><br><span class="line">    &#125;while(abs(result - lastValue) &gt; EPS);</span><br><span class="line"> return (double)result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="更牛逼的一种开跟方式-快的一笔"><a href="#更牛逼的一种开跟方式-快的一笔" class="headerlink" title="更牛逼的一种开跟方式  快的一笔"></a>更牛逼的一种开跟方式 快的一笔</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">来自雷神之锤III的源代码中q_math.c的文件中。</span><br><span class="line">*&#x2F;</span><br><span class="line">float Q_rsqrt( float number ) &#123;</span><br><span class="line">    long i; float x2, y; const float threehalfs &#x3D; 1.5F;</span><br><span class="line">    x2 &#x3D; number * 0.5F;</span><br><span class="line">    y &#x3D; number;</span><br><span class="line">    i &#x3D; * ( long * ) &amp;y; &#x2F;&#x2F; evil floating point bit level hacking</span><br><span class="line">    i &#x3D; 0x5f3759df - ( i &gt;&gt; 1 ); &#x2F;&#x2F; what the fuck?</span><br><span class="line">    y &#x3D; * ( float * ) &amp;i;</span><br><span class="line">    y &#x3D; y * ( threehalfs - ( x2 * y * y ) ); &#x2F;&#x2F; 1st iteration</span><br><span class="line">    &#x2F;&#x2F; y &#x3D; y * ( threehalfs - ( x2 * y * y ) ); &#x2F;&#x2F; 2nd iteration, this can be removed</span><br><span class="line">    #ifndef Q3_VM #</span><br><span class="line">    ifdef __linux__ assert( !isnan(y) ); &#x2F;&#x2F; bk010122 - FPE?</span><br><span class="line">    #endif</span><br><span class="line">    #endif return y;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;整理得到</span><br><span class="line">int sqrt(float x) &#123;</span><br><span class="line">    if(x &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    float result &#x3D; x;</span><br><span class="line">    float xhalf &#x3D; 0.5f*result;</span><br><span class="line">    int i &#x3D; *(int*)&amp;result;</span><br><span class="line">    i &#x3D; 0x5f375a86- (i&gt;&gt;1); &#x2F;&#x2F; what the fuck?</span><br><span class="line">    result &#x3D; *(float*)&amp;i;</span><br><span class="line">    result &#x3D; result*(1.5f-xhalf*result*result); &#x2F;&#x2F; Newton step, repeating increases accuracy</span><br><span class="line">    result &#x3D; result*(1.5f-xhalf*result*result);</span><br><span class="line">    return 1.0f&#x2F;result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$O(n)$预处理逆元</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一  i的逆元</span><br><span class="line">inv[1] &#x3D; 1;</span><br><span class="line">for (int i &#x3D; 2; i&lt;MAXN; i++)</span><br><span class="line">    inv[i] &#x3D; inv[MOD%i]*(MOD-MOD&#x2F;i)%MOD;</span><br><span class="line">方法二  inv&#123;(n-i)!&#125; &#x3D; inv(n!)*n    &#x2F;&#x2F;阶乘逆元</span><br><span class="line">Fac[0] &#x3D; 1;</span><br><span class="line">for (int i &#x3D; 1; i &lt; N; i++) Fac[i] &#x3D; (Fac[i-1] * i) % MOD;</span><br><span class="line">Inv[N-1] &#x3D; pow_mod(Fac[N-1], MOD-2);&#x2F;&#x2F;Fac[N]^&#123;MOD-2&#125;</span><br><span class="line">for (int i &#x3D; N - 2; i &gt;&#x3D; 0; i--) Inv[i] &#x3D; Inv[i+1] * (i + 1) % MOD;</span><br><span class="line">方法三  费马小定理</span><br><span class="line">fac[0]&#x3D;1;</span><br><span class="line">for(int i&#x3D;1;i&lt;N;i++)fac[i]&#x3D;fac[i-1]*i%MOD;</span><br><span class="line">for(int i&#x3D;1;i&lt;N;i++)inv[i]&#x3D;qmod(fac[i],MOD-2);</span><br></pre></td></tr></table></figure><h1 id="数学概念"><a href="#数学概念" class="headerlink" title="数学概念"></a>数学概念</h1><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><pre><code>不赘述
</code></pre><h2 id="反素数"><a href="#反素数" class="headerlink" title="反素数"></a>反素数</h2><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p><strong>定义</strong>：设$m&gt;1$，$\gcd(a,m)=1$，使得$a^{r} \equiv(\mod m)$成立的最小的$r$，称为$a$对模$m$的阶，记为。$\delta_{m}(a)$</p><p><strong>定理</strong>：如果模$m$有原根，那么它一共有个$\varphi(\varphi(m))$原根。</p><p><strong>定理</strong>：若$m&gt;1$，$\gcd(a,m)=1$，$a^{n} \equiv(\mod m)$则$\delta_{m}(a)|n$。</p><p><strong>定理</strong>：如果$p$为素数，那么素数$p$一定存在原根，并且模$p$的原根的个数为$\varphi(p-1)$。</p><p><strong>定理</strong>：设$m$是正整数，$a$是整数，若$a$模$m$的阶等于$\varphi(m)$，则称$a$为模$m$的一个原根。</p><p> 假设一个数$g$对于模$m$来说是原根，那么$g^{i}\mod p$的结果两两不同,且有$1\lt g\lt p$，$0\le i\lt p$那么$g$可以称为是模$p$的一个原根，归根到底就是$g^{p-1}\equiv (\mod p)$当且仅当指数为$p-1$的时候成立。（这里是素数）</p><p>模$m$有原根的充要条件：$m=2,4,p^a,2p^a$，其中$p$是奇素数。</p><p>求模素数$P$原根的方法：对$p-1$素因子分解，即$p-1=p_1^{a_1}p_2^{a_2}...p_k^{a_k}$是的标准分解式，若恒有<br> $g^{\frac{p-1}{p_i} } \neq 1(\mod p)$</p><p>成立，则$g$就是$p$的原根。（对于合数求原根，只需把$p-1$换成$\varphi(p)$即可）</p><p><a href="http://blog.csdn.net/zhang20072844/article/details/11541133" target="_blank" rel="external nofollow noopener noreferrer">求解原根的优化方法</a></p><p>求解原根的完整代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果mod 为素数</span><br><span class="line">int get(int mod) &#123;</span><br><span class="line">    for(int i &#x3D; 2; ; i++) &#123;</span><br><span class="line">        set&lt;int&gt; s;</span><br><span class="line">        for(int j &#x3D; 1, x &#x3D; 1; j &lt; mod; j++) &#123;</span><br><span class="line">            x &#x3D; (x*i)%mod;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.size() &#x3D;&#x3D; mod-1) return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;注意爆int，所以用LL</span><br><span class="line">LL qmod(LL a,LL b,LL c)&#123;</span><br><span class="line">    LL res &#x3D; 1;a%&#x3D;c;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) res&#x3D;res*a%c;</span><br><span class="line">        b&gt;&gt;&#x3D;1,a&#x3D;a*a%c;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int prime[N];</span><br><span class="line">int Is_or[N][2];</span><br><span class="line"></span><br><span class="line">void Prime()&#123;</span><br><span class="line">    int n &#x3D; 100000;</span><br><span class="line">    prime[0]&#x3D;0;</span><br><span class="line">    memset(Is_or,1,sizeof(Is_or));</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(Is_or[i][0]) prime[++prime[0]]&#x3D;i,Is_or[i][1]&#x3D;prime[0];</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;prime[0]&amp;&amp;i*prime[j]&lt;&#x3D;n;j++)&#123;</span><br><span class="line">            Is_or[i*prime[j]][0]&#x3D;0;</span><br><span class="line">            if(0&#x3D;&#x3D;i%prime[j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Phi(int x)&#123;</span><br><span class="line">    &#x2F;&#x2F;因为本题中数据都是质数，所以欧拉函数值就都是x-1了。</span><br><span class="line">    return x-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[10000],cnt;</span><br><span class="line">void divide(int n)&#123;</span><br><span class="line">    cnt &#x3D; 0;</span><br><span class="line">    for(int i&#x3D;1;prime[i]*prime[i]&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(n&lt;&#x3D;prime[prime[0]]&amp;&amp;Is_or[n][0])&#123;a[++cnt]&#x3D;n;n&#x3D;1;break;&#125;</span><br><span class="line">        if(n%prime[i]&#x3D;&#x3D;0)&#123;a[++cnt]&#x3D;prime[i];n&#x2F;&#x3D;prime[i];&#125;</span><br><span class="line">        while(n%prime[i]&#x3D;&#x3D;0)&#123;n&#x2F;&#x3D;prime[i];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n&gt;1)a[++cnt]&#x3D;n;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work(int n)&#123;</span><br><span class="line">    int phi &#x3D; Phi(n);</span><br><span class="line">    bool flag ;</span><br><span class="line">    for(int i&#x3D;2;i&lt;n;i++)&#123; &#x2F;&#x2F;一个数的原根是很小的 所以暴力枚举就行,但其实是有优化方法的,</span><br><span class="line">        flag &#x3D; true;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;cnt;j++)&#123;</span><br><span class="line">            int tmp &#x3D; phi&#x2F;a[j];</span><br><span class="line">            if(qmod(i,tmp,n)&#x3D;&#x3D;1)&#123;</span><br><span class="line">                flag &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,i);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;没有原根&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Prime();</span><br><span class="line">    int n;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        divide(Phi(n));</span><br><span class="line">        work(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="footer"><div class="copyright"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="http://blog.tabris.top/2016-05-24-51488462/">http://blog.tabris.top/2016-05-24-51488462/</a></p></blockquote></div></div><div class="article-meta" id="bottom"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-05-04T11:57:14+00:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>本页文档最后更新于：2021年5月4日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/csdn/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>CSDN</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%95%B0%E8%AE%BA/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>数论</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"> <a class="-mob-share-qq" title rel="external nofollow noopener noreferrer" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.tabris.top/2016-05-24-51488462/&title=[原创]数论各种小定理 - tabris的博客&summary=[原创]数论各种小定理
2016-05-24 10:54:37  Tabris_ 阅读数：1852

博客爬取于2020-06-14 22:39:18以下为正文
版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。https://blog.csdn.net/qq_33184171/article/details/51488462"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></a> <a class="-mob-share-qzone" title rel="external nofollow noopener noreferrer" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.tabris.top/2016-05-24-51488462/&title=[原创]数论各种小定理 - tabris的博客&summary=[原创]数论各种小定理
2016-05-24 10:54:37  Tabris_ 阅读数：1852

博客爬取于2020-06-14 22:39:18以下为正文
版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。https://blog.csdn.net/qq_33184171/article/details/51488462"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></a> <a class="-mob-share-weibo" title rel="external nofollow noopener noreferrer" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.tabris.top/2016-05-24-51488462/&title=[原创]数论各种小定理 - tabris的博客&summary=[原创]数论各种小定理
2016-05-24 10:54:37  Tabris_ 阅读数：1852

博客爬取于2020-06-14 22:39:18以下为正文
版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。https://blog.csdn.net/qq_33184171/article/details/51488462"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></a></div></div></div></div><div class="prev-next"><a class="prev" href="/2016-05-31-51544872/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>[原创]codeforces #354 div.2 C &&676C Vasya and String</p><p class="content">[原创]codeforces #354 div.2 C &amp;&amp;676C Vasya and String 2016-05-31 13:10:56 Tabris_ 阅读数：5...</p></a><a class="next" href="/2016-05-22-51476199/"><p class="title">[原创]组合数学各种小定理<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">[原创]组合数学各种小定理 2016-05-22 18:11:12 Tabris_ 阅读数：1482 博客爬取于2020-06-14 22:39:19以下为正文 版权声明：本文为Tabris...</p></a></div></article><article class="post white-box reveal shadow" id="comments"><p ct><i class="fas fa-comments"></i> 评论</p><div id="valine_container" class="valine_thread"><i class="fas fa-cog fa-spin fa-fw fa-2x"></i></div></article><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="https://cdn.jsdelivr.net/npm/mathjax@3.0/es5/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script></div><aside id="l_side"><section class="widget blogger shadow desktop mobile"><div class="content"> <a class="avatar flat-box rectangle" href="/about/"><img no-lazy src="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/avatar/avatar.jpg"></a><div class="text"><h2>tabris's blog</h2><p>Tabris</p><p><span id="jinrishici-sentence">tabris的博客</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a><a href="mailto:tabris.dq@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a><a href="https://github.com/tabris233/" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a><a href="/" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget toc-wrapper shadow desktop mobile" id="toc-div"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i> <span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%99%E6%95%B0%E5%AE%9A%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">余数定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97"><span class="toc-number">2.</span> <span class="toc-text">扩展欧几里得</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%85%83"><span class="toc-number">3.</span> <span class="toc-text">逆元</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E9%80%86%E5%85%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.1.</span> <span class="toc-text">求逆元的两种方法</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3%E9%AB%98%E6%AC%A1%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">求解高次同余方程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babystep%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.1.</span> <span class="toc-text">babystep算法模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E6%89%93%E7%B4%A0%E6%95%B0%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">线性筛法打素数表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%80%A7%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95-miller-rabbin"><span class="toc-number">6.</span> <span class="toc-text">随机性素数测试 miller-rabbin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pollard-rho-longlong%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">pollard_rho(longlong质因子分解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86%E5%B1%95%E5%BC%80"><span class="toc-number">8.</span> <span class="toc-text">算数基本定理展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">欧拉函数表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">10.</span> <span class="toc-text">矩阵快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FFT-NTT"><span class="toc-number">11.</span> <span class="toc-text">FFT&#x2F;NTT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%BC%80%E6%A0%B9"><span class="toc-number">12.</span> <span class="toc-text">牛顿迭代法 线性开根</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E7%89%9B%E9%80%BC%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BC%80%E8%B7%9F%E6%96%B9%E5%BC%8F-%E5%BF%AB%E7%9A%84%E4%B8%80%E7%AC%94"><span class="toc-number">12.1.</span> <span class="toc-text">更牛逼的一种开跟方式 快的一笔</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">素数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%B4%A0%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">反素数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9"><span class="toc-number"></span> <span class="toc-text">原根</span></a></li></div></section></aside><script>window.pdata={},pdata.ispage=!0,pdata.postTitle="[原创]数论各种小定理",pdata.commentPath="",pdata.commentPlaceholder="";var l_header=document.getElementById("l_header");l_header.classList.add("show");var cover_wrapper=document.querySelector("#l_cover .cover-wrapper"),scroll_down=document.getElementById("scroll-down");cover_wrapper.id="none",cover_wrapper.style.display="none",scroll_down.style.display="none"</script></div><footer class="footer clearfix"><br><br><div class="aplayer-container"><meting-js theme="#1BCDFC" autoplay="true" volume="0.4" loop="all" order="random" fixed="false" list-max-height="320px" server="netease" type="playlist" id="3175833810" list-folded="true"></meting-js></div><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a><a href="mailto:tabris.dq@qq.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a><a href="https://github.com/tabris233" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a><a href="https://music.163.com/#/user/home?id=63035382" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external nofollow noopener noreferrer">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p></div><div><p><span id="lc-sv">本站总访问量为<span id="number"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为<span id="number"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p></div> 本站使用 <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1" target="_blank" class="codename" rel="external nofollow noopener noreferrer">Volantis</a> 作为主题<div><p><a>粤ICP备</a> <a href="https://beian.miit.gov.cn" target="_blank" rel="external nofollow noopener noreferrer">2021020563号</a></p></div><div class="copyright"><p><a href="http://tabris.top/" target="_blank" rel="noopener external nofollow noreferrer">Copyright © 2017-2021 tabris</a></p></div></footer><a id="s-top" class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div></div><div><script>function RunItem(){function t(t,e){this.name=e||t.name,this.run=()=>{try{t()}catch(t){console.log(t)}}}this.list=[],this.start=()=>{for(var t=0;t<this.list.length;t++)this.list[t].run()},this.push=(e,n)=>{var s=new t(e,n);this.list.push(s)}}function loadScript(t,e){setTimeout((function(){var n=document.getElementsByTagName("head")[0]||document.documentElement,s=document.createElement("script");s.setAttribute("type","text/javascript"),e&&(s.onload=e),s.setAttribute("src",t),n.appendChild(s)}))}window.volantis={},volantis.$={},volantis.pjax={},volantis.pjax.method={complete:new RunItem,error:new RunItem,send:new RunItem},volantis.pjax={...volantis.pjax,push:volantis.pjax.method.complete.push,error:volantis.pjax.method.error.push,send:volantis.pjax.method.send.push},volantis.dark={},volantis.dark.method={toggle:new RunItem},volantis.dark={...volantis.dark,push:volantis.dark.method.toggle.push},volantis.plugins={jQuery:"https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js",sitesjs:"/js/plugins/sites.js",friendsjs:"/js/plugins/friends.js",contributorsjs:"/js/plugins/contributors.js"};var loadCSS=function(t,e,n,s){var i,o=window.document,r=o.createElement("link");if(e)i=e;else{var a=(o.body||o.getElementsByTagName("head")[0]).childNodes;i=a[a.length-1]}var l=o.styleSheets;if(s)for(var d in s)s.hasOwnProperty(d)&&r.setAttribute(d,s[d]);r.rel="stylesheet",r.href=t,r.media="only x",function t(e){if(o.body)return e();setTimeout((function(){t(e)}))}((function(){i.parentNode.insertBefore(r,e?i:i.nextSibling)}));var u=function(t){for(var e=r.href,n=l.length;n--;)if(l[n].href===e)return t();setTimeout((function(){u(t)}))};function h(){r.addEventListener&&r.removeEventListener("load",h),r.media=n||"all"}return r.addEventListener&&r.addEventListener("load",h),r.onloadcssdefined=u,u(h),r}</script><script>loadCSS("https://cdn.jsdelivr.net/gh/volantis-x/cdn-fontawesome-pro@master/css/all.min.css")</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script><script>function pjax_fancybox(){$(".md .gallery").find("img").each((function(){var a=document.createElement("a");$(a).attr("class","fancybox"),$(a).attr("pjax-fancybox",""),$(a).attr("href",$(this).attr("src")),$(this).attr("data-original")&&$(a).attr("href",$(this).attr("data-original")),$(a).attr("data-fancybox","images");var t="";$(this).attr("alt")&&"image"!==$(this).attr("alt")&&($(a).attr("data-caption",$(this).attr("alt")),t=$(this).attr("alt"));var n=document.createElement("div");$(n).addClass("fancybox"),$(this).wrap(n);var o=document.createElement("span");$(o).addClass("image-caption"),$(o).text(t),$(this).after(o),$(this).wrap(a)})),$(".md .gallery").find("img").fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1,closeClick:!0,helpers:{overlay:{closeClick:!0}},buttons:["zoom","close"]})}function SCload_fancybox(){0!=$(".md .gallery").find("img").length&&(loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"),loadScript("https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js",pjax_fancybox))}function Pjax_SCload_fancybox(){void 0===$.fancybox?SCload_fancybox():pjax_fancybox()}$((function(){SCload_fancybox()})),volantis.pjax.push(Pjax_SCload_fancybox),volantis.pjax.send(()=>{void 0!==$.fancybox&&$.fancybox.close()},"fancybox")</script><div id="rightmenu-wrapper"><ul class="list-v rightmenu" id="rightmenu-content"><li class="navigation menuNavigation-Content"><a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa fa-arrow-left fa-fw"></i></a><a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa fa-arrow-right fa-fw"></i></a><a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa fa-redo fa-fw"></i></a><a class="nav icon-only fix-cursor-default" href="/"><i class="fa fa-home fa-fw"></i></a></li><li class="option menuOption-Content"><span class="vlts-menu opt fix-cursor-default menu-Option" data-fn-type="copyText"><i class="fa fa-copy fa-fw"></i> 复制文本</span><span class="vlts-menu opt fix-cursor-default menu-Option" data-fn-type="copyPaste"><i class="fa fa-paste fa-fw mR12"></i> 粘贴文本</span><span class="vlts-menu opt fix-cursor-default menu-Option" data-fn-type="copySelect"><i class="fa fa-object-ungroup fa-fw mR12"></i> 全选文本</span><span class="vlts-menu opt fix-cursor-default menu-Option" data-fn-type="copyCut"><i class="fa fa-cut fa-fw mR12"></i> 剪切文本</span><span class="vlts-menu opt fix-cursor-default menu-Option" data-fn-type="openTab"><i class="fa fa-external-link-square-alt fa-fw mR12"></i> 在新标签页打开</span><span class="vlts-menu opt fix-cursor-default menu-Option" data-fn-type="copySrc"><i class="fa fa-image fa-fw mR12"></i> 复制图片地址</span><span class="vlts-menu opt fix-cursor-default menu-Option" data-fn-type="copyImg"><i class="fa fa-images fa-fw mR12"></i> 复制图片文件</span></li><hr class="menuLoad-Content"><li class="menuLoad-Content"><a class="vlts-menu fix-cursor-default" href="https://volantis.js.org/faqs/" id="https:volantisjsorgfaqs" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-question fa-fw"></i> 常见问题</a></li><li class="menuLoad-Content"><a class="vlts-menu fix-cursor-default" href="https://volantis.js.org/examples/" id="https:volantisjsorgexamples" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-rss fa-fw"></i> 示例博客</a></li><li class="menuLoad-Content"><a class="vlts-menu fix-cursor-default" href="https://volantis.js.org/contributors/" id="https:volantisjsorgcontributors" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fan fa-spin fa-fw"></i> 加入社区</a></li><hr class="menuLoad-Content"><li class="menuLoad-Content"><a class="vlts-menu fix-cursor-default" href="https://github.com/volantis-x/volantis-docs/" id="https:githubcomvolantis-xvolantis-docs" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-code-branch fa-fw"></i> 本站源码</a></li><li class="menuLoad-Content"><a class="vlts-menu fix-cursor-default" href="https://github.com/volantis-x/hexo-theme-volantis/" id="https:githubcomvolantis-xhexo-theme-volantis" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-code-branch fa-fw"></i> 主题源码</a></li><hr class="menuLoad-Content"><li class="option menuOption-Content"><span class="vlts-menu opt fix-cursor-default" id="printHtml"><i class="fa fa-print fa-fw"></i> 打印页面</span></li><li class="option menuOption-Content"><span class="vlts-menu opt fix-cursor-default toggle-mode-btn" id="menuDarkBtn"><i class="fa fa-moon fa-fw"></i> 暗黑模式</span></li><hr class="menuLoad-Content"><li class="music name menuOption-Content"><p class="nav music-title fix-cursor-default"></p></li><li class="music ctrl"><a class="nav icon-only backward fix-cursor-default" onclick="aplayerBackward()"><i class="fa fa-step-backward fa-fw"></i></a><a class="nav icon-only toggle fix-cursor-default" onclick="aplayerToggle()"><i class="fa fa-play fa-fw"></i></a><a class="nav icon-only forward fix-cursor-default" onclick="aplayerForward()"><i class="fa fa-step-forward fa-fw"></i></a></li><li class="music volume"><a class="nav volume"><div class="aplayer-volume-bar-wrap"><div class="aplayer-volume-bar fix-cursor-pointer"><div class="aplayer-volume"></div><i class="left fa fa-volume-off fa-fw"></i><i class="right fa fa-volume-up fa-fw"></i></div></div></a></li></ul></div><script>$((function(){RightMenu.init()}));const RightMenu=(()=>{const e={},t=$("#printHtml"),n=$("#menuDarkBtn"),o=$(".menuLoad-Content"),i=($(".menuOption-Content"),$("#rightmenu-wrapper")[0]),c=$("#rightmenu-content")[0],r=$('.menu-Option[data-fn-type="copyText"]'),a=$('.menu-Option[data-fn-type="copyPaste"]'),s=$('.menu-Option[data-fn-type="copySelect"]'),l=$('.menu-Option[data-fn-type="copyCut"]'),d=$('.menu-Option[data-fn-type="copyHref"]'),u=$('.menu-Option[data-fn-type="copySrc"]'),h=$('.menu-Option[data-fn-type="copyImg"]'),g=$('.menu-Option[data-fn-type="openTab"]'),p=/^((https|http)?:\/\/)+[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&_~`@[\]\':+!]*([^<>\"\"])*$/;return e.init=()=>{$(".menu-Option").hide()},e.initEvent=()=>{window.document.oncontextmenu=t=>t.ctrlKey||$(window).width()<=500?(e.hideMenu(),!0):e.popMenu(t),i.oncontextmenu=e=>(e.stopPropagation(),e.preventDefault(),!1),$(window).off("click.rightMenu").on("click.rightMenu",()=>{e.hideMenu()}),$(window).off("blur.rightMenu").on("blur.rightMenu",()=>{e.hideMenu()}),$(i).off("blur.rightMenu").on("blur.rightMenu",()=>{e.hideMenu()})},e.popMenu=t=>{let n=t.clientX,o=t.clientY,r=document.documentElement.clientWidth||document.body.clientWidth,a=document.documentElement.clientHeight||document.body.clientHeight;try{e.setMenuItem(t),$(i).focus(),i.style.display="block",i.style.zIndex="-2147483648";let s=c.offsetWidth,l=c.offsetHeight,d=n+s>r?n-s+10:n,u=o+l>a?o-l+10:o;i.style.left=d+"px",i.style.top=u+"px",i.style.zIndex="2147483648"}catch(e){return $(i).blur(),console.error(e),!0}return!1},e.setMenuItem=i=>{let c=!1;const m=i.target,f=window.getSelection().toString();if(g.hide(),n&&n.off("click.rightMenu").one("click.rightMenu",e=>{n.children().toggleClass("fa fa-moon"),n.children().toggleClass("fa fa-sun")}),$(m).is("input")||$(m).is("textarea")){const t=$(m).val();t.length>0?(s.show(),s.off("click.rightMenu").one("click.rightMenu",()=>{$(m).select()})):s.hide(),f?(l.show(),l.off("click.rightMenu").one("click.rightMenu",()=>{const n=m.selectionStart,o=m.selectionEnd;e.copyString(f),$(m).val(t.substring(0,n)+t.substring(o,t.length)),m.selectionStart=n,m.selectionEnd=n,$(m).focus()})):l.hide(),e.readClipboard().then(t=>{t?(a.show(),a.off("click.rightMenu").one("click.rightMenu",()=>{e.insertAtCaret($(m),t)})):a.hide()}).catch(e=>{console.error(e),a.hide()})}else s.hide(),a.hide(),l.hide();const w=m.href;w&&p.test(w)?(c=!0,d.show(),g.show(),d.off("click.rightMenu").one("click.rightMenu",()=>{e.copyString(w)}),g.off("click.rightMenu").one("click.rightMenu",()=>{window.open(w)})):d.hide();const y=m.currentSrc;y&&p.test(y)?(c=!0,u.show(),g.show(),u.off("click.rightMenu").one("click.rightMenu",()=>{e.copyString(y)}),g.off("click.rightMenu").one("click.rightMenu",()=>{window.open(y)})):u.hide(),y&&p.test(y)&&y.trimEnd().endsWith(".png")?(c=!0,h.show(),h.off("click.rightMenu").one("click.rightMenu",()=>{e.writeClipImg(i,()=>{volantis.message("操作提示","复制成功！","success")},e=>{volantis.message("操作提示","复制失败："+e,"error")})})):h.hide(),f?(c=!0,r.show(),r.off("click.rightMenu").one("click.rightMenu",()=>{e.copyString(f)})):r.hide();const b=$("#post.article").html()||null,M=window.location.pathname;b?(t.show(),t.off("click.rightMenu").one("click.rightMenu",t=>{window.location.pathname===M?e.printHtml():e.hideMenu()})):t.hide(),c?o.hide():o.show(),volantis.APlayerLoaded&&checkAPlayer()},e.hideMenu=()=>{i.style.display="none"},e.copyString=t=>{e.writeClipText(t).then(()=>{volantis.message("操作提示",t.length>120?t.substring(0,120)+"...":t,"info")}).catch(e=>{volantis.message("操作提示",e,"error")})},e.writeClipText=e=>{try{return navigator.clipboard.writeText(e).then(()=>Promise.resolve()).catch(e=>Promise.reject(e))}catch(t){const n=document.createElement("input");n.setAttribute("readonly","readonly"),document.body.appendChild(n),n.setAttribute("value",e),n.select();try{let e=document.execCommand("copy");return document.body.removeChild(n),e&&"unsuccessful"!==e?Promise.resolve():Promise.reject("复制文本失败!")}catch(e){return document.body.removeChild(n),Promise.reject("当前浏览器不支持复制功能，请检查更新或更换其他浏览器操作!")}}},e.writeClipImg=async function(e,t,n){const o=e.target.currentSrc,i=e.target.parentElement;try{const e=await fetch(o),i=await e.blob();await navigator.clipboard.write([new ClipboardItem({[i.type]:i})]).then(()=>{t()},e=>{console.error("图片复制失败：",e),n(e)})}catch(e){const o=document;try{if(o.body.createTextRange){const e=document.body.createTextRange();e.moveToElementText(i),e.select()}else if(window.getSelection){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(i),e.removeAllRanges(),e.addRange(t)}document.execCommand("copy"),window.getSelection().removeAllRanges(),t()}catch(e){console.error(e),n("不支持复制当前图片！")}}},e.readClipboard=async()=>{const e=await navigator.permissions.query({name:"clipboard-read"});return"granted"===e.state||"prompt"===e.state?navigator.clipboard.readText().then(e=>e).catch(e=>Promise.reject(e)):Promise.reject(e)},e.insertAtCaret=(e,t)=>{const n=e[0],o=n.selectionStart,i=n.selectionEnd;if(document.selection)e.focus(),document.selection.createRange().text=t,e.focus();else if(o||"0"==o){var c=n.scrollTop;n.value=n.value.substring(0,o)+t+n.value.substring(i,n.value.length),e.focus(),n.selectionStart=o+t.length,n.selectionEnd=o+t.length,n.scrollTop=c}else e.value+=t,e.focus()},e.printHtml=()=>{$("body").css({backgroundColor:"unset"}),$("#l_header").hide(),$("#l_cover").hide(),$("#l_side").hide(),$("#l_main").css({width:"100%"}),$("#post").css({"box-shadow":"none",background:"none",padding:"0"}),$("h1").css({"text-align":"center","font-weight":"600","font-size":"2rem","margin-bottom":"20px"}),$(".prev-next").hide(),$("#bottom").children().append('<div class="new-meta-item"><a class="tag" href="'+window.location.href+'" rel="nofollow" data-pjax-state=""><i class="fad fa-external-link fa-fw" aria-hidden="true"></i><p>本文地址：'+window.location.href+"</p></a></div>"),$("#comments").hide(),$("#s-top").hide(),$("footer").hide(),$("#rightmenu-wrapper").hide(),$("details").attr("open","true"),$(".tab-pane").css({display:"block"}),$(".tab-content").css({"border-top":"none"}),$(".highlight>table pre").css({"white-space":"pre-wrap","word-break":"break-all"}),$(".nav-tabs").hide(),$(".backstretch").hide(),$(".fancybox img").css({height:"auto",weight:"auto"}),$("img").removeAttr("srcset data-srcset").removeClass("img lazyload loaded"),$(document).click(),setTimeout(()=>{window.print(),document.body.innerHTML="",window.location.reload()},50)},{init:(t=!1)=>{e.init(),e.initEvent(),t&&volantis.message("操作提示","自定义右键注册成功。","success")},destroy:(t=!1)=>{e.hideMenu(),$(window).off("click.rightMenu"),$(window).off("blur.rightMenu"),$(i).off("blur.rightMenu"),window.document.oncontextmenu=()=>!0,t&&volantis.message("操作提示","自定义右键注销成功。","success")}}})()</script><script>const rootElement=document.documentElement,darkModeStorageKey="user-color-scheme",rootElementDarkModeAttributeName="data-user-color-scheme",setLS=(e,t)=>{localStorage.setItem(e,t)},removeLS=e=>{localStorage.removeItem(e)},getLS=e=>localStorage.getItem(e),getModeFromCSSMediaQuery=()=>window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",resetRootDarkModeAttributeAndLS=()=>{var e;rootElement.removeAttribute("data-user-color-scheme"),e=darkModeStorageKey,localStorage.removeItem(e)},validColorModeKeys={dark:!0,light:!0},applyCustomDarkModeSettings=e=>{const t=e||getLS(darkModeStorageKey);getCustomDarkMode(),t===getModeFromCSSMediaQuery()?resetRootDarkModeAttributeAndLS():validColorModeKeys[t]?rootElement.setAttribute("data-user-color-scheme",t):resetRootDarkModeAttributeAndLS()},invertDarkModeObj={dark:"light",light:"dark"},getCustomDarkMode=()=>{let e=getLS(darkModeStorageKey);if(validColorModeKeys[e])e=invertDarkModeObj[e];else{if(null!==e)return;e=invertDarkModeObj[getModeFromCSSMediaQuery()]}volantis.dark.mode="dark"==e?"light":"dark"},toggleCustomDarkMode=()=>{let e=getLS(darkModeStorageKey);if(validColorModeKeys[e])e=invertDarkModeObj[e];else{if(null!==e)return;e=invertDarkModeObj[getModeFromCSSMediaQuery()]}var t,o;return t=darkModeStorageKey,o=e,localStorage.setItem(t,o),e};volantis.dark.toggle=()=>{const e=toggleCustomDarkMode();applyCustomDarkModeSettings(e),volantis.dark.method.toggle.start()};var btn=$(".toggle-mode-btn","#wrapper,#rightmenu-wrapper");function bindToggleButton(){btn.on("click",volantis.dark.toggle)}applyCustomDarkModeSettings(),document.addEventListener("DOMContentLoaded",bindToggleButton),volantis.pjax.push(bindToggleButton),volantis.pjax.send(()=>{btn.unbind("click")},"toggle-mode-btn-unbind")</script><script>function loadIssuesJS(){if(volantis.plugins.sitesjs){null!=document.getElementById("sites-api")&&"undefined"==typeof SitesJS&&loadScript(volantis.plugins.sitesjs,{defer:!0})}if(volantis.plugins.friendsjs){null!=document.getElementById("friends-api")&&"undefined"==typeof FriendsJS&&loadScript(volantis.plugins.friendsjs,{defer:!0})}if(volantis.plugins.contributorsjs){null!=document.getElementById("contributors-api")&&"undefined"==typeof ContributorsJS&&loadScript(volantis.plugins.contributorsjs,{defer:!0})}}$((function(){loadIssuesJS()})),volantis.pjax.push(()=>{loadIssuesJS()})</script><script defer="defer" src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazyload",threshold:0},window.addEventListener("LazyLoad::Initialized",(function(n){window.lazyLoadInstance=n.detail.instance}),!1),document.addEventListener("DOMContentLoaded",(function(){lazyLoadInstance.update()})),document.addEventListener("pjax:complete",(function(){lazyLoadInstance.update()}))</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer="defer" src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>var clipboard=new ClipboardJS(".btn-copy",{target:function(e){return e.nextElementSibling}});function wait(e,i){window.setTimeout(e,i)}function pjax_initCopyCode(){if($(".highlight .code pre").length+$(".article pre code").length!=0){var e="";e+='<button class="btn-copy" data-clipboard-snippet="">',e+='<i class="fas fa-copy"></i><span>COPY</span>',e+="</button>",$(".highlight .code pre").before(e),$(".article pre code").before(e),clipboard.off("success").on("success",(function(e){let i=$(e.trigger);i.addClass("copied");let a=$(i.find("i"));a.removeClass("fa-copy"),a.addClass("fa-check-circle");let n=$(i.find("span"));n[0].innerText="COPIED",wait((function(){a.removeClass("fa-check-circle"),a.addClass("fa-copy"),n[0].innerText="COPY"}),2e3)})),clipboard.off("error").on("error",(function(e){e.clearSelection();let i=$(e.trigger);i.addClass("copy-failed");let a=$(i.find("i"));a.removeClass("fa-copy"),a.addClass("fa-times-circle");let n=$(i.find("span"));n[0].innerText="COPY FAILED",wait((function(){a.removeClass("fa-times-circle"),a.addClass("fa-copy"),n[0].innerText="COPY"}),2e3)}))}}$((function(){pjax_initCopyCode()})),volantis.pjax.push(pjax_initCopyCode)</script><script>let APlayerController=new Object;APlayerController.id="3175833810",APlayerController.volume="0.4",loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"),loadScript("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"),window.volantis.APlayerLoaded=0;var checkAPlayer=setInterval((function(){window.APlayer&&"block"==$("#safearea").css("display")&&(clearInterval(checkAPlayer),window.volantis.APlayerLoaded||window.MetingJSElement||(window.volantis.APlayerLoaded=1,loadScript("https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js")))}),100);loadScript("/js/aplayer.js")</script><script src="/js/valine.js"></script><script>function emoji(i,e,a){return i+"/"+i+"-"+e+"."+a}for(var emojiMaps={},i=1;i<=54;i++)emojiMaps["tieba-"+i]=emoji("tieba",i,"png");for(i=1;i<=101;i++)emojiMaps["qq-"+i]=emoji("qq",i,"gif");for(i=1;i<=116;i++)emojiMaps["aru-"+i]=emoji("aru",i,"gif");for(i=1;i<=125;i++)emojiMaps["twemoji-"+i]=emoji("twemoji",i,"png");for(i=1;i<=4;i++)emojiMaps["weibo-"+i]=emoji("weibo",i,"png");function pjax_valine(){if(!document.querySelectorAll("#valine_container")[0])return;let i=pdata.commentPlaceholder||"快来评论吧~",e=pdata.commentPath;if(0==e.length){e=""||decodeURI(window.location.pathname)}(new Valine).init(Object.assign({path:null,placeholder:"快来评论吧~",appId:"XkeYrd6r1FrJXgASPvPJa9Hp-gzGzoHsz",appKey:"de9Yfw8ns8xwf6S9eHOj82Wi",meta:["nick","mail","link"],requiredFields:["nick","mail"],enableQQ:!0,recordIP:!1,avatar:"robohash",pageSize:10,lang:"zh-cn",highlight:!0,mathJax:!1},{el:"#valine_container",path:e,placeholder:i,emojiCDN:"https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/",emojiMaps:emojiMaps}))}$((function(){pjax_valine()})),volantis.pjax.push(pjax_valine)</script><script src="/js/app.js"></script><script>const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/",ROOT="/".endsWith("/")?"/":"//";function listenSearch(){customSearch=new HexoSearch({imagePath:SearchServiceimagePath})}function setSearchService(){listenSearch()}$(".input.u-search-input").one("focus",(function(){loadScript("/js/search/hexo.js",setSearchService)}))</script><script defer="defer">const LCCounter={app_id:"XkeYrd6r1FrJXgASPvPJa9Hp-gzGzoHsz",app_key:"de9Yfw8ns8xwf6S9eHOj82Wi",custom_api_server:"https://lcapi.tabris.top",getRecord:(e,t,r)=>new Promise((function(n,o){e("get","/classes/Counter?where="+encodeURIComponent(JSON.stringify({url:t}))).then(e=>e.json()).then(({results:i,code:s,error:a})=>{if(401===s)throw a;if(i&&i.length>0){var l=i[0];n(l)}else e("post","/classes/Counter",{url:t,title:r,times:0}).then(e=>e.json()).then((e,t)=>{if(t)throw t;n(e)}).catch(e=>{console.error("Failed to create",e),o(e)})}).catch(e=>{console.error("LeanCloud Counter Error:",e),o(e)})})),increment:(e,t)=>new Promise((function(r,n){e("post","/batch",{requests:t}).then(e=>{if((e=e.json()).error)throw e.error;r(e)}).catch(e=>{console.error("Failed to save visitor count",e),n(e)})})),buildIncrement:e=>({method:"PUT",path:"/1.1/classes/Counter/"+e,body:{times:{__op:"Increment",amount:1}}}),validUV(){var e="LeanCloudUVTimestamp",t=localStorage.getItem(e);return!(t&&(new Date).getTime()-parseInt(t)<=864e5)&&(localStorage.setItem(e,(new Date).getTime().toString()),!0)},addCount(e){var t=[],r=[],n=document.querySelector("#lc-sv"),o=this.getRecord(e,"http://blog.tabris.top/#lc-sv","Visits").then(e=>{r.push(this.buildIncrement(e.objectId));var t=document.querySelectorAll("#lc-sv #number");t.length>0&&t.forEach((t,r,o)=>{t.innerText=e.times+1,n&&(n.style.display="inline")})});t.push(o);var s=document.querySelector("#lc-uv"),a=this.getRecord(e,"http://blog.tabris.top/#lc-uv","Visitors").then(e=>{var t=this.validUV();t&&r.push(this.buildIncrement(e.objectId));var n=document.querySelectorAll("#lc-uv #number");n.length>0&&n.forEach((r,n,o)=>{r.innerText=e.times+(t?1:0),s&&(s.style.display="inline")})});t.push(a);var l=document.querySelectorAll("#lc-pv");for(l.length,i=0;i<l.length;i++){let n=l[i],o=n.getAttribute("data-title");var c="http://blog.tabris.top"+n.getAttribute("data-path");if(c){var h=this.getRecord(e,c,o).then(e=>{let t=window.location.pathname;if(t.includes("index.html")&&(t=t.substring(0,t.lastIndexOf("index.html"))),n.getAttribute("data-path")==t&&r.push(this.buildIncrement(e.objectId)),n){var o=n.querySelector("#lc-pv #number");o&&(n.getAttribute("data-path")==t?o.innerText=(e.times||0)+1:o.innerText=e.times||0,n.style.display="inline")}});t.push(h)}}Promise.all(t).then(()=>{r.length>0&&this.increment(e,r)})},fetchData(e){this.addCount((t,r,n)=>fetch(`${e}/1.1${r}`,{method:t,headers:{"X-LC-Id":this.app_id,"X-LC-Key":this.app_key,"Content-Type":"application/json"},body:JSON.stringify(n)}))},refreshCounter(){var e="-MdYXbMMI"!==this.app_id.slice(-9)?this.custom_api_server:`https://${this.app_id.slice(0,8).toLowerCase()}.api.lncldglobal.com`;e?this.fetchData(e):fetch("https://app-router.leancloud.cn/2/route?appId="+this.app_id).then(e=>e.json()).then(({api_server:e})=>{this.fetchData("https://"+e)})}};LCCounter.refreshCounter(),document.addEventListener("pjax:complete",(function(){LCCounter.refreshCounter()}))</script><script>var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg"],index=0;function shuffle(a){for(var l=a.length;l--;){var e=Math.floor(Math.random()*l),r=a[e];a[e]=a[l],a[l]=r}}function parallax(a){$("#parallax-window").parallax({src:a,speed:.25,bleed:0,zIndex:-100,posX:"center",posY:"center",overScrollFix:!1,excludeAgents:/(iPod|iPhone|iPad|Android)/,aspectRatio:null,sliderSelector:">.parallax-slider",mirrorSelector:"#l_cover",afterRefresh:()=>{},afterRender:()=>{},afterSetup:()=>{},afterDestroy:()=>{}})}function next_parallax(){$("#l_cover .parallax-mirror img")[0].src=imgs[index%imgs.length],index++,fetch(imgs[index%imgs.length])}function pjax_parallax(){next_parallax(),volantis.IntervalParallax=setInterval((function(){next_parallax()}),15e3)}shuffle(imgs),loadScript("/js/jquery.parallax.min.js");var checkParallax=setInterval((function(){"block"==$("#safearea").css("display")&&void 0!==$("#parallax-window").parallax&&(clearInterval(checkParallax),parallax(imgs[index%imgs.length]))}),500);volantis.pjax.push(pjax_parallax),volantis.pjax.send(()=>{try{clearInterval(volantis.IntervalParallax)}catch(a){}},"pjax_parallax")</script><script>volantis.message=(s,e,a,t=3e3,i)=>{if(void 0===$.message){loadCSS("/css/message.css"),loadScript("/js/message.js",()=>{m(s,e,a,i,t)})}else m(s,e,a,i,t);function m(s,e,a,t,i){$.message({title:s,message:e,type:a,autoClose:t,time:i})}}</script><script>function listennSidebarTOC(){const e=document.querySelectorAll(".toc li");if(!e.length)return;const t=[...e].map(e=>{const t=e.querySelector(".toc-link"),n=document.getElementById(decodeURI(t.getAttribute("href")).replace("#",""));return t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:n.offsetTop+100,behavior:"smooth"})}),n});!function n(o){o=Math.floor(o+1e4);let r=new IntersectionObserver((r,c)=>{let i=document.documentElement.scrollHeight+100;if(i>o)return c.disconnect(),void n(i);let l=function(e){let n=0,o=e[n];if(o.boundingClientRect.top>0)return n=t.indexOf(o.target),0===n?0:n-1;for(;n<e.length;n++){if(!(e[n].boundingClientRect.top<=0))return t.indexOf(o.target);o=e[n]}return t.indexOf(o.target)}(r);!function(e){if(e.classList.contains("active-current"))return;document.querySelectorAll(".toc .active").forEach(e=>{e.classList.remove("active","active-current")}),e.classList.add("active","active-current");let t=e.parentNode;for(;!t.matches(".toc");)t.matches("li")&&t.classList.add("active"),t=t.parentNode}(e[l])},{rootMargin:o+"px 0px -100% 0px",threshold:0});t.forEach(e=>{e&&r.observe(e)})}(document.documentElement.scrollHeight)}document.addEventListener("DOMContentLoaded",listennSidebarTOC),document.addEventListener("pjax:success",listennSidebarTOC)</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>var pjax;document.addEventListener("DOMContentLoaded",(function(){pjax=new Pjax({elements:'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',selectors:["title","#pjax-container","#pjax-header-nav-list"],cacheBust:!1,timeout:5e3})})),document.addEventListener("pjax:send",(function(e){try{var n=window.location.pathname,t=e.triggerElement.href,a=[""];""!=a[0]&&a.forEach(e=>{-1==n.indexOf(e)&&-1==t.indexOf(e)||(window.location.href=t)})}catch(e){}volantis.$.switcher.removeClass("active"),volantis.$.header.removeClass("z_search-open"),volantis.$.wrapper.removeClass("sub"),volantis.$.topBtn.unbind("click"),$(".menu a","#l_header,#l_cover").unbind("click"),$(window).unbind("resize"),$(window).unbind("scroll"),$(document).unbind("scroll"),$(document).unbind("click"),$("body").unbind("click"),volantis.pjax.method.send.start()})),document.addEventListener("pjax:complete",(function(){$("script[data-pjax], .pjax-reload script").each((function(){$(this).parent().append($(this).remove())})),volantis.pjax.method.complete.start()})),document.addEventListener("pjax:error",(function(e){volantis.pjax.method.error.start(),window.location.href=e.triggerElement.href}))</script></div></body></html>