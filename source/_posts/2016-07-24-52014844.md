---
title: "[原创]POJ 2653 Pick-up sticks  [线段相交]【计算几何】"
date: 2016-07-24 16:57:43
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN, 计算几何 ]
tags: [CSDN,poj,计算几何,线段相交]
key: key2027f524-8fdc-422b-b4ce-652faf39f475
---

题目连接：http://poj.org/problem?id=2653

------------------------------------------------------------------------.

Pick-up sticks
Time Limit: 3000MS		Memory Limit: 65536K
Total Submissions: 12353		Accepted: 4660
Description

Stan has n sticks of various length. He throws them one at a time on the floor in a random way. After finishing throwing, Stan tries to find the top sticks, that is these sticks such that there is no stick on top of them. Stan has noticed that the last thrown stick is always on top but he wants to know all the sticks that are on top. Stan sticks are very, very thin such that their thickness can be neglected.
Input

Input consists of a number of cases. The data for each case start with 1 <= n <= 100000, the number of sticks for this case. The following n lines contain four numbers each, these numbers are the planar coordinates of the endpoints of one stick. The sticks are listed in the order in which Stan has thrown them. You may assume that there are no more than 1000 top sticks. The input is ended by the case with n=0. This case should not be processed.
Output

For each input case, print one line of output listing the top sticks in the format given in the sample. The top sticks should be listed in order in which they were thrown.

The picture to the right below illustrates the first case from input.
![这里写图片描述](http://poj.org/images/2653_1.jpg)


Sample Input

5
1 1 4 2
2 3 3 1
1 -2.0 8 4
1 4 8 2
3 3 6 -2.0
3
0 0 1 1
1 0 2 1
2 0 3 1
0

Sample Output

Top sticks: 2, 4, 5.
Top sticks: 1, 2, 3.


Hint

Huge input,scanf is recommended.


------------------------------------------------------.

题目大意 ： 就是依次向平面上扔几根棍  ，问最后没被其他木棍压住的木棍有哪些


题解： 水题  判断从每个棍向后来的棍 判断线段相交 有没有交上的 没有就是所要求的 记录下来 最后输出一下就醒了

  时间够长 能够小 n^2 就行


附本题代码

------------------------------------.
```
# include<iostream>
# include<stdio.h>
# include<math.h>
# include<stdlib.h>
# include<string.h>
using namespace std;
const double EPS=1e-6;
int n;
struct point
{
    double  x, y;
};
struct line
{
    point p1,p2;
    int flag;
} line1[100005];

double multi(point p0,point p1,point p2)
{
	return(p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}

bool IsIntersected(point s1,point e1,point s2,point e2) //线段相交
{
	return (max(s1.x,e1.x)>=min(s2.x,e2.x))&&
           (max(s2.x,e2.x)>=min(s1.x,e1.x))&&
           (max(s1.y,e1.y)>=min(s2.y,e2.y))&&
           (max(s2.y,e2.y)>=min(s1.y,e1.y))&&
           (multi(s1,s2,e1)*multi(s1,e1,e2)>0)&&
           (multi(s2,s1,e2)*multi(s2,e2,e1)>0);
}

int num[100005];

int main()
{
    while(~scanf("%d",&n)&&n)
    {
        for(int i=1; i<=n; i++)
            scanf("%lf%lf%lf%lf",&line1[i].p1.x,&line1[i].p1.y,&line1[i].p2.x,&line1[i].p2.y);

        int f=0,k=0;
        for(int i=1; i<n; i++)
        {
            f=0;
            for(int j=i+1; j<=n; j++)
            {
                if(IsIntersected(line1[i].p1,line1[i].p2,line1[j].p1,line1[j].p2))
                {
                        f=1;
                        break;
                }
            }
            if(!f)  num[k++]=i;
        }
        num[k]=n;
        printf("Top sticks:");
        for(int i=0; i<=k; i++)
        {
            if(i==0)
                printf(" %d",num[i]);
            else
                printf(", %d",num[i]);
        }
        printf(".\n");
    }
    return 0;
}
```