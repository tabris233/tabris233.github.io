---
title: "[原创]POJ 3070  Fibonacci  【矩阵快速幂】"
date: 2016-07-17 09:37:27
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN,数学]
tags: [CSDN,poj]
key: keybc38b525-451b-4e99-b7b1-17bf9695c4ea
---

题目连接 ： http://poj.org/problem?id=3070

---------------------------------------------------------------------------
-
Fibonacci
Time Limit: 1000MS		Memory Limit: 65536K
Total Submissions: 12738		Accepted: 9065
Description

In the Fibonacci integer sequence, F0 = 0, F1 = 1, and Fn = Fn − 1 + Fn − 2 for n ≥ 2. For example, the first ten terms of the Fibonacci sequence are:

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …

An alternative formula for the Fibonacci sequence is

.![这里写图片描述](http://poj.org/images/3070_1.png)

Given an integer n, your goal is to compute the last 4 digits of Fn.

Input

The input test file will contain multiple test cases. Each test case consists of a single line containing n (where 0 ≤ n ≤ 1,000,000,000). The end-of-file is denoted by a single line containing the number −1.

Output

For each test case, print the last four digits of Fn. If the last four digits of Fn are all zeros, print ‘0’; otherwise, omit any leading zeros (i.e., print Fn mod 10000).

Sample Input

0
9
999999999
1000000000
-1
Sample Output

0
34
626
6875
Hint

As a reminder, matrix multiplication is associative, and the product of two 2 × 2 matrices is given by
![这里写图片描述](http://poj.org/images/3070_2.png)
.

Also, note that raising any 2 × 2 matrix to the 0th power gives the identity matrix:

.![这里写图片描述](http://poj.org/images/3070_3.gif)


------------------------------------------
-


题目大意 ：  这个的大意应该不用说了吧

题解  ： 这个题目大意里已经说得很清楚了吧 。。

就是裸的矩阵快速幂 没什么难度  主要是用来熟悉下 矩阵快速么的代码实现 并顺手撸了一发模板
```
const int M = 2;
const int MOD = 1e4;

struct Matrix
{
    LL m[M][M];
};

Matrix operator * (Matrix a,Matrix b)
{
    Matrix c;
    for(int i=0; i<M; i++) //初始化矩阵
        for(int j=0; j<M; j++)
            c.m[i][j]= 0;

    for(int k=0; k<M; k++)
        for(int i=0; i<M; i++) //实现矩阵乘法
        {
            if(a.m[i][k] <= 0)  continue;
            for(int j=0; j<M; j++)
            {
                if(b.m[k][j] <= 0)    continue;
                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;
            }
        }
    return c;
}

Matrix operator ^ (Matrix a,LL b)
{
    Matrix c;
    for(int i=0; i<M; i++) //初始化单位矩阵
        for(int j=0; j<M; j++)
            c.m[i][j]= ( i == j );

    while(b)
    {
        if(b&1) c= c * a ;
        b >>= 1;
        a = a * a ;
    }

    return c;
}
```


直接附本题代码吧

---------------------------------------------------------------------------------
-

```
# include <iostream>
# include <stdio.h>
# include <string.h>
# include <string>
# include <algorithm>
# include <math.h>

using namespace std;

# define LL long long int
# define _LL __int64

/******************************/


/*****************************/

const int M = 2;
const int MOD = 1e4;

struct Matrix
{
    LL m[M][M];
};

Matrix operator * (Matrix a,Matrix b)
{
    Matrix c;
    for(int i=0; i<M; i++) //初始化矩阵
        for(int j=0; j<M; j++)
            c.m[i][j]= 0;

    for(int k=0; k<M; k++)
        for(int i=0; i<M; i++) //实现矩阵乘法
        {
            if(a.m[i][k] <= 0)  continue;
            for(int j=0; j<M; j++)
            {
                if(b.m[k][j] <= 0)    continue;
                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+MOD)%MOD;
            }
        }
    return c;
}

Matrix operator ^ (Matrix a,LL b)
{
    Matrix c;
    for(int i=0; i<M; i++) //初始化单位矩阵
        for(int j=0; j<M; j++)
            c.m[i][j]= ( i == j );

    while(b)
    {
        if(b&1) c= c * a ;
        b >>= 1;
        a = a * a ;
    }

    return c;
}

void init(Matrix &a)
{
    a.m[0][0]=1;
    a.m[0][1]=1;
    a.m[1][0]=1;
    a.m[1][1]=0;
}
int main()
{
    ios::sync_with_stdio(false);

    Matrix f;
    int n;
    while(~scanf("%d",&n)&&n!=-1)
    {
        init(f);
        f=f^n;


        printf("%lld/n",f.m[0][1]);
    }
    return 0;
}
```