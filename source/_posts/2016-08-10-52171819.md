---
title: "[原创]codeforces 704A Thor  [技巧吧.]"
date: 2016-08-10 15:19:05
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN, STL ,codeforces,思维]
tags: [CSDN,codeforces]
key: keyec294952-65da-4844-b5fe-08b80d0e5ad3
---

题目连接 : http://codeforces.com/problemset/problem/704/A

--------------------------------------.
A. Thor
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There are n applications on this phone. Thor is fascinated by this phone. He has only one minor issue: he can't count the number of unread notifications generated by those applications (maybe Loki put a curse on it so he can't).

q events are about to happen (in chronological order). They are of three types:

Application x generates a notification (this new notification is unread).
Thor reads all notifications generated so far by application x (he may re-read some notifications).
Thor reads the first t notifications generated by phone applications (notifications generated in first t events of the first type). It's guaranteed that there were at least t events of the first type before this event. Please note that he doesn't read first t unread notifications, he just reads the very first t notifications generated on his phone and he may re-read some of them in this operation.
Please help Thor and tell him the number of unread notifications after each event. You may assume that initially there are no notifications in the phone.

Input
The first line of input contains two integers n and q (1 ≤ n, q ≤ 300 000) — the number of applications and the number of events to happen.

The next q lines contain the events. The i-th of these lines starts with an integer typei — type of the i-th event. If typei = 1 or typei = 2 then it is followed by an integer xi. Otherwise it is followed by an integer ti (1 ≤ typei ≤ 3, 1 ≤ xi ≤ n, 1 ≤ ti ≤ q).

Output
Print the number of unread notifications after each event.

Examples
input
3 4
1 3
1 1
1 2
2 3
output
1
2
3
2
input
4 6
1 2
1 4
1 2
3 3
1 3
1 3
output
1
2
3
0
1
2
Note
In the first sample:

Application 3 generates a notification (there is 1 unread notification).
Application 1 generates a notification (there are 2 unread notifications).
Application 2 generates a notification (there are 3 unread notifications).
Thor reads the notification generated by application 3, there are 2 unread notifications left.
In the second sample test:

Application 2 generates a notification (there is 1 unread notification).
Application 4 generates a notification (there are 2 unread notifications).
Application 2 generates a notification (there are 3 unread notifications).
Thor reads first three notifications and since there are only three of them so far, there will be no unread notification left.
Application 3 generates a notification (there is 1 unread notification).
Application 3 generates a notification (there are 2 unread notifications).

----------------------------------.
题目大意 :
就是你有一个手机  有三种操作
1,x软件收到一个信息
2,看了所有x软件的信息
3,看了第1~第x次收到的信息 （被看过的也算）

每次都输出一下当前手机里的未读信息的个数


题解 ：
首先把信息编号
用一个vector 和set 维护下就好了
vector有n个 代表n个软件  每次向n[x]中加入新的信息编号
set存储所有的信息

维护的时候
对于1 操作  把信息编号加入vector 和set
对于2 操作  对应n[x]遍历一遍 从set中删除
对于3 操作  遍历1~x 从set中删除 （这里注意每次的x要记录一下 然后下一次遍历的时候只要遍历这个x到下一个x的区间就行了 之前被删除的不用再删除一遍  否则会TLE）
每次输出set的大小就行了

这样总体复杂度是O(2n)

/**************** 这些shi牢骚
这道题是赛后补得 并且看了网上的题解
当时 想到了思路 当时没有做主要是怕TLE  在一个不太会用set （我是小白）  当时想到的是对数组二分查找整个区间 然后删除 当对判断数据的统计这一块只想到了线段树（赛前几天才学习数据结构，做什么题都想用线段树） 然后旁边队友 风骚的A了这道题后  告诉用STL做   然而对于不会STL的我老说 根本没法搞。 So我就不做了。。。
仔细想来  根本不用那么麻烦   多熟练下vector map set 这东西其实是能秒的。。
****************/
附本题代码
-------------------------.
```
# include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 300010;

vector<int> app[maxn];
set<int> cnt;

int main()
{
    int n,q,x,type,num;
    while(~scanf("%d%d",&n,&q))
    {
        num = 0;
        cnt.clear();
        int last = 0;
        for(int i=0;i<q;i++)
        {
            scanf("%d%d",&type,&x);
            if(type==1)
            {
                app[x].push_back(++num);
                cnt.insert(num);
            }
            else if(type==2)
            {
                for(int i=0;i<app[x].size();i++)
                    cnt.erase(app[x][i]);
                app[x].clear();
            }
            else
            {
                for(int i=last;i<=x;i++)
                {
                    cnt.erase(i);
                }
                last = max(x,last);
            }
            printf("%d\n",cnt.size());
        }
    }
    return 0;
}
```