---
title: "[原创]LightOJ 1035 Intelligent Factorial Factorization [预处理+一半的 质因子分解]【数论】"
date: 2016-06-29 16:32:35
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN,数学]
tags: [CSDN,lightoj,数论,质因子分解]
key: key7468200f-4d32-46c3-89a9-587b331c717d
---

题目链接：[LightOJ 1035 Intelligent Factorial Factorization](http://acm.hust.edu.cn/vjudge/contest/view.action?cid=120197#problem/T)

-----------------------------------------

 Intelligent Factorial Factorization
Time Limit:500MS     Memory Limit:32768KB     64bit IO Format:%lld & %llu
Submit

Status
Description
Given an integer N, you have to prime factorize N! (factorial N).

Input
Input starts with an integer T (≤ 125), denoting the number of test cases.

Each case contains an integer N (2 ≤ N ≤ 100).

Output
For each case, print the case number and the factorization of the factorial in the following format as given in samples.

Case x: N = p1 (power of p1) * p2 (power of p2) * ...

Here x is the case number, p1, p2 ... are primes in ascending order.

Sample Input
3
2
3
6
Sample Output
Case 1: 2 = 2 (1)
Case 2: 3 = 2 (1) * 3 (1)
Case 3: 6 = 2 (4) * 3 (2) * 5 (1)

--------------------


题目大意 就是把N！ 质因子分解一下

题解：  因为数据量很小 所以预处理一下所有N！ 的质因子个数即可

这种办法 应该可以做到n<=1000
n<10000的时候用容器存一下 而且时间在大一丢丢 应该还是能做的

因为数据量太小 所有算法都是最最最最最暴力的

附本题代码

----------------------------
-
```
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <limits.h>
# include <malloc.h>
# include <ctype.h>
# include <math.h>
# include <string>
# include <iostream>
# include <algorithm>
# include <map>
# include <vector>
# include <set>

using namespace std;

# define LL unsigned long long int

int Is_or[500];
void Prime()
{
    int n=200;
    int k=0;
    memset(Is_or,1,sizeof(Is_or));
    Is_or[0]=Is_or[1]=0;
    for(int i=2; i<n; i++)
    {
        if(Is_or[i])
        {
            for(int j=i+i; j<n; j+=i)
            {
                Is_or[j]=0;
            }
        }
    }
    return ;
}

int has[105][105];

void init()
{
    int num;
    memset(has,0,sizeof(has));
    for(int i=2;i<=100;i++)
    {
        for(int j=2;j<=i;j++)
        {
            num=i;
            if(num%j==0&&Is_or[j])
                while(num%j==0)
                    has[i][j]++,num/=j;
        }
    }

    for(int i=1;i<=100;i++)
    {
        for(int j=1;j<=100;j++)
        {
            has[i][j]+=has[i-1][j];
        }
    }

    return ;
}

int main()
{
    Prime();
    init();
    int t,tt=0,num;
    LL p,l;
    scanf("%d",&t);
    while(t--)
    {
        int n,m;
        scanf("%d",&n);
        printf("Case %d: %d = ",++tt,n);

        printf("%d (%d)",2,has[n][2]);
        for(int i=3;i<=n;i++)
        {
            if(has[n][i])
            printf(" * %d (%d)",i,has[n][i]);
        }
        printf("\n");
    }
    return 0;
}
```