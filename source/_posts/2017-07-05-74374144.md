---
title: "[原创]HDU 5534 Partial Tree [完全背包]【动态规划+思维】"
date: 2017-07-05 09:31:07
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN,hdu, 动态规划 ]
tags: [CSDN,动态规划,思维]
key: keyccb8170b-4be7-4136-bdb0-ad78ffd6ab23
---

题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5534
————————————————————————————————————————
Partial Tree

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 262144/262144 K (Java/Others)
Total Submission(s): 1401    Accepted Submission(s): 693


Problem Description
In mathematics, and more specifically in graph theory, a tree is an undirected graph in which any two nodes are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.

You find a partial tree on the way home. This tree has n nodes but lacks of n−1 edges. You want to complete this tree by adding n−1 edges. There must be exactly one path between any two nodes after adding. As you know, there are nn−2 ways to complete this tree, and you want to make the completed tree as cool as possible. The coolness of a tree is the sum of coolness of its nodes. The coolness of a node is f(d), where f is a predefined function and d is the degree of this node. What's the maximum coolness of the completed tree?


Input
The first line contains an integer T indicating the total number of test cases.
Each test case starts with an integer n in one line,
then one line with n−1 integers f(1),f(2),…,f(n−1).

1≤T≤2015
2≤n≤2015
0≤f(i)≤10000
There are at most 10 test cases with n>100.


Output
For each test case, please output the maximum coolness of the completed tree in one line.


Sample Input
2
3
2 1
4
5 1 4


Sample Output
5
19
————————————————————————————————————————
题目大意:
有n个节点,让你加n-1条边构建成一棵联通树,使得其权值和最大
题目给定节点度数为i的权值为f(i),

---

解题思路:

首先能够确定的是对于整棵树度数和为$2*(n-1)$,
如果树联通的话,那么每个节点度数至少为$1$.

于是问题就变成如何分配$2*(n-1)-n*1 = n-2$这几个度数

可以将这个问题变成在容量为$n-2$的背包中不限次数拿取体积为$i$价值为$f(i)$这样一个完全背包问题.

之后就是因为节点度数至少为$1$了,而在转移的时候至少都是度数为$2$的节点

那么转移过程应该怎么办?

这样考虑,如果多了一个度数为$x$的节点,那么同时也就少了一个度数为$1$的节点

显然在转移的时候先减去$f[1]$,最后在结果加回$n*f[1]$,那么就把应该有的度数为$1$的节点计算上了.又因为最后这个$n*f[1]$是常数,不会影响dp转移的结果

附本题代码
————————————————————————————————————————
```
int n;

int f[2222];
int dp[2222];

int main(){
    for(int _=read();_;_--){
        n=read();
        for(int i=1;i<n;i++) f[i]=read(),dp[i]=-1e9; dp[0]=0;
        for(int i=1;i<n-1;i++)
            for(int j=i;j<=n-2;j++)
                dp[j]=max(dp[j],dp[j-i]+f[i+1]-f[1]);
        printf("%d\n",dp[n-2]+n*f[1]);
    }
    return 0;
}

```
