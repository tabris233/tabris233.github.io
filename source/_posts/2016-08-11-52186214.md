---
title: "[原创]HDU 2588 GCD [欧拉函数]【数论】"
date: 2016-08-11 20:25:10
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img:
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password:
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: true
summary: ""
categories: [CSDN,hdu,数学, 数论 ]
tags: [CSDN,函数,gcd]
key: keya068c174-e0c8-4e88-901e-7958fa651adc
---

题目连接 ： [传送阵](http://acm.hdu.edu.cn/showproblem.php?pid=2588)
-------------------------.
GCD

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 1734    Accepted Submission(s): 852


Problem Description
The greatest common divisor GCD(a,b) of two positive integers a and b,sometimes written (a,b),is the largest divisor common to a and b,For example,(1,2)=1,(12,18)=6.
(a,b) can be easily found by the Euclidean algorithm. Now Carp is considering a little more difficult problem:
Given integers N and M, how many integer X satisfies 1<=X<=N and (X,N)>=M.


Input
The first line of input is an integer T(T<=100) representing the number of test cases. The following T lines each contains two numbers N and M (2<=N<=1000000000, 1<=M<=N), representing a test case.


Output
For each test case,output the answer on a single line.


Sample Input
3
1 1
10 2
10000 72


Sample Output
1
6
260

-----------------------------------------.

题目大意 ：不用解释了吧 ..


解题思路：
这道题所需要的算法主要为欧拉函数的运用和一点点的GCD知识。
问题所要求的是 gcd( x , n ) > m ,由gcd( x , n )本身可知，gcd求出来的是 x 和n的最大公约数（设为a），即有式子gcd( x ,n )=a , 进一步进行化简可变为gcd( x/a , n/a )=1 , 到了此处这个式子又有了另一层含义——x/a与n/a互素 。在联想到欧拉函数的功能——对正整数n，欧拉函数是小于或等于n的数中与n互质的数的数目。于是将欧拉函数里的n换成n/a，不就正好能求出x/a的个数了吗？x/a的个数不就是我们所要求的x的个数了吗？

转自[这里](http://blog.csdn.net/no2015214099/article/details/52122295)


附本题代码
-------------------------------------.
```
# include <stdio.h>
# include <vector>
# include <iostream>
# include <stdlib.h>
using namespace std;
# define LL long long int
# define pb push_back

int Euler(int n)
{
    if(n==1)    return 1;
    int m=n;

    for(int i=2; i*i<=m; i++)
        if(m%i==0)
        {
            n-=n/i;
            while(m%i==0)
                m/=i;
        }
    if(m!=1)
    {
        n-=n/m;
    }
    return n;
}

int solve(int n,int m)
{
    int ans=0;
    for(int i=1; i*i<=n; i++)
    {
        if(n%i) continue;
        if(i>=m&&i*i!=n)
            ans += Euler(n/i);
        if(n/i>=m)
            ans += Euler(i);
    }
    return ans;
}

int main()
{
    int _,p=0;
    scanf("%d",&_);
    while(_--)
    {
        int  n,m;
        scanf("%d%d",&n,&m);
        int sum=solve(n,m);
        printf("%d\n",sum);
    }
    return 0;
}
```
