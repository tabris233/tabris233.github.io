<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tabris的博客</title>
  
  <subtitle>IT互联网</subtitle>
  <link href="http://blog.tabris.top/atom.xml" rel="self"/>
  
  <link href="http://blog.tabris.top/"/>
  <updated>2021-05-04T11:57:14.155Z</updated>
  <id>http://blog.tabris.top/</id>
  
  <author>
    <name>tabris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 第51场双周赛</title>
    <link href="http://blog.tabris.top/LeetcodeConestBiweekly51/"/>
    <id>http://blog.tabris.top/LeetcodeConestBiweekly51/</id>
    <published>2021-05-01T23:54:58.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501233929.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501233929.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>GG</p><h1 id="5730-将所有数字用字符替换"><a href="#5730-将所有数字用字符替换" class="headerlink" title="5730. 将所有数字用字符替换"></a>5730. 将所有数字用字符替换</h1><p>简单模拟题目</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceDigits</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size(); i+=<span class="number">2</span>) &#123;</span><br><span class="line">            s[i+<span class="number">1</span>] = s[i]+(s[i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5731-座位预约管理系统"><a href="#5731-座位预约管理系统" class="headerlink" title="5731. 座位预约管理系统"></a>5731. 座位预约管理系统</h1><p>数据结构题， 维护一个set就可以了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeatManager</span> &#123;</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SeatManager(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        s.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reserve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mn = *s.begin();</span><br><span class="line">        s.erase(mn);</span><br><span class="line">        <span class="keyword">return</span> mn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unreserve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5732-减小和重新排列数组后的最大元素"><a href="#5732-减小和重新排列数组后的最大元素" class="headerlink" title="5732. 减小和重新排列数组后的最大元素"></a>5732. 减小和重新排列数组后的最大元素</h1><p>开始想都没想就搞二分了。。。搞了半天</p><p>后面发现只要拍个序 模拟一下就好了， 如果这个一个减上一个超过1， 就变成上一个的值+1.</p><p>没看到题目说 第一个 必须为 1  wa了一发。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumElementAfterDecrementingAndRearranging</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i<span class="number">-1</span>]+<span class="number">1</span>) &#123;</span><br><span class="line">                arr[i] = arr[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5733-最近的房间"><a href="#5733-最近的房间" class="headerlink" title="5733. 最近的房间"></a>5733. 最近的房间</h1><p>这个题本身也不难， 数据和查询两个数组按照size从大到小拍个序就好了。 搞个set维护roomId。 set自带的二分查找下就行了。  因为是绝对值就再维护个负值的set(后面看了其他大佬的代码发现迭代器减一下就行了)。</p><p>不太会用set， 不会写c++的匿名函数，， 后面判断逻辑又少了， GG。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">closestRoom</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(q.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;q.size(); i++) &#123;</span><br><span class="line">            q[i].push_back(i);</span><br><span class="line">            ans[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(rooms.begin(), rooms.end(), cmp);</span><br><span class="line">        sort(q.begin(), q.end(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>,as,asf;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s, sf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; qq: q) &#123;</span><br><span class="line">            <span class="keyword">for</span>(;p&lt;rooms.size() &amp;&amp; rooms[p][<span class="number">1</span>] &gt;= qq[<span class="number">1</span>]; p++) &#123;</span><br><span class="line">                s.insert(rooms[p][<span class="number">0</span>]);</span><br><span class="line">                sf.insert(-rooms[p][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            as = asf = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">auto</span> it = s.lower_bound(qq[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(it!=s.end()) &#123;</span><br><span class="line">                as = (*it) - qq[<span class="number">0</span>];</span><br><span class="line">                ans[qq[<span class="number">2</span>]] = (*it);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> it2 = sf.lower_bound(-qq[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(it2 != sf.end()) &#123;</span><br><span class="line">                asf = (*it2) - (-qq[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span>(ans[qq[<span class="number">2</span>]] == <span class="number">-1</span> || asf &lt;= as) ans[qq[<span class="number">2</span>]] = -(*it2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode 第51场双周赛。。 菜死了啊</summary>
    
    
    
    <category term="leetcode" scheme="http://blog.tabris.top/categories/leetcode/"/>
    
    
    <category term="周赛" scheme="http://blog.tabris.top/tags/%E5%91%A8%E8%B5%9B/"/>
    
    <category term="双周赛" scheme="http://blog.tabris.top/tags/%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>【TODO】 redis 学习 基础数据结构篇 之 dict</title>
    <link href="http://blog.tabris.top/StudyRedis-DataStruct-dict/"/>
    <id>http://blog.tabris.top/StudyRedis-DataStruct-dict/</id>
    <published>2021-04-29T22:35:23.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于redis 6.2.1</p></blockquote><h1 id="dict（字典）"><a href="#dict（字典）" class="headerlink" title="dict（字典）"></a>dict（字典）</h1><blockquote><p>字典， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。</p></blockquote><p>        在字典中，一个键（key）和一个值（value）关联，关联上的键和值被称为键值对</p><p>        很多语言都提供了字典的实现，如C++ STL中的map，python中的dict，Go中的map等等。C语言中并为提供字典实现，因此Redis自行实现了字典。</p><p>        Redis中很多地方用到了字典，Redis的数据库，HASH类型等。</p><h2 id="dict的实现"><a href="#dict的实现" class="headerlink" title="dict的实现"></a>dict的实现</h2><p><code>src/dict.h</code> 中定义了字典</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashtable 哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// dictEntry 二维指针， 被当成指针数组用的。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;     <span class="comment">// 哈希表容量大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 等于size-1， 方便位运算的</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;     <span class="comment">// 哈希表使用的大小</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>        <code>table</code> 属性是一个数组， 数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针， 每个 <code>dictEntry</code> 结构保存着一个键值对。</p><p>        <code>size</code> 属性记录了哈希表的大小， 也即是 <code>table</code> 数组的大小， 而 <code>used</code> 属性则记录了哈希表目前已有节点（键值对）的数量。</p><p>        <code>sizemask</code> 属性的值总是等于 <code>size - 1</code> ， 这个属性和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面。</p><p>        采用的hash算法在<code>src/siphash.c</code> 中， 采用的hash算法 是 <code>SipHash 1-2</code> 本文并不展开介绍<code>SipHash 1-2</code>原理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点， 也就是一个键值对</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;              <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;                    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// next指针， 用来开链解决冲突的。</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>        <code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 <code>uint64_t</code> 整数， 又或者是一个 <code>int64_t</code> 整数。</p><p>        <code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p><p>举个例子， 图 4-2 就展示了如何通过 <code>next</code> 指针， 将两个索引值相同的键 <code>k1</code> 和 <code>k0</code> 连接在一起。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典 结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;  <span class="comment">// 字典类型 （用来支持不同类型的，暂时不用泰太过关注）</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// 哈希表  这里有两个，ht[1] 是rehash的时候才用的</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;  <span class="comment">// 是否rehash标记 /没有rehash的时候等于-1， rehash的时候为接下来要rehash的哈希表下标</span></span><br><span class="line">    <span class="keyword">int16_t</span> pauserehash; <span class="comment">// 暂停rehash标记 /* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p><code>type</code> 属性和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li><li>而 <code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">  <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">  <span class="comment">// 复制键的函数</span></span><br><span class="line">  <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">  <span class="comment">// 复制值的函数</span></span><br><span class="line">  <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">  <span class="comment">// 对比键的函数</span></span><br><span class="line">  <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">  <span class="comment">// 销毁键的函数</span></span><br><span class="line">  <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">  <span class="comment">// 销毁值的函数</span></span><br><span class="line">  <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></li></ul><p>        <code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p><p>        除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p><p>下图是一个完整的字典结构（普通状态下，没有进行rehash）：</p><p><img src="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501184352.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501184352.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h2><p>TODO 感觉没啥好说的了。</p><h3 id="hash冲突解决（链地址法）"><a href="#hash冲突解决（链地址法）" class="headerlink" title="hash冲突解决（链地址法）"></a>hash冲突解决（链地址法）</h3><p>TODO 这个感觉也没啥好说的，太基础了。</p><h2 id="rehash-和-渐进式-rehash"><a href="#rehash-和-渐进式-rehash" class="headerlink" title="rehash 和 渐进式 rehash"></a>rehash 和 渐进式 rehash</h2><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>        随着频繁的增删操作， 哈希表可能不够用了或者空间使用率变低了，这时候就需要进行扩容或缩容，也就是Redis的rehash过程。</p><p>        rehash过程很好理解，当哈希表需要扩容或缩容的时候，改变哈希表的大小，对所有元素重新 hash 后放到新的位置。</p><p>        以下图为例， 当字典使用率过低时，会进行缩容。按照used个数确定合适的容量生成一个新的。这时候将旧的哈希表（h[0]）中的数据重新hash放到新的哈希表中（h[1]）。</p><p><img src="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501184231.jpeg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501184231.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>        同理当容量不足的时候，字典会进行扩容。容量大小会翻一倍（乘2）。也是一样生成一个新的。把旧的哈希表（h[0]）中的数据重新hash放到新的哈希表中（h[1]）。</p><p><img src="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501222136.jpeg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/tabris233/cdn-assets/PicGo/2021/05/01/20210501222136.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IMG_E3060FCFC999-1.jpeg"></p><p>        ⚠️注意， 如上图所示，当给一个容量为4的哈希表添加键值对，然后再删一个，然后再添加一个。。。这样重复的删除再添加。 会一直rehash下去，每次都要进行大量的内存操作和数据结构的维护处理，想想Redis本身单进程的，这得慢成什么样子。 所以 Redis 在处理扩容缩容时有这样的策略：</p><p>        一般情况下 当<code>used/size &gt;= 1</code> 时, 进行<strong>扩容</strong>。 容量缩到大于 used 的第一个大小。</p><p>        正在进行高负载命令时（行 BGSAVE 命令或BGREWRITEAOF 命令）， 当<code>used/size &gt; 5</code>时才进行扩容，容量缩到大于 used 的第一个大小。</p><p>        当<code>used/size &lt;= 1/10</code> 时进行<strong>缩容</strong>。容量缩到大于 used 的第一个大小。</p><p>扩容策略源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio) &amp;&amp;</span><br><span class="line">        dictTypeExpandAllowed(d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>        有了上面rehash的，字典可以应对容量的变化， 但如果字典已经存储了十万，百万，甚至千万量级的键值对，一次rehash的过程会持续很久，这个时候因为Redis单进程处理会阻塞很久，业务服务就会卡住。</p><p>        因此Redis实现了渐进式的rehash，将rehash的操作分散到字典多次的增删改查操作中。每一次只操作少量的哈希表的槽位，将整体rehash操作均摊。</p><p>        从字典的结构中可以看到它有两个哈希表。正常情况下直接使用的<code>ht[0]</code>, 渐进式的rehash过程就是逐步将键值对迁移到<code>ht[1]</code>中。在rehash的过程中进行操作时字典会先从<code>ht[0]</code>找，如果找不到则在<code>ht[1]</code>中找。 如下面<code>dictFind</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渐进式rehash主要时限制了两个，</p><ol><li><p>最多可迁移的槽的个数<code>n</code>。</p></li><li><p>最多可遍历的空槽的个数<code>n*10</code></p></li></ol><p>如果进行了这么多的遍历或rehash操作，函数则退出，如果rehash已经结束返回<code>0</code>，没有结束返回<code>1</code>。</p><p>最后看下rehash的完整函数吧：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dict重要API"><a href="#dict重要API" class="headerlink" title="dict重要API"></a>dict重要API</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>dictCreate</code></td><td>创建一个新的字典。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>dictAdd</code></td><td>将给定的键值对添加到字典里面。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>dictReplace</code></td><td>将给定的键值对添加到字典里面， 如果键已经存在于字典，那么用新值取代原有的值。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>dictFetchValue</code></td><td>返回给定键的值。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>dictGetRandomKey</code></td><td>从字典中随机返回一个键值对。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>dictDelete</code></td><td>从字典中删除给定键所对应的键值对。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f5139a8e88e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>dictRelease</code></td><td>释放给定字典，以及字典中包含的所有键值对。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f513a53880b.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f513a53880b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为字典包含的键值对数量。</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>字典中最重要的实现是 rehash 及其渐进式的方式。</p>]]></content>
    
    
    <summary type="html">redis 基础数据结构 - 字典。</summary>
    
    
    
    <category term="redis" scheme="http://blog.tabris.top/categories/redis/"/>
    
    
    <category term="redis" scheme="http://blog.tabris.top/tags/redis/"/>
    
    <category term="dict" scheme="http://blog.tabris.top/tags/dict/"/>
    
    <category term="rehash" scheme="http://blog.tabris.top/tags/rehash/"/>
    
    <category term="渐进式 rehesh" scheme="http://blog.tabris.top/tags/%E6%B8%90%E8%BF%9B%E5%BC%8F-rehesh/"/>
    
  </entry>
  
  <entry>
    <title>redis 学习</title>
    <link href="http://blog.tabris.top/StudyRedis/"/>
    <id>http://blog.tabris.top/StudyRedis/</id>
    <published>2021-04-17T21:47:23.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>准备好好学习下redis了<br><a href="https://www.kancloud.cn/kancloud/redisbook/63834" target="_blank" rel="noopener external nofollow noreferrer">《Redis 设计与实现(第二版)》</a><br><a href="https://github1s.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener external nofollow noreferrer">redis-3.0.0 带中文注释代码</a><br><a href="https://github1s.com/redis/redis" target="_blank" rel="noopener external nofollow noreferrer">redis 最新版代码</a><br>准备跟书看，同时对比下最新版代码，最后运行调试看下。<br>博客还不知道会不会更新。。。。</p></blockquote><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>我个人习惯用vscode。</p><p>C/C++ 开发环境这里不展开了，参考这个搞下就行了</p><p>简单配置下就可以断点调试了</p><p>.vscode/launch.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(redis-6.2.1) 启动&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/src/redis-server&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;$&#123;workspaceFolder&#125;/redis.conf&quot;</span>],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.vscode/tasks.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;CFLAGS=\&quot;-g -O0\&quot;&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阅读内容"><a href="#阅读内容" class="headerlink" title="阅读内容"></a>阅读内容</h1><ul><li><input disabled="" type="checkbox"> 数据结构<ul><li><p><input disabled="" type="checkbox">  基础数据结sdsß</p><ul><li><p><input checked="" disabled="" type="checkbox">  sds （sds.h, sds.c, sdsalloc.h)</p></li><li><p><input checked="" disabled="" type="checkbox">  list    ()</p></li><li><p><input checked="" disabled="" type="checkbox">  dict  (dict.h, dict.c)</p></li><li><p><input disabled="" type="checkbox">  zkiplist</p></li><li><p><input disabled="" type="checkbox">  intset</p></li><li><p><input disabled="" type="checkbox">  ziplist</p></li></ul></li><li><p><input disabled="" type="checkbox">  外部数据结构（各类对象）</p><ul><li><input disabled="" type="checkbox"> 对象的类型和编码</li><li><input disabled="" type="checkbox"> 字符串对象</li><li><input disabled="" type="checkbox"> 列表对象</li><li><input disabled="" type="checkbox"> 哈希对象</li><li><input disabled="" type="checkbox"> 集合对象</li><li><input disabled="" type="checkbox"> 有序集合对象</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">redis学习,,,</summary>
    
    
    
    <category term="redis" scheme="http://blog.tabris.top/categories/redis/"/>
    
    
    <category term="osx" scheme="http://blog.tabris.top/tags/osx/"/>
    
  </entry>
  
  <entry>
    <title>redis 学习 基础数据结构篇 之SDS</title>
    <link href="http://blog.tabris.top/StudyRedis-DataStruct-sds/"/>
    <id>http://blog.tabris.top/StudyRedis-DataStruct-sds/</id>
    <published>2021-04-17T21:47:23.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>这篇文章基本是抄来的。 好不要脸啊我。</p><p>带有空还是要自己整理一下。</p></blockquote><h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><blockquote><p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。<br>Redis 中除了字符串字面量，当作常量使用的地方用了C语言传统字符串。 其他可以想见的涉及到字符串的东西都是用SDS实现的。</p></blockquote><blockquote><p>redis 3.2 版本更新了 sds 2.0， 本文简单总结下sds1.0，再总结下sds2.0.</p></blockquote><h2 id="SDS-1-0"><a href="#SDS-1-0" class="headerlink" title="SDS 1.0"></a>SDS 1.0</h2><blockquote><p>SDS 1.0 内容copy 自 《Redis 设计与实现（第二版）》</p></blockquote><h3 id="sds1-0-定义"><a href="#sds1-0-定义" class="headerlink" title="sds1.0 定义"></a>sds1.0 定义</h3><p>每个 sds.h/sdshdr 结构表示一个 SDS 值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图 2-1 展示了一个 SDS 示例：</p><ul><li><code>free</code> 属性的值为 <code>0</code> ， 表示这个 SDS 没有分配任何未使用空间。</li><li><code>len</code> 属性的值为 <code>5</code> ， 表示这个 SDS 保存了一个五字节长的字符串。</li><li><code>buf</code> 属性是一个 <code>char</code> 类型的数组， 数组的前五个字节分别保存了 <code>&#39;R&#39;</code> 、 <code>&#39;e&#39;</code> 、 <code>&#39;d&#39;</code> 、 <code>&#39;i&#39;</code> 、 <code>&#39;s&#39;</code> 五个字符， 而最后一个字节则保存了空字符 <code>&#39;\0&#39;</code> 。</li></ul><p><img src="https://box.kancloud.cn/2015-09-13_55f50d7faffa3.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50d7faffa3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 <code>1</code> 字节空间不计算在 SDS 的 <code>len</code> 属性里面， 并且为空字符分配额外的 <code>1</code> 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</p><p>遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p><p>举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 <code>s</code> ， 那么我们可以直接使用 <code>stdio.h/printf</code> 函数， 通过执行以下语句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;%s&quot;, s-&gt;buf);</span><br></pre></td></tr></table></figure><p>来打印出 SDS 保存的字符串值 <code>&quot;Redis&quot;</code> ， 而无须为 SDS 编写专门的打印函数。</p><p>图 2-2 展示了另一个 SDS 示例:</p><ul><li>这个 SDS 和之前展示的 SDS 一样， 都保存了字符串值 <code>&quot;Redis&quot;</code> 。</li><li>这个 SDS 和之前展示的 SDS 的区别在于， 这个 SDS 为 <code>buf</code> 数组分配了五字节未使用空间， 所以它的 <code>free</code> 属性的值为 <code>5</code> （图中使用五个空格来表示五字节的未使用空间）。</li></ul><p><img src="https://box.kancloud.cn/2015-09-13_55f50d86a66ae.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50d86a66ae.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="sds-1-0-与C字符串的区别"><a href="#sds-1-0-与C字符串的区别" class="headerlink" title="sds 1.0 与C字符串的区别"></a>sds 1.0 与C字符串的区别</h3><p>根据传统， C 语言使用长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串， 并且字符数组的最后一个元素总是空字符 <code>&#39;\0&#39;</code> 。</p><p>比如说， 图 2-3 就展示了一个值为 <code>&quot;Redis&quot;</code> 的 C 字符串：</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e077afb3.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e077afb3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求， 本节接下来的内容将详细对比 C 字符串和 SDS 之间的区别， 并说明 SDS 比 C 字符串更适用于 Redis 的原因。</p><h4 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h4><p>因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 <img src="https://box.kancloud.cn/2015-09-13_55f50e14dc650.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e14dc650.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> 。</p><p>举个例子， 图 2-4 展示了程序计算一个 C 字符串长度的过程。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e169b803.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e169b803.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e1ce00fa.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e1ce00fa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e1e8455f.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e1e8455f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e1f6223a.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e1f6223a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e20dedbf.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e20dedbf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e21b34d8.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e21b34d8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>和 C 字符串不同， 因为 SDS 在 <code>len</code> 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 <img src="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"> 。</p><p>举个例子， 对于图 2-5 所示的 SDS 来说， 程序只要访问 SDS 的 <code>len</code> 属性， 就可以立即知道 SDS 的长度为 <code>5</code> 字节：</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e23d7963.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e23d7963.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>又比如说， 对于图 2-6 展示的 SDS 来说， 程序只要访问 SDS 的 <code>len</code> 属性， 就可以立即知道 SDS 的长度为 <code>11</code> 字节。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e24c2ded.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e24c2ded.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。</p><p>通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 <img src="https://box.kancloud.cn/2015-09-13_55f50e14dc650.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e14dc650.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> 降低到了 <img src="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"> ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。</p><p>比如说， 因为字符串键在底层使用 SDS 来实现， 所以即使我们对一个非常长的字符串键反复执行 STRLEN 命令， 也不会对系统性能造成任何影响， 因为 STRLEN 命令的复杂度仅为 <img src="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"> 。</p><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><p>除了获取字符串长度的复杂度高之外， C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</p><p>举个例子， <code>&lt;string.h&gt;/strcat</code> 函数可以将 <code>src</code> 字符串中的内容拼接到 <code>dest</code> 字符串的末尾：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *strcat(char *dest, const char *src);</span><br></pre></td></tr></table></figure><p>因为 C 字符串不记录自身的长度， 所以 <code>strcat</code> 假定用户在执行这个函数时， 已经为 <code>dest</code> 分配了足够多的内存， 可以容纳 <code>src</code> 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。</p><p>举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 <code>s1</code> 和 <code>s2</code> ， 其中 <code>s1</code> 保存了字符串 <code>&quot;Redis&quot;</code> ， 而 <code>s2</code> 则保存了字符串 <code>&quot;MongoDB&quot;</code>， 如图 2-7 所示。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e28c1620.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e28c1620.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如果一个程序员决定通过执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcat(s1, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure><p>将 <code>s1</code> 的内容修改为 <code>&quot;Redis Cluster&quot;</code> ， 但粗心的他却忘了在执行 <code>strcat</code> 之前为 <code>s1</code> 分配足够的空间， 那么在 <code>strcat</code> 函数执行之后， <code>s1</code> 的数据将溢出到 <code>s2</code> 所在的空间中， 导致 <code>s2</code> 保存的内容被意外地修改， 如图 2-8 所示。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e29e04a2.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e29e04a2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p><p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 <code>sdscat</code> 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， <code>sdscat</code> 会先检查给定 SDS 的空间是否足够， 如果不够的话， <code>sdscat</code> 就会先扩展 SDS 的空间， 然后才执行拼接操作。</p><p>比如说， 如果我们执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdscat(s, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure><p>其中 SDS 值 <code>s</code> 如图 2-9 所示， 那么 <code>sdscat</code> 将在执行拼接操作之前检查 <code>s</code> 的长度是否足够， 在发现 <code>s</code> 目前的空间不足以拼接 <code>&quot; Cluster&quot;</code>之后， <code>sdscat</code> 就会先扩展 <code>s</code> 的空间， 然后才执行拼接 <code>&quot; Cluster&quot;</code> 的操作， 拼接操作完成之后的 SDS 如图 2-10 所示。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e30446df.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e30446df.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e315f5ac.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e315f5ac.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意图 2-10 所示的 SDS ： <code>sdscat</code> 不仅对这个 SDS 进行了拼接操作， 它还为 SDS 分配了 <code>13</code> 字节的未使用空间， 并且拼接之后的字符串也正好是 <code>13</code> 字节长， 这种现象既不是 bug 也不是巧合， 它和 SDS 的空间分配策略有关， 接下来的小节将对这一策略进行说明。</p><h4 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h4><p>正如前两个小节所说， 因为 C 字符串并不记录自身的长度， 所以对于一个包含了 <code>N</code> 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 <code>N+1</code> 个字符长的数组（额外的一个字符空间用于保存空字符）。</p><p>因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：</p><ul><li>如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。</li></ul><p>举个例子， 如果我们持有一个值为 <code>&quot;Redis&quot;</code> 的 C 字符串 <code>s</code> ， 那么为了将 <code>s</code> 的值改为 <code>&quot;Redis Cluster&quot;</code> ， 在执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcat(s, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure><p>之前， 我们需要先使用内存重分配操作， 扩展 <code>s</code> 的空间。</p><p>之后， 如果我们又打算将 <code>s</code> 的值从 <code>&quot;Redis Cluster&quot;</code> 改为 <code>&quot;Redis Cluster Tutorial&quot;</code> ， 那么在执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcat(s, &quot; Tutorial&quot;);</span><br></pre></td></tr></table></figure><p>之前， 我们需要再次使用内存重分配扩展 <code>s</code> 的空间， 诸如此类。</p><p>因为内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以它通常是一个比较耗时的操作：</p><ul><li>在一般程序中， 如果修改字符串长度的情况不太常出现， 那么每次修改都执行一次内存重分配是可以接受的。</li><li>但是 Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。</li></ul><p>为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， <code>buf</code> 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 <code>free</code> 属性记录。</p><p>通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。</p><h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。</p><p>其中， 额外分配的未使用空间数量由以下公式决定：</p><ul><li>如果对 SDS 进行修改之后， SDS 的长度（也即是 <code>len</code> 属性的值）将小于 <code>1 MB</code> ， 那么程序分配和 <code>len</code> 属性同样大小的未使用空间， 这时 SDS <code>len</code> 属性的值将和 <code>free</code> 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 <code>len</code> 将变成 <code>13</code> 字节， 那么程序也会分配<code>13</code> 字节的未使用空间， SDS 的 <code>buf</code> 数组的实际长度将变成 <code>13 + 13 + 1 = 27</code> 字节（额外的一字节用于保存空字符）。</li><li>如果对 SDS 进行修改之后， SDS 的长度将大于等于 <code>1 MB</code> ， 那么程序会分配 <code>1 MB</code> 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 <code>len</code> 将变成 <code>30 MB</code> ， 那么程序会分配 <code>1 MB</code> 的未使用空间， SDS 的 <code>buf</code> 数组的实际长度将为 <code>30 MB + 1 MB + 1 byte</code> 。</li></ul><p>通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数。</p><p>举个例子， 对于图 2-11 所示的 SDS 值 <code>s</code> 来说， 如果我们执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdscat(s, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure><p>那么 <code>sdscat</code> 将执行一次内存重分配操作， 将 SDS 的长度修改为 <code>13</code> 字节， 并将 SDS 的未使用空间同样修改为 <code>13</code> 字节， 如图 2-12 所示。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e329713a.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e329713a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e33eb3a4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e33eb3a4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>如果这时， 我们再次对 <code>s</code> 执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdscat(s, &quot; Tutorial&quot;);</span><br></pre></td></tr></table></figure><p>那么这次 <code>sdscat</code> 将不需要执行内存重分配： 因为未使用空间里面的 <code>13</code> 字节足以保存 <code>9</code> 字节的 <code>&quot; Tutorial&quot;</code> ， 执行 <code>sdscat</code> 之后的 SDS 如图 2-13 所示。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e3578644.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e3578644.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。</p><p>通过这种预分配策略， SDS 将连续增长 <code>N</code> 次字符串所需的内存重分配次数从必定 <code>N</code> 次降低为最多 <code>N</code> 次。</p><h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 <code>free</code> 属性将这些字节的数量记录起来， 并等待将来使用。</p><p>举个例子， <code>sdstrim</code> 函数接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</p><p>比如对于图 2-14 所示的 SDS 值 <code>s</code> 来说， 执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdstrim(s, &quot;XY&quot;);   &#x2F;&#x2F; 移除 SDS 字符串中的所有 &#39;X&#39; 和 &#39;Y&#39;</span><br></pre></td></tr></table></figure><p>会将 SDS 修改成图 2-15 所示的样子。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e3698506.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e3698506.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e3856487.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e3856487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>注意执行 <code>sdstrim</code> 之后的 SDS 并没有释放多出来的 <code>8</code> 字节空间， 而是将这 <code>8</code> 字节空间作为未使用空间保留在了 SDS 里面， 如果将来要对 SDS 进行增长操作的话， 这些未使用空间就可能会派上用场。</p><p>举个例子， 如果现在对 <code>s</code> 执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdscat(s, &quot; Redis&quot;);</span><br></pre></td></tr></table></figure><p>那么完成这次 <code>sdscat</code> 操作将不需要执行内存重分配： 因为 SDS 里面预留的 <code>8</code> 字节空间已经足以拼接 <code>6</code> 个字节长的 <code>&quot; Redis&quot;</code> ， 如图 2-16 所示。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e39ce035.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e39ce035.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。</p><p>与此同时， SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p><p>举个例子， 如果有一种使用空字符来分割多个单词的特殊数据格式， 如图 2-17 所示， 那么这种格式就不能使用 C 字符串来保存， 因为 C 字符串所用的函数只会识别出其中的 <code>&quot;Redis&quot;</code> ， 而忽略之后的 <code>&quot;Cluster&quot;</code> 。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e3b04bab.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e3b04bab.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>虽然数据库一般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此， 为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf</code> 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。</p><p>这也是我们将 SDS 的 <code>buf</code> 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。</p><p>比如说， 使用 SDS 来保存之前提到的特殊数据格式就没有任何问题， 因为 SDS 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束， 如图 2-18 所示。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e3cdec5b.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e3cdec5b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据。</p><h4 id="兼容部分-C-字符串函数"><a href="#兼容部分-C-字符串函数" class="headerlink" title="兼容部分 C 字符串函数"></a>兼容部分 C 字符串函数</h4><p>虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 <code>buf</code> 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <code>&lt;string.h&gt;</code>库定义的函数。</p><p><img src="https://box.kancloud.cn/2015-09-13_55f50e3e47994.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e3e47994.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>举个例子， 如图 2-19 所示， 如果我们有一个保存文本数据的 SDS 值 <code>sds</code> ， 那么我们就可以重用 <code>&lt;string.h&gt;/strcasecmp</code> 函数， 使用它来对比 SDS 保存的字符串和另一个 C 字符串：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcasecmp(sds-&gt;buf, &quot;hello world&quot;);</span><br></pre></td></tr></table></figure><p>这样 Redis 就不用自己专门去写一个函数来对比 SDS 值和 C 字符串值了。</p><p>与此类似， 我们还可以将一个保存文本数据的 SDS 作为 <code>strcat</code> 函数的第二个参数， 将 SDS 保存的字符串追加到一个 C 字符串的后面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcat(c_string, sds-&gt;buf);</span><br></pre></td></tr></table></figure><p>这样 Redis 就不用专门编写一个将 SDS 字符串追加到 C 字符串之后的函数了。</p><p>通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 <code>&lt;string.h&gt;</code> 函数库， 从而避免了不必要的代码重复。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>表 2-1 对 C 字符串和 SDS 之间的区别进行了总结。</p><hr><p>表 2-1 C 字符串和 SDS 之间的区别</p><table><thead><tr><th>C 字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为 <img src="https://box.kancloud.cn/2015-09-13_55f50e14dc650.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e14dc650.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> 。</td><td>获取字符串长度的复杂度为 <img src="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"> 。</td></tr><tr><td>API 是不安全的，可能会造成缓冲区溢出。</td><td>API 是安全的，不会造成缓冲区溢出。</td></tr><tr><td>修改字符串长度 <code>N</code> 次必然需要执行 <code>N</code> 次内存重分配。</td><td>修改字符串长度 <code>N</code> 次最多需要执行 <code>N</code> 次内存重分配。(极大成都降低了频繁内存分配导致的开销)</td></tr><tr><td>只能保存文本数据。</td><td>可以保存文本或者二进制数据。</td></tr><tr><td>可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数。</td><td>可以使用一部分 <code>&lt;string.h&gt;</code> 库中的函数。</td></tr></tbody></table><h3 id="sds-1-0-主要API"><a href="#sds-1-0-主要API" class="headerlink" title="sds 1.0 主要API"></a>sds 1.0 主要API</h3><p>表 2-2 SDS 的主要操作 API</p><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>sdsnew</code></td><td>创建一个包含给定 C 字符串的 SDS 。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为给定 C 字符串的长度。</td></tr><tr><td><code>sdsempty</code></td><td>创建一个不包含任何内容的空 SDS 。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>sdsfree</code></td><td>释放给定的 SDS 。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"></td></tr><tr><td><code>sdslen</code></td><td>返回 SDS 的已使用空间字节数。</td><td>这个值可以通过读取 SDS 的 <code>len</code> 属性来直接获得， 复杂度为 <img src="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"> 。</td></tr><tr><td><code>sdsavail</code></td><td>返回 SDS 的未使用空间字节数。</td><td>这个值可以通过读取 SDS 的 <code>free</code> 属性来直接获得， 复杂度为 <img src="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"> 。</td></tr><tr><td><code>sdsdup</code></td><td>创建一个给定 SDS 的副本（copy）。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为给定 SDS 的长度。</td></tr><tr><td><code>sdsclear</code></td><td>清空 SDS 保存的字符串内容。</td><td>因为惰性空间释放策略，复杂度为 <img src="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e99de6fb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(1)"> 。</td></tr><tr><td><code>sdscat</code></td><td>将给定 C 字符串拼接到 SDS 字符串的末尾。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为被拼接 C 字符串的长度。</td></tr><tr><td><code>sdscatsds</code></td><td>将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为被拼接 SDS 字符串的长度。</td></tr><tr><td><code>sdscpy</code></td><td>将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为被复制 C 字符串的长度。</td></tr><tr><td><code>sdsgrowzero</code></td><td>用空字符将 SDS 扩展至给定长度。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为扩展新增的字节数。</td></tr><tr><td><code>sdsrange</code></td><td>保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为被保留数据的字节数。</td></tr><tr><td><code>sdstrim</code></td><td>接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50eae65cb0.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50eae65cb0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(M*N)"> ， <code>M</code> 为 SDS 的长度， <code>N</code> 为给定 C 字符串的长度。</td></tr><tr><td><code>sdscmp</code></td><td>对比两个 SDS 字符串是否相同。</td><td><img src="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" class="lazyload" data-srcset="https://box.kancloud.cn/2015-09-13_55f50e98b76b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O(N)"> ， <code>N</code> 为两个 SDS 中较短的那个 SDS 的长度。</td></tr></tbody></table><h2 id="SDS2-0"><a href="#SDS2-0" class="headerlink" title="SDS2.0"></a>SDS2.0</h2><blockquote><p>2.0 原由</p><p><a href="https://github.com/antirez/redis/issues/757" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/antirez/redis/issues/757</a><br>问题就在len和free的使用类型上，使用的是unsigned int</p><ul><li>unsigned int，也就是32位，最多只能记录4GB大小，超过4G的大小将无法使用</li><li>内存损耗，如果字符串都非常短，可能16位就能记录，那么32位就损耗了2位</li></ul><p>简单的换len和free的类型是不行的，仔细观察上面两个缺点，发现他们其实是有点互斥的成分在里面。<br>一个嫌弃是unsigned int过小，一个是嫌弃unsigned int过大</p><p>然后这个PR就提出了自适应的sdshdr<br><a href="https://github.com/antirez/redis/pull/2509" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/antirez/redis/pull/2509</a>也就是SDS2.0的实现</p></blockquote><h3 id="SDS-2-0-定义"><a href="#SDS-2-0-定义" class="headerlink" title="SDS 2.0 定义"></a>SDS 2.0 定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>len</code>：字符串的长度，不包含<code>&#39;\0&#39;</code>，<code>&#39;\0&#39;</code>由自己维护，用户不需要关心；</p></li><li><p><code>alloc</code>：申请的内存空间大小；</p></li><li><p><code>flags</code>：类型，当前仅使用低三位，后续可能会有扩展，用于判断当前sds对应的header的类型；</p></li><li><p><code>buf</code>：变长部分，存储数据；</p></li></ul><p>2.0 根据长度的不同，分成了5种， 分别是5位，8位，16位，32位，64位。</p><p>其中sdshdr5较为特殊，没有len和alloc，flags的3位表示类型，剩下的5位表示长度，最多只能表示$2^5 = 32$长度的字符串。</p><p>2.0版本与1.0版本本质功能上差别不大。</p><ul><li><p>最大的区别就是<code>header</code>的定义，分成5类记录长度，而不是之前的<code>int len</code>，是为了节省内存（抠的着实是有些细了）。</p></li><li><p>其次在非32位环境下支持超过4GB大小内存的能力。</p></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>比起 C 字符串， SDS 具有以下优点：</p><ol><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出。</li><li>减少修改字符串长度时所需的内存重分配次数。</li><li>二进制安全。</li><li>兼容部分 C 字符串函数。</li></ol>]]></content>
    
    
    <summary type="html">redis 基础数据结构 - 简单动态字符串。redis 3.2 版本更新了 sds 2.0， 本文简单总结下sds1.0，再总结下sds2.0.</summary>
    
    
    
    <category term="redis" scheme="http://blog.tabris.top/categories/redis/"/>
    
    
    <category term="redis" scheme="http://blog.tabris.top/tags/redis/"/>
    
    <category term="sds" scheme="http://blog.tabris.top/tags/sds/"/>
    
  </entry>
  
  <entry>
    <title>StudyGolang</title>
    <link href="http://blog.tabris.top/StudyGolang/"/>
    <id>http://blog.tabris.top/StudyGolang/</id>
    <published>2019-11-08T15:33:11.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://go-zh.org/" target="_blank" rel="noopener external nofollow noreferrer">Go 中文主页</a></p><p>先把这个教程看完 - <a href="https://tour.go-zh.org/" target="_blank" rel="noopener external nofollow noreferrer">Go 指南</a></p><span id="more"></span><p>然后就去写代码</p><p>完毕</p><hr><h1 id="go-语言常用的一些代码-刷题"><a href="#go-语言常用的一些代码-刷题" class="headerlink" title="go 语言常用的一些代码 (刷题"></a>go 语言常用的一些代码 (刷题</h1><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><p>[【Go语言】基本类型排序和 slice 排序](<a href="https://itimetraveler.github.io/2016/09/07/%E3%80%90Go%E8%AF%AD%E8%A8%80%E3%80%91%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F%E5%92%8C" target="_blank" rel="noopener external nofollow noreferrer">https://itimetraveler.github.io/2016/09/07/【Go语言】基本类型排序和</a> slice 排序/)</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 Person.Age 从大到小排序</span></span><br><span class="line"><span class="keyword">type</span> PersonSlice [] Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;     <span class="comment">// 重写 Len() 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>&#123;     <span class="comment">// 重写 Swap() 方法</span></span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a PersonSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;    <span class="comment">// 重写 Less() 方法， 从大到小排序</span></span><br><span class="line">    <span class="keyword">return</span> a[j].Age &lt; a[i].Age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := [] Person&#123;</span><br><span class="line">        &#123;<span class="string">&quot;zhang san&quot;</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;li si&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;wang wu&quot;</span>, <span class="number">52</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;zhao liu&quot;</span>, <span class="number">26</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(people)</span><br><span class="line"></span><br><span class="line">    sort.Sort(PersonSlice(people))    <span class="comment">// 按照 Age 的逆序排序</span></span><br><span class="line">    fmt.Println(people)</span><br><span class="line"></span><br><span class="line">    sort.Sort(sort.Reverse(PersonSlice(people)))    <span class="comment">// 按照 Age 的升序排序</span></span><br><span class="line">    fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟C-的Vector"><a href="#模拟C-的Vector" class="headerlink" title="模拟C++的Vector"></a>模拟C++的Vector</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一维</span></span><br><span class="line"><span class="comment"> * 初始长度为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)      <span class="comment">// 相当于C++ vector&lt;int&gt; ans;</span></span><br><span class="line">ans = <span class="built_in">append</span>(ans, <span class="number">23</span>)      <span class="comment">// 相当于C++ ans.push_back(23);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维切片</span></span><br><span class="line"><span class="comment"> * LeetCode 5280</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupThePeople</span><span class="params">(groupSizes []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)            <span class="comment">// 相当于C++ vector&lt;vector&lt;int&gt; &gt; ans;</span></span><br><span class="line"></span><br><span class="line">    cnt := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">500</span>)          <span class="comment">// 相当于C++ vector&lt;int&gt; cnt[500];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> groupSizes &#123;</span><br><span class="line">        cnt[v] = <span class="built_in">append</span>(cnt[v], i)     <span class="comment">// 相当于C++ cnt[v].push_back(i);</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cnt[v]) == v &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, cnt[v])  <span class="comment">// 相当于C++ ans.push_back(cnt[v]);</span></span><br><span class="line">            cnt[v] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)    <span class="comment">// 相当于C++ cnt.clear();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="刷题板子"><a href="#刷题板子" class="headerlink" title="刷题板子"></a>刷题板子</h1><h2 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> lcs(<span class="keyword">string</span> word1, <span class="keyword">string</span> word2) &#123;</span><br><span class="line">    <span class="keyword">int</span> ls1 = word1.size(), ls2 = word2.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=ls1; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=ls2; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[ls1][ls2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双层二进制枚举</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = j; x; x = (x - <span class="number">1</span>) &amp; j)  <span class="comment">// 这里有个优化</span></span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">type</span> unionSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    fa [<span class="number">100004</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="comment">// length_ [100004]int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func (u *unionSet) length(x int) int &#123;</span></span><br><span class="line"><span class="comment">// return u.length_[u.find(x)]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *unionSet)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r := x</span><br><span class="line">    <span class="keyword">for</span> r != u.fa[r] &#123;</span><br><span class="line">        r = u.fa[r]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i, j := x, r</span><br><span class="line">    <span class="keyword">for</span> i!=j &#123;</span><br><span class="line">        j = u.fa[i]</span><br><span class="line">        u.fa[i]=r</span><br><span class="line">        i=j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *unionSet)</span> <span class="title">join</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fx, fy := u.find(x), u.find(y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fx != fy &#123;</span><br><span class="line">        u.fa[fy]=fx</span><br><span class="line">        <span class="comment">// if u.length(fx) &gt; u.length(fy) &#123;</span></span><br><span class="line">        <span class="comment">//     u.fa[fy]=fx</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     u.fa[fx]=fy</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// u.length_[fx], u.length_[fy] = u.length(fx) + u.length(fy), u.length(fx) + u.length(fy)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义结构体-排序"><a href="#自定义结构体-排序" class="headerlink" title="自定义结构体+排序"></a>自定义结构体+排序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义结构体+排序</span></span><br><span class="line"><span class="keyword">type</span> box <span class="keyword">struct</span> &#123;</span><br><span class="line">    num <span class="keyword">int</span></span><br><span class="line">    size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> boxSlice []box</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t boxSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="keyword">return</span> <span class="built_in">len</span>(t)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t boxSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t[i].size &gt; t[j].size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t boxSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t[i], t[j] = t[j], t[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eg:</span></span><br><span class="line">    a := []box</span><br><span class="line">    sort.Sort(boxSlice(a))</span><br></pre></td></tr></table></figure><h2 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lis</span></span><br><span class="line">lis := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lis) == <span class="number">0</span> &#123;</span><br><span class="line">        lis = <span class="built_in">append</span>(lis, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> lis[<span class="built_in">len</span>(lis)<span class="number">-1</span>] != MOD &#123;</span><br><span class="line">        lis = <span class="built_in">append</span>(lis, MOD)</span><br><span class="line">        &#125;</span><br><span class="line">        pos := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            l, r, mid, ans := <span class="number">0</span>, <span class="built_in">len</span>(lis)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> l&lt;=r &#123;</span><br><span class="line">                mid = (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> lis[mid] &gt;= v &#123;</span><br><span class="line">                    r, ans = mid<span class="number">-1</span>, mid</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid+<span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        &#125;()</span><br><span class="line">        lis[pos] = v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BIT-树状数组"><a href="#BIT-树状数组" class="headerlink" title="BIT(树状数组)"></a>BIT(树状数组)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum [<span class="number">100009</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowbit</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(sum [100009]<span class="keyword">int</span>, i, v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ;i&lt;=<span class="number">100000</span>; i+=lowbit(i) &#123;</span><br><span class="line">        sum[i]+=v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(sum [100009]<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; i&gt;<span class="number">0</span>; i-=lowbit(i) &#123;</span><br><span class="line">        ans += sum[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Golang</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="Golang" scheme="http://blog.tabris.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>终于用上MBP了</title>
    <link href="http://blog.tabris.top/osx/"/>
    <id>http://blog.tabris.top/osx/</id>
    <published>2019-09-15T20:21:03.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="osx-真香"><a href="#osx-真香" class="headerlink" title="osx 真香!"></a>osx 真香!</h1><blockquote><p>公司给发了个MacBook Pro 然后就基本告别Manjaro了,</p><p>这里介绍下使用osx的一些体验</p></blockquote><blockquote><p><a href="https://blog.csdn.net/huhuijun123/article/details/84815267" target="_blank" rel="noopener external nofollow noreferrer">Mac tips - 打开【键盘重复按键】功能</a></p><p>很多App 在 Mac 下长按某个键时只会触发一次。 比如在Sublime Text下， 用 Vim 模式来 操作时， 长按 「J」 时， 只会按下跳一行。 但是奇怪开了中文输入法后又可以一直往下跳。<br>其实我们是可以用下面的命令来重新默认打开这个功能。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">defaults write -g ApplePressAndHoldEnabled -bool false</span><br></pre></td></tr></table></figure><p>注销并重新登录系统使其更改生效。<br>如果需要恢复长按键盘可以重音字符或非英文字符的功能，请打开终端窗口，运行以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">defaults delete -g ApplePressAndHoldEnabled</span><br></pre></td></tr></table></figure></blockquote><h2 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h2><h3 id="GUI软件"><a href="#GUI软件" class="headerlink" title="GUI软件"></a>GUI软件</h3><p><strong>vscode</strong>: 开源的编辑器, 体验很棒</p><p><del><strong>jetbrains tool box</strong>: 管理jetbrains哪些ide和工程的,推荐</del></p><p><strong>Chrome</strong>: 浏览器, 依赖于它的很多插件, 换不了,  太费内存了...</p><p><strong>typora</strong>: markdown编辑器, 单页 实时预览,很nice</p><p><del><strong>proxifer</strong>: 改代理用的软件.</del></p><p><strong>Beyound Compare</strong>: 文件比较工具, 本来不想用的, git的话 就直接<code>git diff</code>了, 但是公司好多代码还在<code>svn</code>上.</p><p><strong>onedrive</strong>: 微软家的网盘, 跨平台同步的工具,</p><p><del><strong>navicat</strong>: 操作数据库的, 超级好用.(收费软件，后来用sequal pro代替)</del></p><p><del><strong>markText</strong>: markdown编辑器, 挺好用的.</del></p><p><strong><a href="https://fliqlo.com/" target="_blank" rel="noopener external nofollow noreferrer">Fliqlo</a></strong>: 好看翻页时钟屏保。</p><hr><blockquote><p>mac独有分割线</p></blockquote><p><strong>iina</strong>: 看视频的软件,大多格式的都能放</p><p><strong>itsycal</strong>: 在menu bar上的时间点一下会出现日历</p><p><del><strong>cheatsheet</strong>: 长按<code>command</code>出现当前应用所有快捷键, 用<code>键指如飞/FlyKey</code>代替了</del></p><p><strong>iglance</strong>: 在Mac menu bar上显示CPU内存网速电池等信息的小工具</p><p><strong>Alfred4</strong>: 启动器, 比自带的好用得多,  但高端功能要花钱.</p><p><strong>cakebrew</strong>: homebrew的可视化版, 还挺好用, 但是有的软件找不到..</p><p><strong>karabiner</strong>: 键盘映射工具</p><p><strong>keycastr</strong>:显示键盘按键的软件</p><p><strong>GetPlainText</strong>: 复制时删除样式.</p><p><strong>bartender 4</strong>: 整理menu bar的工具.</p><p><strong>ForkLift</strong>: finder 的替代品,</p><p><strong>Lemon</strong>: 柠檬清理.</p><p><strong>Get Plain Text</strong>: 复制粘贴的时候清除格式</p><p><strong>SwitchResX</strong>: 快速修改屏幕分辨率的Mac软件</p><p><strong><a href="https://www.better365.cn/bab2.html" target="_blank" rel="noopener external nofollow noreferrer">Better And Better 2.0</a></strong>: Better And Better 2.0 将强大功能与优秀人机交互结合提升到一个崭新的高度。全面提升Mac触控板、鼠标、键盘使用，数百种动作手势、绘图手势与预设、脚本、快捷键完美协作，为你带来无与伦比的Mac操作体验。</p><p><strong><a href="https://www.better365.cn/irightmouse.html" target="_blank" rel="noopener external nofollow noreferrer">超级右键</a></strong>: 超级右键以优秀设计与丰富功能为Mac带来绝佳的使用体验，众多功能与右键融为一体，深得人心的设计，让你即刻进入高效的Mac使用体验，快、高效、便捷，效果出奇的好</p><p><strong><a href="https://www.better365.cn/ishot.html" target="_blank" rel="noopener external nofollow noreferrer">ishot</a></strong>: iShot堪称macOS上功能最为全面的截图、录屏工具，<br>截图、长截图、多窗口截图、延时截图、标注、贴图、取色、录屏......</p><p><strong><a href="https://www.better365.cn/AutoSwitchInput.html" target="_blank" rel="noopener external nofollow noreferrer">自动切换输入法</a></strong>: 在自动切换输入法内，提前设置每个App对应的输入法，切换至该App时，将为您自动切换至为他设定好的输入法。</p><p><strong><a href="https://www.better365.cn/FlyKey.html" target="_blank" rel="noopener external nofollow noreferrer">键指如飞/FlyKey</a></strong>: 键指如飞默认使用双击Command显示当前App的所有快捷键</p><p><strong><a href="https://rectangleapp.com/" target="_blank" rel="noopener external nofollow noreferrer">rectangle</a></strong>: 桌面窗口管理。</p><p><strong><a href="https://pock.dev/" target="_blank" rel="noopener external nofollow noreferrer">pock</a></strong>: 在触控栏中显示macOS程序坞</p><p><img src="https://camo.githubusercontent.com/401d36fc151b85b5c001acb6c026c4c33c86aea9949a73bd2bbab811678e9a77/68747470733a2f2f706f636b2e6465762f6173736574732f696d672f707265766965772f706f636b5f776964676574732e706e67" class="lazyload" data-srcset="https://camo.githubusercontent.com/401d36fc151b85b5c001acb6c026c4c33c86aea9949a73bd2bbab811678e9a77/68747470733a2f2f706f636b2e6465762f6173736574732f696d672f707265766965772f706f636b5f776964676574732e706e67" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong><a href="https://copyless.net/" target="_blank" rel="noopener external nofollow noreferrer">copyless 2</a></strong>: 剪贴板管理器. 最多可以存储1000个最新剪辑</p><p><strong><a href="https://github.com/Caldis/Mos" target="_blank" rel="noopener external nofollow noreferrer">Mos</a></strong>: 一个用于在MacOS上平滑你的鼠标滚动效果的小工具, 让你的滚轮爽如触控板。</p><p><strong><a href="https://apps.apple.com/cn/app/amphetamine/id937984704?mt=12" target="_blank" rel="noopener external nofollow noreferrer">Amphetamine</a></strong>: 防睡眠软件。</p><hr><h3 id="Terminal软件"><a href="#Terminal软件" class="headerlink" title="Terminal软件"></a>Terminal软件</h3><p><strong>iterm2</strong>: mac下的终端模拟软件,<strong>其实是GUI软件的,故意放在这里</strong></p><p><del><strong>thefuck</strong>: 帮忙修正手误导致的错误命令</del></p><p><strong>tmux</strong>: 终端复用工具,</p><p><strong>neovim</strong>: 从vim上fork来的, (没怎么用过vim, 无法做出比较,</p><p><strong>ranger</strong>: 终端下的文件管理器,配置后能预览图片,显示压缩文件信息等, 加上类vi的操作方式,很奈斯</p><p><del><strong>wtfutil</strong>: 命令行下的仪表盘工具, 插件丰富,同时也可以自己开发提交pr, 比较推荐</del></p><p><strong>homebrew</strong>: mac的软件包管理器, 一般好用吧, 用过pacman感觉其他的都不太行</p><p><strong>glances</strong>: python实现的高级top工具, 之前有时候会崩，崩的时候用<code>htop</code>代替</p><p><strong>docker</strong>: mac的docker感觉和linux的不太一样 会有个应用程序在启动器里面..</p><p><strong>ripgrep</strong>: 搜索工具, 快</p><p><strong>lsd</strong>: ls的替代品, rust写的 好看又快</p><p><strong>nvm</strong>: Node Version Manager, node版本管理工具, 好用</p><p><strong>whistle</strong>: 代理配置软件</p><p><strong>mycli</strong>: 好用的mysql客户端</p>]]></content>
    
    
    <summary type="html">公司给发了个MacBook Pro 然后就基本告别Manjaro了,这里介绍下使用osx的一些体验</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="osx" scheme="http://blog.tabris.top/tags/osx/"/>
    
  </entry>
  
  <entry>
    <title>python import</title>
    <link href="http://blog.tabris.top/pythonImport/"/>
    <id>http://blog.tabris.top/pythonImport/</id>
    <published>2019-08-26T12:43:03.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>未完待续</strong></em></p></blockquote><h1 id="python-import研究"><a href="#python-import研究" class="headerlink" title="python import研究"></a>python import研究</h1><p>​    <code>python</code>用了好久了, 对它的<code>import</code>规则一直都很懵,借此机会梳理下.</p><span id="more"></span><h3 id="首先是导包"><a href="#首先是导包" class="headerlink" title="首先是导包."></a>首先是导包.</h3><p>导入同目录下的包, 或者安装好的第三方模块, 或者python自带的模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name</span><br></pre></td></tr></table></figure><p>导入当前目录中某一文件夹里面的<code>python</code>模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="built_in">dir</span> <span class="keyword">import</span> module_name</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">python import研究,持续更新</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="python" scheme="http://blog.tabris.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>travis-ci 自动化部署hexo静态博客</title>
    <link href="http://blog.tabris.top/test_travis/"/>
    <id>http://blog.tabris.top/test_travis/</id>
    <published>2019-08-02T10:48:16.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="travis-ci-自动化部署hexo静态博客"><a href="#travis-ci-自动化部署hexo静态博客" class="headerlink" title="travis-ci 自动化部署hexo静态博客"></a>travis-ci 自动化部署hexo静态博客</h1><blockquote><p>使用github pages的用户应该都有一个痛点, 就是要本地写好博文后再执行<code>hexo c</code>,<code>hexo g</code>,<code>hexo d</code>等命令, 特别是当博文数量多了的时候<code>hexo g</code>就要等待几分钟甚至更长时间,然后在<code>hexo d</code> 甚是烦恼.</p><p>查了资料, 有了<code>travis-ci</code>这个<code>GitHub</code> 的亲兄弟,就容易的多了, 只需<code>3</code>步配置,就可以享受持续集成自动部署博客的.</p><p>用户只需要在<code>markdown</code>原文上修改,然后<code>push</code>到<code>github</code>上去就可以了,</p></blockquote><span id="more"></span><h2 id="Step-1-GitHub-上配置"><a href="#Step-1-GitHub-上配置" class="headerlink" title="Step 1 GitHub 上配置"></a>Step 1 GitHub 上配置</h2><ol><li><p>安装<code>github app</code></p><p> <a href="https://github.com/settings/installations" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/settings/installations</a></p><p> <img src="/images/test_travis.assets/image-20190825142940431.png" class="lazyload" data-srcset="/images/test_travis.assets/image-20190825142940431.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20190825142940431"></p></li><li><p>申请<code>Personal access tokens</code></p><p> 转送门 -&gt; <a href="https://github.com/settings/tokens" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/settings/tokens</a></p><p> 在这里主要是设置<code>github-token</code>,让<code>travis</code>有权限读写<code>github</code>项目文件</p><p> 去<code>github</code>上申请一个就好</p><p> 点<code>生产新的token</code>的按钮.申请好后就会出现下面的那个.</p><p> <img src="/images/test_travis.assets/image-20190825143124613.png" class="lazyload" data-srcset="/images/test_travis.assets/image-20190825143124613.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20190825143124613"></p><p> 我勾选的设置,可以参考</p><p> <img src="/images/test_travis.assets/image-20190825143240304.png" class="lazyload" data-srcset="/images/test_travis.assets/image-20190825143240304.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20190825143240304"></p></li></ol><h2 id="Step-2-配置travis-ci"><a href="#Step-2-配置travis-ci" class="headerlink" title="Step 2 配置travis-ci"></a>Step 2 配置travis-ci</h2><ol><li><p>在<a href="https://travis-ci.org/" target="_blank" rel="noopener external nofollow noreferrer">https://travis-ci.org</a>配置项目</p><blockquote><p>注意私有项目需要用<a href="https://travis-ci.com/" target="_blank" rel="noopener external nofollow noreferrer">https://travis-ci.com</a> 这个是需要费用的.</p></blockquote><p> 用<code>github</code>账号登录<a href="https://travis-ci.org/" target="_blank" rel="noopener external nofollow noreferrer">https://travis-ci.org</a>, 在右上角头像出现下拉框里面选择设置,</p><p> 然后找你博客源码所在项目, (我的项目放在<code>tabris233.github.io</code>的<code>blog-source</code>分支下,所以勾选这个项目,然后点后面的<code>Settings</code>)</p><p> <img src="/images/test_travis.assets/image-20190825140545978.png" class="lazyload" data-srcset="/images/test_travis.assets/image-20190825140545978.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20190825140545978"></p><p> 先在<code>2</code>上添加<code>github-token</code>值用刚刚申请好的哪一个, 后面在构建日志中展示值得选项可勾可不勾. 然后点<code>add</code>,  然后就会出现在<code>1</code>的位置.</p><p> Ps: <code>3</code> 是个定时构建, 看个人心情, 随意了.</p><p> <img src="/images/test_travis.assets/image-20190825141146382.png" class="lazyload" data-srcset="/images/test_travis.assets/image-20190825141146382.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20190825141146382"></p></li><li><p>要在项目根目录建立<code>.travis.yml</code>文件</p><blockquote><p>其实这个配置文件写的比较烂, <a href="https://travis-ci.org/" target="_blank" rel="noopener external nofollow noreferrer">https://travis-ci.org</a>对<code>github\ pages</code>有一个专门的配置<code>yaml</code>,</p><p>我这个算是专门配置加原始配置杂交出来的....</p><p>最后三行感觉没啥用,但是没有就是不行....</p></blockquote> <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span>   <span class="comment"># 指定运行环境</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">&#x27;11&#x27;</span>       <span class="comment"># node环境的版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span>           <span class="comment"># 该shell脚本只对github的blog-source分支生效</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">t&#x27;tblog-source</span></span><br><span class="line"></span><br><span class="line"><span class="attr">git:</span>                 <span class="comment"># 克隆github上的项目到travis</span></span><br><span class="line">  <span class="attr">quite:</span> <span class="literal">true</span>        <span class="comment"># 为了不打印一些日志，故设为安静克隆</span></span><br><span class="line">  <span class="attr">depth:</span> <span class="number">1</span>           <span class="comment"># 只克隆最新的一次commit提交，最多可以克隆最新的30次提交，但是没必要</span></span><br><span class="line">  <span class="attr">submodules:</span> <span class="literal">true</span>   <span class="comment"># 不克隆子项目(避免再次克隆hexo主题)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span> <span class="string">yarn</span>          <span class="comment"># 缓存yarn命令也就是yarn add命令执行后的目录文件，即node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">global</span> <span class="string">add</span> <span class="string">hexo-cli</span> <span class="comment"># 在安装阶段，运行yarn命令来安装依赖</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span>              <span class="comment"># 发布阶段</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span>    <span class="comment"># 解析支持者为github pages</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span> <span class="comment"># 必须打开，如果在travis构建期间你正在推代码，很可能误删你最新的上传代码</span></span><br><span class="line">  <span class="attr">github_token:</span> <span class="string">$GITHUB_TOKEN</span>  <span class="comment"># 在travis的环境变量获取授权码，表示travis有权对github的项目进行拉取推送操作</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span> <span class="comment"># 禁止travis对你的github项目进行强制推送</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">tabris233/tabris233.github.io</span></span><br><span class="line">  <span class="attr">target-branch:</span> <span class="string">master</span> <span class="comment"># 你推送到哪个分支.</span></span><br><span class="line">  <span class="attr">fqdn:</span> <span class="string">tabris.top</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">./public</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">tabris.dq@qq.com</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tabris</span></span><br><span class="line">  <span class="attr">project_name:</span> <span class="string">tabris_blog_travis-ci</span></span><br><span class="line">  <span class="attr">on:</span>                 <span class="comment"># 这个静态文件来自travis中的master分支</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">matery</span></span><br><span class="line">    <span class="attr">all_branches:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Step-3-travis-ci执行任务"><a href="#Step-3-travis-ci执行任务" class="headerlink" title="Step 3 travis-ci执行任务"></a>Step 3 travis-ci执行任务</h2><p>修改博文<code>markdown</code> 然后<code>push</code>上去就行了. 会看到这样的界面</p><p>包含构建日志什么的,最后会部署到<code>github pages</code>的<code>master</code>分支上</p><p><img src="/images/test_travis.assets/image-20190825141944578.png" class="lazyload" data-srcset="/images/test_travis.assets/image-20190825141944578.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20190825141944578"></p>]]></content>
    
    
    <summary type="html">用户只需要在`markdown`原文上修改,然后`push`到`github`上去就可以自动构建博客了</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>csdn博文迁移至hexo心路历程</title>
    <link href="http://blog.tabris.top/csdn2hexo/"/>
    <id>http://blog.tabris.top/csdn2hexo/</id>
    <published>2019-04-18T18:16:15.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  某天我之前的<code>hexo</code>主题被自己玩坏了, 决定换一个主题,</p><p>  同时突然想把之前<code>CSDN</code>博文迁移进来,CSDN这个网站是越来越傻逼了.</p><p>  最终选择了<a href="https://codeload.github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener external nofollow noreferrer">hexo-theme-matery</a>主题,</p><p>  但最艰难的博文迁移过程算是完成了,但仍然有很大瑕疵..</p><hr><p>  之前迁移的版本瑕疵很大，挑了个时间重新爬了一遍， 这次的思路是登录后爬取<code>CSDN</code>的<code>Markdown</code>原文。</p></blockquote><span id="more"></span><h1 id="HEXO更换主题-并配置"><a href="#HEXO更换主题-并配置" class="headerlink" title="HEXO更换主题,并配置"></a>HEXO更换主题,并配置</h1><p>有了<a href="https://easyhexo.com/" target="_blank" rel="noopener external nofollow noreferrer">easyHexo</a>这个项目做起来还是很容易的,里面很详细的介绍了<code>hexo</code>博客的构建部署及主题使用以及配置.</p><p>我这里就不在赘述了,只说几个坑吧.</p><h2 id="代码高亮问题"><a href="#代码高亮问题" class="headerlink" title="代码高亮问题"></a>代码高亮问题</h2><p>我采用的 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener external nofollow noreferrer">hexo-prism-plugin</a> 是一个代码高亮的插件,但是对<code>c++</code>代码的编写是必须为<code>cpp</code> 不能为 <code>c++</code>.</p><h2 id="渲染问题"><a href="#渲染问题" class="headerlink" title="渲染问题"></a>渲染问题</h2><p>之前的文件中存在<code>&#125; &#125;</code>这样的字符,<code>hexo</code>渲染的时候就会出现报错</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: (unknown path) [Line 31, Column 21]</span><br><span class="line">expected variable end</span><br></pre></td></tr></table></figure><p>参考了<a href="https://blog.csdn.net/chwshuang/article/details/52350559" target="_blank" rel="noopener external nofollow noreferrer">文章一</a>,<a href="https://www.jianshu.com/p/738ebe02029b" target="_blank" rel="noopener external nofollow noreferrer">文章二</a> 找到问题并解决</p><h1 id="CSDN博文迁移"><a href="#CSDN博文迁移" class="headerlink" title="CSDN博文迁移"></a>CSDN博文迁移</h1><blockquote><p>以下是<strong>新</strong>的迁移方法。 这次的思路是登录后爬取<code>CSDN</code>的<code>Markdown</code>原文。</p></blockquote><p>其实没啥好说的， 用这个代码就可以了。 </p><p><a href="https://github.com/tabris233/Spider/blob/master/csdn_out_md" target="_blank" rel="noopener external nofollow noreferrer">爬虫代码</a></p><p><strong>需要注意的是 我爬取的时候发现这个编辑页的链接在变， 这里可能要F12找下最新的。</strong></p><p>**<code>https://blog-console-api.csdn.net/v1/editor/getArticle?id=&#123;blog_id&#125;**</code></p><hr><blockquote><p>以下是<strong>旧</strong>的迁移方法。</p></blockquote><p>我这里有<code>300+</code>篇博文在<code>csdn</code>上,所以很难人工迁移,所以选择<code>python</code>爬虫的方式爬取迁移,</p><p>百度一通找了好多爬虫,不是太老了,就是效果不行,</p><p>最终我找到了一个能凑合用的脚本,<a href="https://github.com/gaocegege/csdn-blog-export" target="_blank" rel="noopener external nofollow noreferrer">csdn-blog-export</a></p><p>它能够自动爬取博文,并输出<code>markdown</code>文本或者<code>html</code>的代码,</p><p>但是年代还是过于老了, <code>CSDN</code>的网站<code>html</code>结构已经大变,于是进行了魔改,终于可以爬取到信息了,</p><p>期间主要是有几个问题</p><ol><li>  不适应新的网站<code>html</code>机构,</li></ol><pre><code>&gt;   魔改后可用</code></pre><ol start="2"><li>  缺少<code>hexo</code>需要的<code>yaml front matter</code>,</li></ol><pre><code>&gt;   添加此函数 获得`yaml front matter`&gt;&gt;&gt;&gt;   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHexoTitleMarkdown</span>(<span class="params">self, detail</span>):</span></span><br><span class="line">    title = <span class="string">&#x27;&lt;&#x27;</span> + \</span><br><span class="line">            html2text.html2text(detail.find(class_=<span class="string">&#x27;article-title-box&#x27;</span>).span.prettify()).rstrip(<span class="string">&#x27;\n&#x27;</span>) + \</span><br><span class="line">            <span class="string">&#x27;&gt;&#x27;</span> + \</span><br><span class="line">            html2text.html2text(detail.find(class_=<span class="string">&#x27;title-article&#x27;</span>).prettify()).rstrip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    date = html2text.html2text(detail.find(class_=<span class="string">&#x27;time&#x27;</span>).prettify()).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    date = date[:<span class="number">4</span>] + <span class="string">&#x27;-&#x27;</span> + date[<span class="number">5</span>:<span class="number">7</span>] + <span class="string">&#x27;-&#x27;</span> + date[<span class="number">8</span>:<span class="number">10</span>] + <span class="string">&#x27; &#x27;</span> + date[-<span class="number">8</span>:]</span><br><span class="line">    tags = detail.find_all(class_=<span class="string">&#x27;tag-link&#x27;</span>)</span><br><span class="line">    tags = <span class="built_in">map</span>(deleteURL, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="built_in">map</span>(html2text.html2text, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x.prettify(), tags))))</span><br><span class="line">    <span class="comment"># print(tags)</span></span><br><span class="line">    tags = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="string">&#x27;  - &#x27;</span> + x + <span class="string">&#x27;\n&#x27;</span>, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip(), tags)))</span><br><span class="line">    <span class="built_in">str</span> = <span class="string">u&#x27;&#x27;&#x27;---</span></span><br><span class="line"><span class="string">title: %s</span></span><br><span class="line"><span class="string">date: %s</span></span><br><span class="line"><span class="string">description:</span></span><br><span class="line"><span class="string">toc: true</span></span><br><span class="line"><span class="string">author: tabris</span></span><br><span class="line"><span class="string"># 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg</span></span><br><span class="line"><span class="string">img:</span></span><br><span class="line"><span class="string"># 如果top值为true，则会是首页推荐文章</span></span><br><span class="line"><span class="string">top: false</span></span><br><span class="line"><span class="string"># 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破</span></span><br><span class="line"><span class="string">password:</span></span><br><span class="line"><span class="string"># 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行</span></span><br><span class="line"><span class="string">mathjax: false</span></span><br><span class="line"><span class="string">summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span></span><br><span class="line"><span class="string">categories: OJ算法题</span></span><br><span class="line"><span class="string">tags:</span></span><br><span class="line"><span class="string">%s</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> % (title.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27; &#x27;</span>), date.replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27; &#x27;</span>), tags.replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    <span class="comment"># print(str)</span></span><br><span class="line">    <span class="comment"># exit(0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p>爬取得到的<code>markdown</code>文本格式不是很理想</p><blockquote><p>  <strong>这个问题并没有解决</strong></p><p>  最开始查看了这个脚本使用的<code>html</code>转<code>markdown</code>模块(<a href="https://github.com/aaronsw/html2text" target="_blank" rel="noopener external nofollow noreferrer">html2text</a>)最后一次维护是<code>2012</code>年,</p><p>  于是就换了一个新模块<a href="">html2markdown</a>,可最后发现这个模块的效果还不如<a href="https://github.com/aaronsw/html2text" target="_blank" rel="noopener external nofollow noreferrer">html2text</a>, 于是放弃.</p></blockquote></li></ol><hr><p>最终迁移到了<a href="https://blog.tabris.top/categories/OJ%E7%AE%97%E6%B3%95%E9%A2%98/">https://blog.tabris.top/categories/OJ算法题/</a>,</p><p>迁移脚本在这里<a href="https://github.com/tabris233/Spider/tree/master/csdn2hexo" target="_blank" rel="noopener external nofollow noreferrer">csdn2hexo</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;  某天我之前的&lt;code&gt;hexo&lt;/code&gt;主题被自己玩坏了, 决定换一个主题,&lt;/p&gt;
&lt;p&gt;  同时突然想把之前&lt;code&gt;CSDN&lt;/code&gt;博文迁移进来,CSDN这个网站是越来越傻逼了.&lt;/p&gt;
&lt;p&gt;  最终选择了&lt;a href=&quot;https://codeload.github.com/blinkfox/hexo-theme-matery&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;hexo-theme-matery&lt;/a&gt;主题,&lt;/p&gt;
&lt;p&gt;  但最艰难的博文迁移过程算是完成了,但仍然有很大瑕疵..&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;  之前迁移的版本瑕疵很大，挑了个时间重新爬了一遍， 这次的思路是登录后爬取&lt;code&gt;CSDN&lt;/code&gt;的&lt;code&gt;Markdown&lt;/code&gt;原文。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>主流应用换源or镜像加速</title>
    <link href="http://blog.tabris.top/ChangeSource/"/>
    <id>http://blog.tabris.top/ChangeSource/</id>
    <published>2019-04-14T10:59:03.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>国内换源加速.</p></blockquote><span id="more"></span><h1 id="Arch-or-manjaro-pacman"><a href="#Arch-or-manjaro-pacman" class="headerlink" title="Arch or manjaro : pacman"></a>Arch or manjaro : pacman</h1><h2 id="启用中国源"><a href="#启用中国源" class="headerlink" title="启用中国源"></a>启用中国源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -c China</span><br></pre></td></tr></table></figure><h2 id="添加archlinuxcn源"><a href="#添加archlinuxcn源" class="headerlink" title="添加archlinuxcn源"></a>添加archlinuxcn源</h2><p>archlinuxcn源至您的 /etc/pacman.conf</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[archlinuxcn]</span></span><br><span class="line"><span class="comment">#The Chinese Arch Linux communities packages.</span></span><br><span class="line"><span class="attr">SigLevel</span> = Optional TrustAll</span><br><span class="line"><span class="attr">Server</span> = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><h1 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h1><h2 id="1-备份原来的源"><a href="#1-备份原来的源" class="headerlink" title="1.备份原来的源"></a>1.备份原来的源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources_init.list</span><br></pre></td></tr></table></figure><p>将以前的源备份一下，以防以后可以用的。</p><h2 id="2-更换源"><a href="#2-更换源" class="headerlink" title="2.更换源"></a>2.更换源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>使用gedit打开文档，将下边的阿里源复制进去，然后点击保存关闭。</p><h3 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class="line"></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class="line"></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class="line"></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br></pre></td></tr></table></figure><h2 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h2><h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure><h3 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="4-其他常用源"><a href="#4-其他常用源" class="headerlink" title="4.其他常用源"></a>4.其他常用源</h2><h3 id="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"><a href="#西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）" class="headerlink" title="西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）"></a>西电源（只有校内网网线使用，但是不限制流量，还是十分靠谱的）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse</span><br><span class="line">#deb-src http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse</span><br><span class="line">#deb-src http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse</span><br><span class="line">#deb-src http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">#deb-src http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#deb http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse</span><br><span class="line">#deb-src http:&#x2F;&#x2F;linux.xidian.edu.cn&#x2F;mirrors&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse</span><br></pre></td></tr></table></figure><h3 id="网易源"><a href="#网易源" class="headerlink" title="网易源"></a>网易源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; wily-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h1 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h1><p><strong>pip国内的一些镜像</strong></p><ul><li>  阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener external nofollow noreferrer">http://mirrors.aliyun.com/pypi/simple/</a></li><li>  中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener external nofollow noreferrer">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>  豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener external nofollow noreferrer">http://pypi.douban.com/simple/</a></li><li>  清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener external nofollow noreferrer">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>  中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener external nofollow noreferrer">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul><p><strong>修改源方法：</strong></p><p><strong>临时使用：</strong><br>可以在使用pip的时候在后面加上-i参数，指定pip源<br>eg: <code>pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p><strong>永久修改：</strong><br><strong>linux:</strong><br>修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h1 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h1><blockquote><p>  <a href="https://ruby.taobao.org/" target="_blank" rel="noopener external nofollow noreferrer">https://ruby.taobao.org/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem sources -l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://gems.ruby-china.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 请确保只有 gems.ruby-china.org</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gem install rails</span></span><br></pre></td></tr></table></figure><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是阿里云的镜像加速器: <a href="https://oj7znbfj.mirror.aliyuncs.com/" target="_blank" rel="noopener external nofollow noreferrer">https://oj7znbfj.mirror.aliyuncs.com</a></p><p>新版的 <code>Docker</code> 使用 <code>/etc/docker/daemon.json（Linux）</code> 或者 <code>%programdata%\docker\config\daemon.json（Windows）</code> 来配置 <code>Daemon</code>。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://oj7znbfj.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>安装node.js后，现在的node.js已经自带了npm工具了，但是国外的源很慢，为了解决这个问题，同时使用cnpm替换npm，我们通过切换源，切换到国内淘宝的源中。下面是我的操作过程。简单记录便于以后自己查看。</p><ol><li><p>查看npm版本</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>升级npm版本</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm update</span><br></pre></td></tr></table></figure></li><li><p>查看npm配置</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure></li><li><p>更换源配置</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm config list / npm config get registery #检查是否替换成功</span><br></pre></td></tr></table></figure></li><li><p>安装cnpm插件</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure></li><li><p> 安装包测试</p></li></ol>]]></content>
    
    
    <summary type="html">应用换源</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="linux" scheme="http://blog.tabris.top/tags/linux/"/>
    
    <category term="git" scheme="http://blog.tabris.top/tags/git/"/>
    
    <category term="ruby" scheme="http://blog.tabris.top/tags/ruby/"/>
    
    <category term="docker" scheme="http://blog.tabris.top/tags/docker/"/>
    
    <category term="npm" scheme="http://blog.tabris.top/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>vim使用心得</title>
    <link href="http://blog.tabris.top/vim/"/>
    <id>http://blog.tabris.top/vim/</id>
    <published>2019-01-10T17:21:03.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h1><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>所有的 Unix Like 系统都会内建 vi 文本编辑器，其他的文本编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p>vim主要有以下几个优点.</p><ul><li>可以不使用鼠标，完全用键盘操作。</li><li>系统资源占用小，打开大文件毫无压力。</li><li>键盘命令变成肌肉记忆以后，操作速度极快。</li></ul><p>同时现今很多开源软件(ranger,lazygit)采用的快捷键都与vim类似.学习vim变得很有必要.</p><p>但我这里采用的是<code>neovim</code></p><p><a href="https://neovim.io/" target="_blank" rel="noopener external nofollow noreferrer">NeoVim</a> 旨在成为Vim的升级版，有不少对它的介绍，我就不赘述了。NeoVim官网强调了它的四大特点:</p><ul><li>Powerful plugins（强大的插件）</li><li>Better out-of-the-box（更好的开箱即用）</li><li>First-class embedding（高度支持嵌入模式）</li><li>Drop-in replacement for Vim（直接替换Vim）。</li></ul><h2 id="vim基本配置"><a href="#vim基本配置" class="headerlink" title="vim基本配置"></a>vim基本配置</h2><blockquote><p>了解的还不是很详细, 暂时以我自己的配置介绍</p></blockquote><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">&quot; base config</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> termguicolors                                  <span class="comment">&quot; true color</span></span><br><span class="line"><span class="keyword">colorscheme</span> NeoSolarized                           <span class="comment">&quot; scheme</span></span><br><span class="line"><span class="keyword">set</span> background=dark</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 自动折行</span></span><br><span class="line"><span class="keyword">set</span> linebreak</span><br><span class="line"><span class="keyword">set</span> nowrap</span><br><span class="line"><span class="comment">&quot;垂直滚动时，光标距离顶部/底部的位置（单位：行）。</span></span><br><span class="line"><span class="keyword">set</span> scrolloff=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;set textwidth=80</span></span><br><span class="line"><span class="comment">&quot; tabs and spaces handling</span></span><br><span class="line"><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"><span class="comment">&quot; 侦测文件类型</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 载入文件类型插件</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 为特定文件类型载入相关缩进文件</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="built_in">indent</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 设置空白字符的视觉提示</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">list</span> listchars=<span class="built_in">extend</span><span class="variable">s:</span>❯,precede<span class="variable">s:</span>❮,<span class="keyword">ta</span><span class="variable">b:</span>▸\ ,trai<span class="variable">l:</span>˽,space:·</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 高亮当前行列</span></span><br><span class="line"><span class="keyword">set</span> cursorcolumn</span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 搜索时忽略大小写。</span></span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="comment">&quot; 如果同时打开了ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索Test时，将不匹配test；搜索test时，将匹配Test。</span></span><br><span class="line"><span class="keyword">set</span> smartcase</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 打开英语单词的拼写检查。</span></span><br><span class="line"><span class="keyword">set</span> spell spelllang=en_us</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</span></span><br><span class="line"><span class="keyword">set</span> autochdir</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">&quot; keyboard map</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">&quot; sudo保存</span></span><br><span class="line"><span class="keyword">ca</span> w!! <span class="keyword">w</span> !sudo tee <span class="string">&quot;%&quot;</span></span><br><span class="line"></span><br><span class="line">tnoremap <span class="symbol">&lt;ESC&gt;</span>    &lt;C-\&gt;<span class="symbol">&lt;C-n&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;去行首空格</span></span><br><span class="line"><span class="comment">&quot;:%s/^\s\+</span></span><br><span class="line"><span class="comment">&quot;去行末空格</span></span><br><span class="line"><span class="comment">&quot;:%s/\s\+$</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vim插件管理器"><a href="#vim插件管理器" class="headerlink" title="vim插件管理器"></a>vim插件管理器</h2><blockquote><p>参考 <a href="https://www.jianshu.com/p/0c83e6aed270" target="_blank" rel="noopener external nofollow noreferrer">https://www.jianshu.com/p/0c83e6aed270</a></p><p><strong>每安装一个插件最好都要去github官网看下,顺便看看文档, 会让你安装的插件用起来更顺手.</strong></p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>现在流行的有这几种插件管理器,<code>VBunle</code>,<code>NeoBunle</code>,<code>vim-plug</code>, 我这里采用的是<code>vim-plug</code>.</p><p>neovim下安装命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs \</span><br><span class="line">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>vim下安装命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>要安装插件，你必须如下所示首先在 Vim 配置文件中声明它们。一般 Vim 的配置文件是 <code>~/.vimrc</code>，Neovim 的配置文件是 <code>~/.config/nvim/init.vim</code>。请记住，当你在配置文件中声明插件时，列表应该以 <code>call plug#begin(PLUGIN_DIRECTORY)</code> 开始，并以 <code>plug#end()</code> 结束。</p><p>例如，我们安装 “lightline.vim” 插件。为此，请在 <code>~/.vimrc</code> 的顶部添加以下行。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">call plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;itchyny/lightline.vim&#x27;</span></span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>在 vim 配置文件中添加上面的行后，通过输入以下命令重新加载：<br> <code>:source ~/.vimrc</code><br> 或者，只需重新加载 Vim 编辑器。</p><p> 现在，打开 vim 编辑器：<br> <code>$ vim</code><br> 使用以下命令检查状态：<br> <code>:PlugStatus</code><br> 然后输入下面的命令，然后按回车键安装之前在配置文件中声明的插件。<br> <code>:PlugInstall</code></p><h4 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h4><p>要更新插件，请运行：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:PlugUpdate</span><br></pre></td></tr></table></figure><p>更新插件后，按下 <code>d</code> 查看更改。或者，你可以之后输入 <code>:PlugDiff</code>。</p><h4 id="审查插件"><a href="#审查插件" class="headerlink" title="审查插件"></a>审查插件</h4><p>有时，更新的插件可能有新的 bug 或无法正常工作。要解决这个问题，你可以简单地回滚有问题的插件。输入 <code>:PlugDiff</code> 命令，然后按回车键查看上次 <code>:PlugUpdate</code>的更改，并在每个段落上按 <code>X</code> 将每个插件回滚到更新前的前一个状态。</p><h4 id="删除插件"><a href="#删除插件" class="headerlink" title="删除插件"></a>删除插件</h4><p>删除一个插件删除或注释掉你以前在你的 vim 配置文件中添加的 <code>plug</code> 命令。然后，运行 <code>:source ~/.vimrc</code> 或重启 Vim 编辑器。最后，运行以下命令卸载插件：<br> <code>:PlugClean</code></p><p>该命令将删除 vim 配置文件中所有未声明的插件。</p><h4 id="升级-Vim-plug"><a href="#升级-Vim-plug" class="headerlink" title="升级 Vim-plug"></a>升级 Vim-plug</h4><p>要升级vim-plug本身，请输入：<br> <code>:PlugUpgrade</code></p><p>如你所见，使用 Vim-plug 管理插件并不难。它简化了插件管理。现在去找出你最喜欢的插件并使用 Vim-plug 来安装它们。</p><h1 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h1><blockquote><p>插件这个东西,少即是多,运行速度会更快</p></blockquote><h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><h3 id="安装vim中文手册"><a href="#安装vim中文手册" class="headerlink" title="安装vim中文手册"></a>安装<a href="https://github.com/yianwillis/vimcdoc" target="_blank" rel="noopener external nofollow noreferrer">vim中文手册</a></h3><p><a href="https://github.com/yianwillis/vimcdoc" target="_blank" rel="noopener external nofollow noreferrer">yianwillis/vimcdoc</a></p><p><code>Plug &#39;yianwillis/vimcdoc&#39;</code></p><h3 id="编码优化插件"><a href="#编码优化插件" class="headerlink" title="编码优化插件"></a>编码优化插件</h3><h4 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h4><p>vim要有python支持,如果没有需要输入<code>pip install neovim</code>命令安装neovim的python支持模块.</p><p><code>Plug &#39;Valloric/YouCompleteMe&#39;</code></p><p><strong>上面的插件对C++的支持是很强大的但是在麻烦.后来改用<code>deoplete</code>了</strong></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">&#x27;shougo/unite.vim&#x27;</span>                            <span class="string">&quot; deoplete依赖</span></span><br><span class="line"><span class="string">Plug &#x27;Shougo/deoplete.nvim&#x27;                        &quot;</span> 代码补全</span><br><span class="line">Plug <span class="string">&#x27;jiangmiao/auto-pairs&#x27;</span>                        <span class="string">&quot; 括号自动补全</span></span><br><span class="line"><span class="string">Plug &#x27;tpope/vim-surround&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;scrooloose/syntastic&#x27;                        &quot;</span> 静态代码分析</span><br><span class="line">Plug <span class="string">&#x27;neomake/neomake&#x27;</span>                             <span class="string">&quot; 语法检查</span></span><br><span class="line"><span class="string">Plug &#x27;mg979/vim-visual-multi&#x27;                      &quot;</span> 多光标</span><br></pre></td></tr></table></figure><h3 id="GitHelp"><a href="#GitHelp" class="headerlink" title="GitHelp"></a>GitHelp</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">&#x27;tpope/vim-fugitive&#x27;</span>                          <span class="string">&quot; git plugin</span></span><br><span class="line"><span class="string">Plug &#x27;airblade/vim-gitgutter&#x27;                      &quot;</span></span><br></pre></td></tr></table></figure><h3 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h3><blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">&#x27;shougo/vimfiler.vim&#x27;</span>                         <span class="string">&quot; file explorer 这个项目已经不维护了</span></span><br></pre></td></tr></table></figure></blockquote><p>现在采用<code>shougo/defx.nvim</code>这个插件</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> has(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">  Plug <span class="string">&#x27;Shougo/defx.nvim&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;:UpdateRemotePlugins&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  Plug <span class="string">&#x27;Shougo/defx.nvim&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/nvim-yarp&#x27;</span></span><br><span class="line">  Plug <span class="string">&#x27;roxma/vim-hug-neovim-rpc&#x27;</span></span><br><span class="line">endif</span><br><span class="line"><span class="string">&quot; 这是defx的两个支持插件</span></span><br><span class="line"><span class="string">Plug &#x27;kristijanhusak/defx-git&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;kristijanhusak/defx-icons&#x27;</span></span><br></pre></td></tr></table></figure><p>defx 没有提供默认的键盘映射,所以需要自己进行设置</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; 这是我的配置. 参考文档种的配置做的修改.  还需完善</span></span><br><span class="line"><span class="string">autocmd FileType defx call s:defx_my_settings()</span></span><br><span class="line"><span class="string">function! s:defx_my_settings() abort</span></span><br><span class="line"><span class="string">  setl nonumber</span></span><br><span class="line"><span class="string">  setl norelativenumber</span></span><br><span class="line"><span class="string">  setl listchars=</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &quot;</span> Define mappings</span><br><span class="line">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; &lt;CR&gt;</span><br><span class="line">  \ defx#do_action(<span class="string">&#x27;open&#x27;</span>)</span><br><span class="line">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; c</span><br><span class="line">  \ defx#do_action(<span class="string">&#x27;copy&#x27;</span>)</span><br><span class="line">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; m</span><br><span class="line">  \ defx#do_action(<span class="string">&#x27;move&#x27;</span>)</span><br><span class="line">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; p</span><br><span class="line">  \ defx#do_action(<span class="string">&#x27;paste&#x27;</span>)</span><br><span class="line">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; l</span><br><span class="line">  \ defx#do_action(<span class="string">&#x27;open&#x27;</span>)</span><br><span class="line">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; E</span><br><span class="line">  \ defx#do_action(<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;vsplit&#x27;</span>)</span><br><span class="line">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; P</span><br><span class="line">  \ defx#do_action(<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;pedit&#x27;</span>)</span><br><span class="line"><span class="string">&quot;  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; l</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;open_or_close_tree&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; K</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;new_directory&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; N</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;new_file&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; M</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;new_multiple_files&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; C</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;toggle_columns&#x27;,</span></span><br><span class="line"><span class="string">  \                &#x27;mark:filename:type:size:time&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; S</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;toggle_sort&#x27;, &#x27;time&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; d</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;remove&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; r</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;rename&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; !</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;execute_command&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; x</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;execute_system&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; yy</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;yank_path&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; .</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;toggle_ignored_files&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; ;</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;repeat&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; h</span></span><br><span class="line"><span class="string">  \ defx#is_opened_tree() ? defx#do_action(&#x27;close_tree&#x27;) :defx#do_action(&#x27;cd&#x27;, [&#x27;..&#x27;])</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; ~</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;cd&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; q</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;quit&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; &lt;Space&gt;</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;toggle_select&#x27;) . &#x27;j&#x27;</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; *</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;toggle_select_all&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; j</span></span><br><span class="line"><span class="string">  \ line(&#x27;.&#x27;) == line(&#x27;$&#x27;) ? &#x27;gg&#x27; : &#x27;j&#x27;</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; k</span></span><br><span class="line"><span class="string">  \ line(&#x27;.&#x27;) == 1 ? &#x27;G&#x27; : &#x27;k&#x27;</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; &lt;C-l&gt;</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;redraw&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; &lt;C-g&gt;</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;print&#x27;)</span></span><br><span class="line"><span class="string">  nnoremap &lt;silent&gt;&lt;buffer&gt;&lt;expr&gt; cd</span></span><br><span class="line"><span class="string">  \ defx#do_action(&#x27;change_vim_cwd&#x27;)</span></span><br><span class="line"><span class="string">endfunction</span></span><br></pre></td></tr></table></figure><h3 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">&#x27;majutsushi/tagbar&#x27;</span>                           <span class="string">&quot;浏览tag</span></span><br></pre></td></tr></table></figure><h2 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a><strong>美化篇</strong></h2><h3 id="安装开始界面插件"><a href="#安装开始界面插件" class="headerlink" title="安装开始界面插件"></a>安装开始界面插件</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">&#x27;mhinz/vim-startify&#x27;</span>                              <span class="string">&quot;start page</span></span><br></pre></td></tr></table></figure><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p><code>Plug &#39;icymind/NeoSolarized&#39;                 &quot;主题    </code></p><h3 id="安装状态栏插件"><a href="#安装状态栏插件" class="headerlink" title="安装状态栏插件"></a>安装状态栏插件</h3><p>状态栏能显示当前的状态，还是有不少用处的，好看的状态栏就是为了美观，毕竟谁也不喜欢对着个难看的东西吧。<br> 　　这里使用的是 <a href="https://link.jianshu.com/?t=https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener external nofollow noreferrer">airline </a>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline&#x27;</span>                     <span class="string">&quot;状态栏工具</span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline-themes&#x27;              &quot;</span>状态栏主题</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; Airline config</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:airline_powerline_fonts = 0</span></span><br><span class="line"><span class="string">let g:airline_theme = &#x27;bubblegum&#x27;</span></span><br><span class="line"><span class="string">let g:airline#extensions#whitespace#enabled = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> to use fancy symbols <span class="keyword">for</span> airline, uncomment the following lines and use a</span><br><span class="line"><span class="string">&quot; patched font (more info on the README.rst)</span></span><br><span class="line"><span class="string">if !exists(&#x27;g:airline_symbols&#x27;)</span></span><br><span class="line"><span class="string">   let g:airline_symbols = &#123;&#125;</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string">let g:airline_left_sep = &#x27;⮀&#x27;</span></span><br><span class="line"><span class="string">let g:airline_left_alt_sep = &#x27;⮁&#x27;</span></span><br><span class="line"><span class="string">let g:airline_right_sep = &#x27;⮂&#x27;</span></span><br><span class="line"><span class="string">let g:airline_right_alt_sep = &#x27;⮃&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.branch = &#x27;⭠&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.readonly = &#x27;⭤&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.linenr = &#x27;⭡&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#show_tabs = 1</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#left_sep = &#x27;⮀&#x27;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#left_alt_sep = &#x27;⮁&#x27;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#right_sep = &#x27;⮂&#x27;</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#right_alt_sep = &#x27;⮃&#x27;</span></span><br></pre></td></tr></table></figure><hr><p>这是我自己的neovim配置</p><p><a href="https://github.com/tabris233/config/blob/master/neovim/init.vim" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/tabris233/config/blob/master/neovim/init.vim</a></p>]]></content>
    
    
    <summary type="html">tabris的vim使用心得</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="editor" scheme="http://blog.tabris.top/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>StudyDocker</title>
    <link href="http://blog.tabris.top/StudyDocker/"/>
    <id>http://blog.tabris.top/StudyDocker/</id>
    <published>2019-01-10T17:21:03.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>操作环境: Arch &amp; manjaro</p><p>docker命令行管理工具使用的<code>dockly</code> 但仍然有缺陷,以后再找找 有没有其他更好用的命令行工具.</p><p>教程先看了一遍 <a href="https://www.bilibili.com/video/av27122140" target="_blank" rel="noopener external nofollow noreferrer">B站的尚硅谷教程</a> 有些av号的顺序不对.  看这个就行了.</p><p>tabris&#39;s 阿里云镜像加速器: <a href="https://oj7znbfj.mirror.aliyuncs.com/" target="_blank" rel="noopener external nofollow noreferrer">https://oj7znbfj.mirror.aliyuncs.com</a></p><span id="more"></span><h1 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h1><p>命令安装<code>docker</code>本体</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S docker</span><br></pre></td></tr></table></figure><blockquote><p>同时建议安装<code>dockly</code>作为docker的命令行管理软件.</p><p><a href="https://www.npmjs.com/package/dockly" target="_blank" rel="noopener external nofollow noreferrer">https://www.npmjs.com/package/dockly</a></p></blockquote><p>非root用户运行docker是执行如下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER #your usrname</span><br></pre></td></tr></table></figure><p>执行如下命令启动docker服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是阿里云的镜像加速器: <a href="https://oj7znbfj.mirror.aliyuncs.com/" target="_blank" rel="noopener external nofollow noreferrer">https://oj7znbfj.mirror.aliyuncs.com</a></p><p>新版的 <code>Docker</code> 使用 <code>/etc/docker/daemon.json（Linux）</code> 或者 <code>%programdata%\docker\config\daemon.json（Windows）</code> 来配置 <code>Daemon</code>。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://oj7znbfj.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker 轻量级虚拟化</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="docker" scheme="http://blog.tabris.top/tags/docker/"/>
    
    <category term="Linux" scheme="http://blog.tabris.top/tags/linux/"/>
    
    <category term="虚拟化" scheme="http://blog.tabris.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://blog.tabris.top/DesignPattern/"/>
    <id>http://blog.tabris.top/DesignPattern/</id>
    <published>2018-11-18T21:06:08.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习下设计模式</p><p>参考<a href="http://www.runoob.com/" target="_blank" rel="noopener external nofollow noreferrer">菜鸟教程</a></p><p>但其实菜鸟教程介绍的比较简略,还是要参考下其他</p></blockquote><span id="more"></span><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><blockquote><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p></blockquote><h3 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h3><p><a href="https://blog.csdn.net/silangquan/article/details/20492293" target="_blank" rel="noopener external nofollow noreferrer">C++实现参考 &lt;- 特别赞</a></p><h3 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h3><h3 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h3><h3 id="建造者模式（Builder-Pattern）"><a href="#建造者模式（Builder-Pattern）" class="headerlink" title="建造者模式（Builder Pattern）"></a>建造者模式（Builder Pattern）</h3><h3 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h3><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a><strong>结构型模式</strong></h2><blockquote><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p></blockquote><h3 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h3><h3 id="桥接模式（Bridge-Pattern）"><a href="#桥接模式（Bridge-Pattern）" class="headerlink" title="桥接模式（Bridge Pattern）"></a>桥接模式（Bridge Pattern）</h3><h3 id="过滤器模式（Filter、Criteria-Pattern）"><a href="#过滤器模式（Filter、Criteria-Pattern）" class="headerlink" title="过滤器模式（Filter、Criteria Pattern）"></a>过滤器模式（Filter、Criteria Pattern）</h3><h3 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h3><h3 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h3><h3 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h3><h3 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h3><h3 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h3><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a><strong>行为型模式</strong></h2><h3 id="责任链模式（Chain-of-Responsibility-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Pattern）"></a>责任链模式（Chain of Responsibility Pattern）</h3><h3 id="命令模式（Command-Pattern）"><a href="#命令模式（Command-Pattern）" class="headerlink" title="命令模式（Command Pattern）"></a>命令模式（Command Pattern）</h3><h3 id="解释器模式（Interpreter-Pattern）"><a href="#解释器模式（Interpreter-Pattern）" class="headerlink" title="解释器模式（Interpreter Pattern）"></a>解释器模式（Interpreter Pattern）</h3><h3 id="迭代器模式（Iterator-Pattern）"><a href="#迭代器模式（Iterator-Pattern）" class="headerlink" title="迭代器模式（Iterator Pattern）"></a>迭代器模式（Iterator Pattern）</h3><h3 id="中介者模式（Mediator-Pattern）"><a href="#中介者模式（Mediator-Pattern）" class="headerlink" title="中介者模式（Mediator Pattern）"></a>中介者模式（Mediator Pattern）</h3><h3 id="备忘录模式（Memento-Pattern）"><a href="#备忘录模式（Memento-Pattern）" class="headerlink" title="备忘录模式（Memento Pattern）"></a>备忘录模式（Memento Pattern）</h3><h3 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h3><h3 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h3><h3 id="空对象模式（Null-Object-Pattern）"><a href="#空对象模式（Null-Object-Pattern）" class="headerlink" title="空对象模式（Null Object Pattern）"></a>空对象模式（Null Object Pattern）</h3><h3 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h3><h3 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h3><h3 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习下设计模式&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.runoob.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但其实菜鸟教程介绍的比较简略,还是要参考下其他&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="软工" scheme="http://blog.tabris.top/categories/%E8%BD%AF%E5%B7%A5/"/>
    
    
    <category term="开发" scheme="http://blog.tabris.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式.</title>
    <link href="http://blog.tabris.top/ProductPattern/"/>
    <id>http://blog.tabris.top/ProductPattern/</id>
    <published>2018-11-18T12:44:08.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener external nofollow noreferrer">http://www.runoob.com/design-pattern/abstract-factory-pattern.html</a></p><span id="more"></span><p>下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。</p><p>比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。</p><p>戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。</p><p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。</p><p>后续直接调用鼠标工厂.生产鼠标()即可</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。</p><p>也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。</p><p>戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。</p><p>创建工厂时，由戴尔工厂创建。</p><p>后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。</p><blockquote><p>在抽象工厂模式中，假设我们需要增加一个工厂</p></blockquote><p>假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。</p><p>之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。</p><blockquote><p>在抽象工厂模式中，假设我们需要增加一个产品</p></blockquote><p>假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。</p><p>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/design-pattern/abstract-factory-pattern.html&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;http://www.runoob.com/design-pattern/abstract-factory-pattern.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="软工" scheme="http://blog.tabris.top/categories/%E8%BD%AF%E5%B7%A5/"/>
    
    
    <category term="面试" scheme="http://blog.tabris.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="设计模式" scheme="http://blog.tabris.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>StudyLinux----arch</title>
    <link href="http://blog.tabris.top/StudyLinux-arch/"/>
    <id>http://blog.tabris.top/StudyLinux-arch/</id>
    <published>2018-09-23T17:21:03.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>manjaro 真好用 arch 再见!</p><p>推荐manjaro-deepin 对中文的支持比较好</p><p>桌面环境真的是个大坑啊</p><p>现在觉得折腾确实挺有趣的, 但以后有机会还是配一个mbp吧, linux的桌面环境是真的烦人..aur和稳定的桌面环境感觉还是后者比较重要.</p><p>争取能做出来一个安装+部署配置的脚本</p></blockquote><span id="more"></span><h1 id="Arch-踩坑笔记"><a href="#Arch-踩坑笔记" class="headerlink" title="Arch 踩坑笔记"></a>Arch 踩坑笔记</h1><blockquote><p>记录一下从0开始玩linux的经历</p><p>其实之前已经有了一点ubuntu的使用经验 但是很浅</p><p>Arch 作为&#39;最难&#39;安装的linux系统  通过它可以更好的了解linux</p><p>这里是VMware安装的Arch虚拟机<br><a href="https://blog.csdn.net/u011054333/article/details/50631599" target="_blank" rel="noopener external nofollow noreferrer">配置和美化Arch Linux</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h2><p>这里参考</p><blockquote><p> <strong>注意引导方式建议使用rEFInd 代替教程里采用的grub</strong></p><p><a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener external nofollow noreferrer">这是最全面的安装指南</a></p></blockquote><p>如果进入不了<code>[root@archiso ]</code> 是物理机安装时 u盘的卷标不是`ARCH_20XXYY</p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置:"></a>基础设置:</h3><h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># useradd -m -G wheel &lt;username&gt; （请自行替换username为你的用户名）</span><br><span class="line"># passwd &lt;username&gt; （请自行替换username为你的用户名）</span><br></pre></td></tr></table></figure><h4 id="开机自动联网"><a href="#开机自动联网" class="headerlink" title="开机自动联网"></a>开机自动联网</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> dhcpcd</span></span><br></pre></td></tr></table></figure><h4 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pacman -Syy net-tools</span></span><br></pre></td></tr></table></figure><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>装完archlinux，因为时区的问题，时间总是比实际快了8个小时，找了各种办法，最终使用了openNTPD的方法</p><p>设置时区：<code>sudo ln sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p><p>安装openNTPD：<code>sudo pacman -S openntpd</code></p><p>重启openNTPD：<code>systemctl restart openntpd</code></p><p>设置开机启动：<code>systemctl enable openntpd</code></p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>安装ssh</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pacman -Syy openssh</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl start sshd</span><br></pre></td></tr></table></figure><p>开机启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl enable sshd.service</span><br></pre></td></tr></table></figure><h4 id="启用中国源"><a href="#启用中国源" class="headerlink" title="启用中国源"></a>启用中国源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -c China</span><br></pre></td></tr></table></figure><h4 id="添加archlinuxcn源"><a href="#添加archlinuxcn源" class="headerlink" title="添加archlinuxcn源"></a>添加archlinuxcn源</h4><p>archlinuxcn源至您的 /etc/pacman.conf</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[archlinuxcn]</span></span><br><span class="line"><span class="comment">#The Chinese Arch Linux communities packages.</span></span><br><span class="line"><span class="attr">SigLevel</span> = Optional TrustAll</span><br><span class="line"><span class="attr">Server</span> = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><h4 id="aur助手"><a href="#aur助手" class="headerlink" title="aur助手"></a>aur助手</h4><p><a href="https://github.com/Jguer/yay" target="_blank" rel="noopener external nofollow noreferrer">yay</a> 是下一个最好的 AUR 助手。它使用 Go 语言写成，宗旨是提供最少化用户输入的 <code>pacman</code> 界面、yaourt 式的搜索，而几乎没有任何依赖软件。</p><p>yay 的特性：</p><ul><li><code>yay</code> 提供 AUR 表格补全，并且从 ABS 或 AUR 下载 PKGBUILD</li><li>支持收窄搜索，并且不需要引用 PKGBUILD 源</li><li><code>yay</code> 的二进制文件除了 <code>pacman</code> 以外别无依赖</li><li>提供先进的包依赖解决方案，以及在编译安装之后移除编译时的依赖</li><li>当在 <code>/etc/pacman.conf</code> 文件配置中启用了色彩时支持色彩输出</li><li><code>yay</code> 可被配置成只支持 AUR 或者 repo 里的软件包</li></ul><p>安装 yay：</p><p><strong>现在yay已经添加到官方源中</strong></p><p><code>sudo pacman -S yay</code></p><h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>electron-ssr : GUI的界面的ssr.很好用</p><h4 id="中文字"><a href="#中文字" class="headerlink" title="中文字"></a>中文字</h4><p><a href="https://wiki.archlinux.org/index.php/Font_Configuration/Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener external nofollow noreferrer">参考ArchWiki</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S ttf-ms-fonts ttf-roboto noto-fonts noto-fonts-cjk adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts ttf-dejavu</span><br></pre></td></tr></table></figure><p>添加配置文件,<code>~/.config/fontconfig/fonts.conf</code> or <code>/etc/fonts/local.conf</code></p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><blockquote><p>linux 强大的命令行操作,使效率倍增,所以配置好命令行,并安装实用命令行软件是必要的</p></blockquote><h4 id="zsh-1"><a href="#zsh-1" class="headerlink" title="zsh^1"></a>zsh<a href="%5B%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83%E4%B9%8BZsh%EF%BC%86oh-my-zsh%5D(https://mtaoist.xyz/2018/03/14/oh-my-zsh/)">^1</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S zsh zsh-completions</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将zsh设为默认shell</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"><span class="meta">#</span><span class="bash">其他发行版可先用chsh -l 查看zsh安装位置</span></span><br></pre></td></tr></table></figure><h5 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h5><ul><li><p>curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。)</p></li><li><p><a href="http://ohmyz.sh/" target="_blank" rel="noopener external nofollow noreferrer">Oh-my-zsh</a>是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。</p></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置文件位置： ~/.zshrc</p></li><li><p>主题<br><code>oh-my-zsh</code>自带大量<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener external nofollow noreferrer">Themes</a>，默认为<code>robbyrussell</code>。你也可以选择<code>random</code>，即每次打开终端随机选一个主题。</p><blockquote><p>ZSH_THEME=”你喜欢的主题名”<br><img src="https://mtaoist.xyz/img/zsh_theme.png" class="lazyload" data-srcset="https://mtaoist.xyz/img/zsh_theme.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="themes"></p></blockquote></li><li><p>常用插件</p><ul><li><p>git: 提供大量git的Aliases，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener external nofollow noreferrer">详情</a></p></li><li><p>archlinux： 提供一些pacman包管理器的Aliases，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#archlinux" target="_blank" rel="noopener external nofollow noreferrer">详情</a></p></li><li><p>z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置</p></li><li><p>sudo：按两次[Esc]自动在前面加sudo</p></li><li><p>pip： 补全pip 命令</p></li><li><p>zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestions</span><br></pre></td></tr></table></figure></li><li><p>zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><blockquote><p>plugins=( 你想启用的插件，空格分隔 )<br><img src="https://mtaoist.xyz/img/zsh_plugins.png" class="lazyload" data-srcset="https://mtaoist.xyz/img/zsh_plugins.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="plugins"></p></blockquote></li><li><p>重新加载配置文件，立刻生效。</p><blockquote><p>source ~/.zshrc</p></blockquote></li></ul></li><li><p>其他插件请参见官方<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview" target="_blank" rel="noopener external nofollow noreferrer">wiki</a></p></li><li><p>少即是多，启用大量插件会严重拖慢zsh启动速度</p></li></ul><hr><p>我这里采用的是<code>agnoster</code>主题<br>为在使用tmux时不重复显示<code>whoami@whereami</code>做两处修改</p><ul><li>在<code>/etc/profile</code>中添加环境变量<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEFAULT_USER=$USER</span><br></pre></td></tr></table></figure></li><li>在<code>agnoster</code>主题文件91行中做如下修改<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot;]]; then</span><br><span class="line">+ if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || (( -n &quot;$SSH_CLIENT&quot; &amp;&amp; -z &quot;$TMUX&quot; )) ]]; then</span><br></pre></td></tr></table></figure>这样在本地初始打开一个terminal时不会显示,ssh远程连接是时显示<br>进入tmux时不会显示</li></ul><p>原因是<br><a href="https://blog.csdn.net/kingolie/article/details/53066679" target="_blank" rel="noopener external nofollow noreferrer">Archlinux下安装和配置zsh</a></p><h4 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h4><p>安装tmux</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S tmux</span><br></pre></td></tr></table></figure><p>在这里配置tmux<br><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/gpakosz/.tmux</a> 这个简单好看,且对true color支持很好, <code>.tmux.conf.local</code>配置文件很方便</p><p><a href="http://lotabout.me/2018/true-color-for-tmux-and-vim/" target="_blank" rel="noopener external nofollow noreferrer">为 vim + tmux 开启真彩色(true color)</a></p><p><a href="https://blog.csdn.net/u014717036/article/details/60139776" target="_blank" rel="noopener external nofollow noreferrer">tmux进阶之tmuxinator</a></p><blockquote><p>  FAQ:</p><ol><li><p>tmux 嵌套使用的话，如何将 tmux 命令发送到嵌套内的会话窗口？<a href="https://blog.csdn.net/henryhu712/article/details/83824487" target="_blank" rel="noopener external nofollow noreferrer">转载自</a></p><p>   很常见的例子是，在本地用 tmux 登陆远程服务器，服务器上又使用了 tmux。问题是，在这种情况下，tmux 指令被外层会话窗口捕获（本地 tmux），根本无法控制服务器上运行的 tmux。例如，想退出服务器上的会话，ctrl + b, d, 结果退出的是本地 tmux 连接, sh*t。</p><p>   介绍一个简单方法：按着 ctrl，点击两次 b 键，这样发出的 tmux 指令就是发送到内层窗口会话！如此简单！</p></li></ol><hr></blockquote><h4 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h4><blockquote><p>neovim属于vim的加强版  功能更加强大</p></blockquote><p>注意的是启动neovim的命令式<code>nvim</code>而不是<code>neovim</code></p><p>同时安装 <a href="https://gitee.com/hustlion-dev/nerd-fonts#option-3-install-script" target="_blank" rel="noopener external nofollow noreferrer">nerd-fonts</a></p><blockquote><p>如果安装spacevim 则不需要手动安装nerd-fonts</p></blockquote><h5 id="spacevim"><a href="#spacevim" class="headerlink" title="spacevim"></a>spacevim</h5><p>一个定制化的vim配置,支持<code>vim,neovim</code></p><p><a href="https://spacevim.org/" target="_blank" rel="noopener external nofollow noreferrer">官网</a></p><blockquote><p>初学的时候可以使用这个省事儿些,但是后面学习使用vim最好采用自己的配置,按需添加插件配置.</p></blockquote><h4 id="Xshell下256-真色支持"><a href="#Xshell下256-真色支持" class="headerlink" title="*Xshell下256/真色支持"></a>*Xshell下256/真色支持</h4><p>检查当前是否为256/真色<a href="https://gaomf.cn/2017/01/16/Terminal_Color/" target="_blank" rel="noopener external nofollow noreferrer">参考本篇文章</a></p><p>我这里的xshell只能支持256色</p><p>这时xshell中只有在tmux下spacevim才能显示256色,不支持真色</p><p>在.zshrc文件头添加</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /$&#123;.zshrc的目录&#125;/.change_term.sh</span><br></pre></td></tr></table></figure><p>.change_term.sh文件内容如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;before: $TERM&quot;</span><br><span class="line">if [ &quot;$TERM&quot; = &quot;linux&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;export TERM=xterm-256color&quot;</span><br><span class="line">  export TERM=xterm-256color</span><br><span class="line">elif [ &quot;$TERM&quot; = &quot;xterm&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;export TERM=tmux-direct&quot;</span><br><span class="line">  export TERM=tmux-direct</span><br><span class="line">elif [ &quot;$TERM&quot; = &quot;xterm-256color&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;export TERM=xterm-direct&quot;</span><br><span class="line">  export TERM=xterm-direct</span><br><span class="line">else</span><br><span class="line">  echo &quot;export TERM=tmux-256color&quot;</span><br><span class="line">  export TERM=tmux-256color</span><br><span class="line">fi</span><br><span class="line">echo &quot;now: $TERM&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是ssh自动启用tmux</span></span><br><span class="line">if [ -n &quot;$SSH_CLIENT&quot; ]</span><br><span class="line">then</span><br><span class="line">  tmux</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">clear</span><br></pre></td></tr></table></figure><p><strong>glances</strong>: 代替htop的资源监控工具</p><p><strong>ranger</strong>: ranger是一个以<a href="https://baike.baidu.com/item/GPL" target="_blank" rel="noopener external nofollow noreferrer">GPL</a>许可证发放源码，默认使用VIM风格键盘绑定、<a href="https://baike.baidu.com/item/curses/1630775" target="_blank" rel="noopener external nofollow noreferrer">curses</a>图形库，基于字符终端的<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/8716754" target="_blank" rel="noopener external nofollow noreferrer">文件管理器</a>，是自由免费软件。</p><p><strong>tig</strong>: git的命令行管理软件</p><p><del><strong>dockly</strong>: docker的命令行管理软件,ranger就可以显示docker容器运行状况,轻量使用就没必要用它了</del></p><p><strong>wtfutil</strong>: 基于 Terminal 的个人 dashboard 实用程序，专为显示不常用的但非常重要的日常数据而设计</p><h3 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h3><h4 id="编辑器-amp-IDE"><a href="#编辑器-amp-IDE" class="headerlink" title="编辑器&amp;IDE"></a>编辑器&amp;IDE</h4><p>JetBrains ToolBox: JB全家桶,管理Clion,IDEA,PyCharm项目</p><p>code::blocks</p><p>vscode:</p><p>Typora: markdown编辑器</p><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p><strong>Yakuake</strong>: 悬挂式命令行,很方便</p><p><strong>termite</strong>:</p><p><strong>alacrity</strong>: 一个GPU渲染的终端工具,感觉现在比较火,但是个人还没怎么用过,不过还是推荐一下</p><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><p><strong>GitKraken</strong>: git的图形化管理软件</p><h4 id="影音"><a href="#影音" class="headerlink" title="影音"></a>影音</h4><p>网易云音乐</p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>google-chrome</p><h4 id="通讯工具"><a href="#通讯工具" class="headerlink" title="通讯工具"></a>通讯工具</h4><p>deepin.com.qq.office： tim</p><p>deepin-wechat： 微信</p><blockquote><p>wine程序字体dpi太小导致视觉观感很难受</p><p>调整DPI字体</p><p>1，先退出deepin-tim或deepin-qq，否则会提示错误。</p><p>2，运行<strong>env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-TIM&quot; winecfg</strong>（如果是修改QQ界面字体大小，就把Deepin-TIM改成Deepin-QQ），然后将屏幕分辨率拖放到合适的大小（一般120就可以了）。</p></blockquote><p><strong>gitter</strong>:</p><p><strong>telegram</strong>:</p><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p><strong>docker</strong></p><p><strong>virtualbox</strong></p><h4 id="helper"><a href="#helper" class="headerlink" title="helper"></a>helper</h4><p><strong>albert</strong>: linux下的启动器</p><h3 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h3><blockquote><p><a href="https://blog.csdn.net/kingolie/article/details/76723448" target="_blank" rel="noopener external nofollow noreferrer">参考</a></p><p>如果安装manjaro 就不需要手动安装这些了</p></blockquote><h4 id="1、安装显卡驱动"><a href="#1、安装显卡驱动" class="headerlink" title="1、安装显卡驱动"></a><strong>1、安装显卡驱动</strong></h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lspci | grep VGA    # 确定显卡型号</span></span><br><span class="line"><span class="comment"># pacman -S &lt;驱动包&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 官方仓库提供的驱动包：</span></span><br><span class="line"><span class="comment"># # +----------------------+--------------------+--------------+</span></span><br><span class="line"><span class="comment"># # |                      |        开源        |     私有     |</span></span><br><span class="line"><span class="comment"># # +----------------------+--------------------+--------------+</span></span><br><span class="line"><span class="comment"># # |         通用         |   xf86-video-vesa  |              |</span></span><br><span class="line"><span class="comment"># # +----------------------+--------------------+--------------+</span></span><br><span class="line"><span class="comment"># # |         Intel        |  xf86-video-intel  |              |</span></span><br><span class="line"><span class="comment"># # +--------+-------------+--------------------+--------------+</span></span><br><span class="line"><span class="comment"># # |        | GeForce 9+  |                    |    nvidia    |</span></span><br><span class="line"><span class="comment"># # +        +-------------+                    +--------------+</span></span><br><span class="line"><span class="comment"># # | nVidia | GeForce 8/9 | xf86-video-nouveau | nvidia-340xx |</span></span><br><span class="line"><span class="comment"># # +        +-------------+                    +--------------+</span></span><br><span class="line"><span class="comment"># # |        | GeForce 6/7 |                    | nvidia-304xx |</span></span><br><span class="line"><span class="comment"># # +--------+-------------+--------------------+--------------+</span></span><br><span class="line"><span class="comment"># # |        AMD/ATI       |   xf86-video-ati   |              |</span></span><br><span class="line"><span class="comment"># # +----------------------+--------------------+--------------+12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><h4 id="2、安装桌面环境"><a href="#2、安装桌面环境" class="headerlink" title="2、安装桌面环境"></a><strong>2、安装桌面环境</strong></h4><p>所有桌面环境都需要依赖xorg。所以先要安装xorg组。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xorg</span><br></pre></td></tr></table></figure><p>输入命令之后首先会询问要安装xorg组下的哪些包，选择全部。然后对于libgl包有个四个不同的实现，选择mesa-libgl。<br>然后再安装xorg-xinit和xterm：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xorg-xinit xterm</span><br></pre></td></tr></table></figure><p>安装完成之后就可以使用startx命令启动xorg的简易界面了。进入成功的话会显示出几个简陋的窗口。然后按Ctrl+D就可以退出了。</p><h4 id="3、安装xfce4桌面"><a href="#3、安装xfce4桌面" class="headerlink" title="3、安装xfce4桌面"></a><strong>3、安装xfce4桌面</strong></h4><p>安装xfce4桌面和附带的软件包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure><h4 id="4、安装LightDM登录管理器-显示管理器"><a href="#4、安装LightDM登录管理器-显示管理器" class="headerlink" title="4、安装LightDM登录管理器(显示管理器)"></a><strong>4、安装LightDM登录管理器(显示管理器)</strong></h4><p>详细安装和配置看arch-wiki-lighdm<br>我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm<br>安装：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">pacman -S lightdm lightdm-gtk-greeter</span><br></pre></td></tr></table></figure><p>其配置文件为：<br>/etc/lightdm/lightdm.conf<br>安装好之后测试启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start lightdm.service1</span><br></pre></td></tr></table></figure><p>如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动<br>点击画面上的关机小图标，弹出关机对话，选择注销!<br>注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息<br>一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable lightdm.service</span><br></pre></td></tr></table></figure><p>之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续</p><p>进入xfce4图形界面的命令为<code>startxfce4</code></p><h4 id="桌面美化"><a href="#桌面美化" class="headerlink" title="桌面美化"></a>桌面美化</h4><p>好好干活,美化个屁.</p>]]></content>
    
    
    <summary type="html">Arch 作为&#39;最难&#39;安装的linux系统  通过它可以更好的了解linux</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="Linux" scheme="http://blog.tabris.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>GraduationProject</title>
    <link href="http://blog.tabris.top/GraduationProject/"/>
    <id>http://blog.tabris.top/GraduationProject/</id>
    <published>2018-09-23T15:33:11.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在这里记录一下我的毕业设计<br>链接在<a href="https://github.com/tabris233/GraduationProject" target="_blank" rel="noopener external nofollow noreferrer">GitHub</a>上</p></blockquote><p>md 写个p 面向cv编程就完了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在这里记录一下我的毕业设计&lt;br&gt;链接在&lt;a href=&quot;https://github.com/tabris233/GraduationProject&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow</summary>
      
    
    
    
    <category term="项目" scheme="http://blog.tabris.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="毕业设计" scheme="http://blog.tabris.top/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式手册</title>
    <link href="http://blog.tabris.top/ManualOfRegex/"/>
    <id>http://blog.tabris.top/ManualOfRegex/</id>
    <published>2018-03-17T16:15:41.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h1><p>由于hexo的markdown的引擎太烂了  这里的格式会乱点<br>有时间在换一个好一点的引擎   太乱了!!<br>移步这里<a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener external nofollow noreferrer">格式好看的正则表达式手册</a></p><span id="more"></span><table><thead><tr><th align="center">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">\</td><td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\n</code>”匹配一个换行符。串行“<code>\</code>”匹配“<code>\</code>”而“<code>(</code>”则匹配“<code>(</code>”。</td></tr><tr><td align="center">^</td><td align="left">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\n</code>”或“<code>\r</code>”之后的位置。</td></tr><tr><td align="center">$</td><td align="left">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\n</code>”或“<code>\r</code>”之前的位置。</td></tr><tr><td align="center"></td><td align="left">匹配前面的子表达式零次或多次。例如，zo能匹配“<code>z</code>”以及“<code>zoo</code>”。<em>等价于{0,}。</em></td></tr><tr><td align="center">+</td><td align="left">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td></tr><tr><td align="center">?</td><td align="left">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td></tr><tr><td align="center">{n}</td><td align="left">n是一个非负整数。匹配确定的n次。例如，“<code>o&#123;2&#125;</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td></tr><tr><td align="center">{n,}</td><td align="left">n是一个非负整数。至少匹配n次。例如，“<code>o&#123;2,&#125;</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o&#123;1,&#125;</code>”等价于“<code>o+</code>”。“<code>o&#123;0,&#125;</code>”则等价于“<code>o</code>”。</td></tr><tr><td align="center">{n,m}</td><td align="left">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“<code>o&#123;1,3&#125;</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o&#123;0,1&#125;</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="center">?</td><td align="left">当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td></tr><tr><td align="center">.</td><td align="left">匹配除“<code>\``n</code>”之外的任何单个字符。要匹配包括“<code>\``n</code>”在内的任何字符，请使用像“`(.</td></tr><tr><td align="center">(pattern)</td><td align="left">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>(</code>”或“<code>)</code>”。</td></tr><tr><td align="center">(?:pattern)</td><td align="left">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td></tr><tr><td align="center">(?=pattern)</td><td align="left">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td></tr><tr><td align="center">(?!pattern)</td><td align="left">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td></tr><tr><td align="center">(?&lt;=pattern)</td><td align="left">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td></tr><tr><td align="center">(?&lt;!pattern)</td><td align="left">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td></tr><tr><td align="center">x|y</td><td align="left">匹配x或y。例如，“`z</td></tr><tr><td align="center">[xyz]</td><td align="left">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td></tr><tr><td align="center">[^xyz]</td><td align="left">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td></tr><tr><td align="center">[a-z]</td><td align="left">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td></tr><tr><td align="center">[^a-z]</td><td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td></tr><tr><td align="center">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td></tr><tr><td align="center">\B</td><td align="left">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td></tr><tr><td align="center">\cx</td><td align="left">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td></tr><tr><td align="center">\d</td><td align="left">匹配一个数字字符。等价于[0-9]。</td></tr><tr><td align="center">\D</td><td align="left">匹配一个非数字字符。等价于[^0-9]。</td></tr><tr><td align="center">\f</td><td align="left">匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td align="center">\n</td><td align="left">匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td align="center">\r</td><td align="left">匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td align="center">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td align="center">\S</td><td align="left">匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td align="center">\t</td><td align="left">匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td align="center">\v</td><td align="left">匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td align="center">\w</td><td align="left">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9*]*</code>”。</td></tr><tr><td align="center">\W</td><td align="left">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9]</code>”。</td></tr><tr><td align="center">\xn</td><td align="left">匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td></tr><tr><td align="center">\num</td><td align="left">匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td></tr><tr><td align="center">\n</td><td align="left">标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td></tr><tr><td align="center">\nm</td><td align="left">标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</td></tr><tr><td align="center">\nml</td><td align="left">如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td></tr><tr><td align="center">\un</td><td align="left">匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td></tr></tbody></table><h1 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>用户名</td><td><code>/^[a-z0-9*-]&#123;3,16&#125;$/</code></td></tr><tr><td>密码</td><td><code>/^[a-z0-9-]&#123;6,18&#125;$/</code></td></tr><tr><td>十六进制值</td><td><code>/^#?([a-f0-9]&#123;6&#125;\&amp;#124;[a-f0-9]&#123;3&#125;)$/</code></td></tr><tr><td>电子邮箱</td><td><code>/^([a-z0-9*.-]+)@([\da-z.-]+).([a-z.]&#123;2,6&#125;)$/</code> <code>/^[a-z\d]+(.[a-z\d]+)@(\da-z?)+(.&#123;1,2&#125;[a-z]+)+$/</code>*`</td></tr><tr><td>URL</td><td><code>/^(https?:\/\/)?([\da-z.-]+).([a-z.]&#123;2,6&#125;)([\/\w .-])*\/?$/</code>*`</td></tr><tr><td>IP 地址</td><td><code>/((2[0-4]\d|25[0-5]|[01]?\d\d?).)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)/</code> <code>/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</code></td></tr><tr><td>HTML 标签</td><td><code>/^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$/</code></td></tr><tr><td>删除代码\注释</td><td><code>(?&lt;!http:|\S)//.$</code></td></tr><tr><td>Unicode编码中的汉字范围</td><td><code>/^[\u2E80-\u9FFF]+$/</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;表达式全集&quot;&gt;&lt;a href=&quot;#表达式全集&quot; class=&quot;headerlink&quot; title=&quot;表达式全集&quot;&gt;&lt;/a&gt;表达式全集&lt;/h1&gt;&lt;p&gt;由于hexo的markdown的引擎太烂了  这里的格式会乱点&lt;br&gt;有时间在换一个好一点的引擎   太乱了!!&lt;br&gt;移步这里&lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jquery/regexp.html&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;格式好看的正则表达式手册&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="实用技能" scheme="http://blog.tabris.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="正则表达式" scheme="http://blog.tabris.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记</title>
    <link href="http://blog.tabris.top/NotesOfPython/"/>
    <id>http://blog.tabris.top/NotesOfPython/</id>
    <published>2018-03-07T20:12:11.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>抄写了两个Spider,发现对于Python基础的掌握实在是差劲的可以.</p><p>于是乎 过来补补基础</p><p>一直在<a href="https://www.hackerrank.com/" target="_blank" rel="noopener external nofollow noreferrer">Hackerrank</a>上面做Python的题目.知识点覆盖挺全面的,推荐一波.</p><span id="more"></span><h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="乱七八糟小技巧"><a href="#乱七八糟小技巧" class="headerlink" title="乱七八糟小技巧"></a>乱七八糟小技巧</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n,m,*l = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(n,m,l)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> []</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id=""><a href="#" class="headerlink" title="."></a>.</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：<br>去重，把一个列表变成集合，就自动去重了<br>关系测试，测试两组数据之前的交集、差集、并集等关系</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list_1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="comment">#去重</span></span><br><span class="line">list_1 = <span class="built_in">set</span>(list_1)</span><br><span class="line"></span><br><span class="line">list_2 = <span class="built_in">set</span>([<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">66</span>,<span class="number">22</span>,<span class="number">8</span>,<span class="number">4</span>])</span><br><span class="line">list_3 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>])</span><br><span class="line">print(list_1)</span><br><span class="line">print(list_2)</span><br><span class="line">print(list_3)</span><br><span class="line">print(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#关系测试</span></span><br><span class="line"><span class="comment">#交集(两个列表里面都有的值，这里是4、6)：</span></span><br><span class="line">print(list_1.intersection(list_2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#并集（把两个列别合并起来，然后去重）：</span></span><br><span class="line">print(list_1.union(list_2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#差集（把list_1里面有的而list_2里面没有的取出来）：</span></span><br><span class="line">print(list_1.difference(list_2))</span><br><span class="line"><span class="comment">#对称差集（两个列表里面，互相没有的取出来，也就是只去掉那些互相都有的值）</span></span><br><span class="line">print(list_1.symmetric_difference(list_2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#子集（判断list_1是否包含了list_3里面的所有值）</span></span><br><span class="line">print(list_3.issubset(list_1))</span><br><span class="line"><span class="comment">#父集（判断list_1是否为list_3的父集）</span></span><br><span class="line">print(list_1.issuperset(list_3))</span><br><span class="line"></span><br><span class="line"><span class="comment">#无交集（判断list_3和list_4是否完全没有任何交集）</span></span><br><span class="line">list_4 = <span class="built_in">set</span>([<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>])</span><br><span class="line">print(list_3.isdisjoint(list_4))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------关系测试的另一种写法：</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>([<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>])      <span class="comment">#创建一个数值集合</span></span><br><span class="line">t = <span class="built_in">set</span>(<span class="string">&quot;Hello&quot;</span>)         <span class="comment">#创建一个唯一字符的集合</span></span><br><span class="line"></span><br><span class="line">a = t | s          <span class="comment"># t 和 s的并集</span></span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集</span></span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）</span></span><br><span class="line">d = t ^ s          <span class="comment"># 对称差集（项在t或s中，但不会同时出现在二者中）</span></span><br><span class="line"></span><br><span class="line">基本操作：</span><br><span class="line">t.add(<span class="string">&#x27;x&#x27;</span>)            <span class="comment"># 添加一项</span></span><br><span class="line">s.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])  <span class="comment"># 在s中添加多项</span></span><br><span class="line"></span><br><span class="line">使用remove()可以删除一项：</span><br><span class="line"></span><br><span class="line">t.remove(<span class="string">&#x27;H&#x27;</span>)   <span class="comment">#有就删除，没有就报错</span></span><br><span class="line">t.pop() <span class="comment">#随机弹出一个</span></span><br><span class="line">t.discard(<span class="string">&#x27;H&#x27;</span>)  <span class="comment">#有就删除，没有也不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line"><span class="built_in">set</span> 的长度</span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> s</span><br><span class="line">测试 x 是否是 s 的成员</span><br><span class="line"></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s</span><br><span class="line">测试 x 是否不是 s 的成员</span><br><span class="line"></span><br><span class="line">s.issubset(t)</span><br><span class="line">s &lt;= t</span><br><span class="line">测试是否 s 中的每一个元素都在 t 中</span><br><span class="line"></span><br><span class="line">s.issuperset(t)</span><br><span class="line">s &gt;= t</span><br><span class="line">测试是否 t 中的每一个元素都在 s 中</span><br><span class="line"></span><br><span class="line">s.union(t)</span><br><span class="line">s | t</span><br><span class="line">返回一个新的 <span class="built_in">set</span> 包含 s 和 t 中的每一个元素</span><br><span class="line"></span><br><span class="line">s.intersection(t)</span><br><span class="line">s &amp; t</span><br><span class="line">返回一个新的 <span class="built_in">set</span> 包含 s 和 t 中的公共元素</span><br><span class="line"></span><br><span class="line">s.difference(t)</span><br><span class="line">s - t</span><br><span class="line">返回一个新的 <span class="built_in">set</span> 包含 s 中有但是 t 中没有的元素</span><br><span class="line"></span><br><span class="line">s.symmetric_difference(t)</span><br><span class="line">s ^ t</span><br><span class="line">返回一个新的 <span class="built_in">set</span> 包含 s 和 t 中不重复的元素</span><br><span class="line"></span><br><span class="line">s.copy()</span><br><span class="line">返回 <span class="built_in">set</span> “s”的一个浅复制</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h3><h4 id="对字符定义优先级"><a href="#对字符定义优先级" class="headerlink" title="对字符定义优先级"></a>对字符定义优先级</h4><p>将需要排序的字符集放到一个字符串中<br>在这个字符串中越靠前的字符排序后越靠前</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">order = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1357902468&#x27;</span></span><br><span class="line">print(*<span class="built_in">sorted</span>(<span class="built_in">input</span>(), key=order.index), sep=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="关键字排序"><a href="#关键字排序" class="headerlink" title="关键字排序"></a>关键字排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N, M = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())    <span class="comment"># Ｎ行 Ｍ列</span></span><br><span class="line">rows = [<span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]  <span class="comment"># 一行 为一组数据</span></span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="comment"># 以第几为关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">sorted</span>(rows, key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x.split()[K])):<span class="comment"># lambda 匿名函数</span></span><br><span class="line">    print(row)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="-2"><a href="#-2" class="headerlink" title="."></a>.</h3><h4 id="26字母"><a href="#26字母" class="headerlink" title="26字母"></a>26字母</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">alpha = string.ascii_lowercase</span><br></pre></td></tr></table></figure><h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;　s = <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line">&gt;&gt;&gt;　print(s[::-<span class="number">1</span>])</span><br><span class="line">edcba</span><br></pre></td></tr></table></figure><h4 id="字符串格式化输出"><a href="#字符串格式化输出" class="headerlink" title="字符串格式化输出"></a>字符串格式化输出</h4><p>个人喜欢最新的<code>&#39;&#123;&#125;&#39;.format()</code>的形式,不仅写起来更方便一些,还有旧方法不能实现的操作.感觉以后可能完全取缔旧的方法.</p><p><a href="https://pyformat.info/" target="_blank" rel="noopener external nofollow noreferrer">.format的介绍(与旧方法的对比)</a></p><p>输出一行 &#39;-&#39;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;:-&#123;align&#125;&#123;width&#125; &#125;&#x27;</span>.<span class="built_in">format</span>( <span class="string">&#x27;&#x27;</span>,align=<span class="string">&#x27;&gt;&#x27;</span>, width = <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----</span><br></pre></td></tr></table></figure><h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数(function)"></a>函数(function)</h2><p>可更改(mutable)与不可更改(immutable)对象<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li>不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li><li>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li>不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li><li>可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h3 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h3><h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>eval(string) 对于一个字符串，相当与<strong>运行</strong>这个字符串所代表的python代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;x+1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">eval</span>(<span class="string">&#x27;x+1&#x27;</span>))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="各种库"><a href="#各种库" class="headerlink" title="各种库"></a>各种库</h1><p>导入库</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 库 <span class="comment">#使用时需要 `库.函数()`</span></span><br><span class="line"><span class="keyword">from</span> 库 <span class="keyword">import</span> 函数 <span class="comment"># 使用时直接 `函数()` 即可</span></span><br></pre></td></tr></table></figure><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br></pre></td></tr></table></figure><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>计数用的函数</p><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>可以简单理解为一个<strong>map</strong>,</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = defaultdict([Type of value])</span><br><span class="line">------</span><br><span class="line">a[<span class="string">&#x27;key&#x27;</span>] <span class="built_in">type</span> <span class="keyword">is</span> [Type of value]</span><br></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.appendleft(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.extend(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.extendleft(<span class="string">&#x27;234&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop()</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popleft()</span><br><span class="line"><span class="string">&#x27;4&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.extend(<span class="string">&#x27;7896&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;6&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.remove(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;6&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;3&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d</span><br><span class="line">deque([<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;9&#x27;</span>])</span><br></pre></td></tr></table></figure><h1 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h1><h2 id="-4"><a href="#-4" class="headerlink" title="."></a>.</h2><h3 id="-5"><a href="#-5" class="headerlink" title="."></a>.</h3><h4 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">getattr(object, name[, default]) -&gt; value</span></span><br><span class="line"><span class="string">其中 name 可以是字符串.</span></span><br><span class="line"><span class="string">这样的话 相当于 name可以用字符串代替 就不用一大堆`if elif else`了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">getattr(object, name[, default]) -&gt; value</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="built_in">object</span>.name(value)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;抄写了两个Spider,发现对于Python基础的掌握实在是差劲的可以.&lt;/p&gt;
&lt;p&gt;于是乎 过来补补基础&lt;/p&gt;
&lt;p&gt;一直在&lt;a href=&quot;https://www.hackerrank.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;Hackerrank&lt;/a&gt;上面做Python的题目.知识点覆盖挺全面的,推荐一波.&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://blog.tabris.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="http://blog.tabris.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>面试经历.</title>
    <link href="http://blog.tabris.top/ExperienceOfInterview/"/>
    <id>http://blog.tabris.top/ExperienceOfInterview/</id>
    <published>2018-01-31T15:56:08.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结下所有的面试, 这样才能<strong>慢慢</strong>进步呀,,,,</p></blockquote><span id="more"></span><h2 id="哈尔滨某小公司-C-岗实习-现场面-offer"><a href="#哈尔滨某小公司-C-岗实习-现场面-offer" class="headerlink" title="哈尔滨某小公司 - C++岗实习 [现场面] - offer"></a>哈尔滨某小公司 - C++岗实习 [现场面] - offer</h2><p>除了问一个多态,没有技术问题,大概是给答上了 意思对,但不专业</p><hr><p>小公司估计是真的没人了,,,,待遇实在...拒绝</p><h2 id="头条-后台开发实习生-视频面试-一面-跪"><a href="#头条-后台开发实习生-视频面试-一面-跪" class="headerlink" title="头条 - 后台开发实习生 [视频面试] 一面 - 跪"></a>头条 - 后台开发实习生 [视频面试] 一面 - 跪</h2><p>可能是紧张吧,开始闲聊然后给了个编程题<br>给一个化学表达式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg: HMg_&#123;_2&#125;(H_2O(N_3Ag)_2)_3N_2</span><br></pre></td></tr></table></figure><p>,让算每个元素有多少个.</p><p>这种题本就不难 问题就是怎么处理括号<br>之前在hiho上还遇到过类似的问题<a href="http://www.hihocoder.com/contest/offers41/problem/2" target="_blank" rel="noopener external nofollow noreferrer">http://www.hihocoder.com/contest/offers41/problem/2</a></p><p>然后不知道紧张还是什么的就写的很乱,然后面试官提示递归,然后墨迹了好久才用stack写了下来.....</p><p>因为我没有项目,就没有问项目.<br>然后问我们学了数据库,操作系统,网络没有,,,,   嗯 学校确实讲过,但我没听过课...</p><p>问了个进程调度,</p><p>我就知道有个算法叫FIFO, 具体是啥还忘了, 然后说错了,,GG</p><p>然后唠了两句面试官说结束,等HR通知,,,  嗯.感谢面试官浪费40+分钟陪我 hhhh.</p><hr><p>总结:<br>有点紧张. 代码能力差 ,<strong>[数据库,操作系统,网络]</strong> 知识严重匮乏.</p><p>之前看面经说,遇到不会的或者把不准的都应该说<strong>不会</strong>. 下次注意.</p><h2 id="达内-NOIP助教-现场面"><a href="#达内-NOIP助教-现场面" class="headerlink" title="达内 - NOIP助教 现场面"></a>达内 - NOIP助教 现场面</h2><p>达内这个大家都懂.</p><p>突然有天接到达内一个经理的电话,问我能不能去当助教,去教小朋友普及组的NOIP.<br>我心想,这也还不错呀.<br>然后去了,开始跟我吹了1个小时的牛逼,达内多么多么牛逼.怎么怎么地.<br>然后给了我一份NOIP普及组的题让我做..</p><p>说来惭愧,中文题面,我竟读错一道题卡了好久,,,然后花了1个多小时终于把4个题做出来了,最后一题还做得很麻烦...<br>然后来了一个小伙子,谈了谈对NOIP的认识,以及我的学习情况.<br>交上去给了一个小姐姐,然后看见三个人对着电脑看了半天..</p><p>然后说一定要一年,但我最多只能半年,于是据.</p><hr><p>体验美滋滋,没有麻烦的题目,没有操作系统,没有计算机网络,没有数据库.真棒 hhh</p><h2 id="深信服-C-C-电话面试-一面-估计跪了"><a href="#深信服-C-C-电话面试-一面-估计跪了" class="headerlink" title="深信服 - C/C++ 电话面试 一面-估计跪了"></a>深信服 - C/C++ 电话面试 一面-估计跪了</h2><p>深圳打来的电话, 不知道哪里人, 浓重的方言口音, 他说话我都要问好多遍才能听懂...交流真滴有障碍...</p><p>一共22分钟,三个问题</p><p>1 . 两个字符串,一个大串,一个小串,问小串是不是大串的子串(不连续)的.</p><p>我回答了: 遍历大串,然后对小串维护一个遍历的指针就行了</p><p>然后他说不是他想要的,问的是正则?</p><p>我记得有正则查询可以模糊匹配,只要在两个相邻的字母中插进去就好了,,但我忘记了具体插什么,</p><p>结束后一查知道是 <code>.*</code> [. 匹配任意非\n的字符 *是0个或多个]</p><p>2 . 给一个100万的字符串,然后找到最短的循环覆盖的子串.</p><p>我开始以为是ABCABC这样的 最短就是ABC了 ,拿next数组直接做就行了,</p><p>然后说了半天,最后知道,他说的可以是这样ABCABCAB,还可以是ABC</p><p>想了想发现和之前的一样, 还是求next数组,然后就可以把结尾的AB给去掉了,然后就和之前一样了.</p><p>然后不知怎么就陷入了一阵交流障碍,我不知道他说的啥,他不知道我说的啥.</p><p>然后我发现他是想让我说一下next怎么求...</p><p>想了想,不能画图 怎么说呀, 问写代码行吗, 额 他也看不见....</p><p>然后勉强解释了下 维护两个指针,一个i遍历大串,j是维护匹配到的位置,balabala的,</p><p>也不知道他明白没有...</p><hr><p>然后他问我用linux还是windows多,</p><p>我说用过linux,但还是windows多.</p><p>然后问我一个问题,我听成了python.. 我说我会python.....但他好像问的根本不是这个问题,,,</p><hr><p>3 . 最后问我进程的内存分布</p><p>我不会呀..</p><p>说了一个堆栈..就说不知道了,</p><p>于是结束...</p><p>目测GG</p><hr><p>总结: 说好的12点,结果15点电话过来了,,,措手不及,以为没我事儿了呢,</p><p>交流障碍导致前面两个问题说的不太好,而且电话面试真的不如视频面试呀,更别说现场面试了,,,后面确实不会, 操作系统,网络,数据库 多看看呀..</p><h2 id="阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了"><a href="#阿里云-分布式-大数据-基础平台研发工程师实习-电话面试-一面-跪了" class="headerlink" title="阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了"></a>阿里云, 分布式,大数据   - 基础平台研发工程师实习 电话面试 一面-跪了</h2><p>redis和MongoDB的区别。 谈一谈这两个数据库 。   (他以为我是自己搭建的数据库，，但我就是安装然后用的呀)<br>说一下大数据: hadoop - HDFS，hive 和 MapReduce ，问哪个是存储的，脑抽说了个hive，，， 后来改正了，然后问HDFS里面都有什么，答NameNode 和 DataNode，<br>问我还有什么，我不知道，他告诉我还有sdk。</p><p>然后让我说竞赛中做过的经典，印象深刻的题目，想了好久，随便说了一个题，题目不怎么难，其实说的很模糊，而且说的时候还把那个题给弱化了，，记不太清那个题目了，</p><p>然后问了我一个问题，现在都没想明白，说HDFS传3个副本，然后又客户在另一端访问这个。 然后是传完这<strong>三</strong>个副本告诉客户传完了有一个延迟时间，这<strong>两</strong>个副本告诉客户传完了有一个延迟时间，，<br>两个的会比三个的地低，<br>然后给初问题，给一个T，求N，M。 T是客户允许的最长延迟时间，N是副本总数，M是传完M个告诉客户传完了。<br>我只知道可以通过传好多次 算一个副本的时间t，但是不会算大T， 跟概率，期望，有关</p><p>最后让写了一个编程题，很简单的n个区间 问覆盖的长度总和是多少。 谈了50多分种 脑子有点蒙，写了好几分钟。。 但他看了好长时间，难道是我写的错啦？？。。</p><p>然后问了面试官几个问题，<br>大数据如何高效学习，论文，跟进<br>分布式如何学习，</p><p>他们这个是做底层的，，，</p><p>然后就是如果通过了 下次面试是什么时候，，，，但估计没有下次了，，，，，</p><hr><p>虽然啥都不会，什么都没有答上来。 体验非常好的一次面试，面试官人特别好，面对我这样的垃圾面试人员，应该很无奈，但依然很耐心的面试我，最后还提了好多问题。</p><p>但是很奇怪，这次竟然一点操作系统和数据结构的问题都没有问， 之前看到牛客网一个基础平台研发，问了这些问题的呀。</p><h2 id="瓜子二手车-后台研发实习生-现场一二面-给了offer邀请"><a href="#瓜子二手车-后台研发实习生-现场一二面-给了offer邀请" class="headerlink" title="瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请."></a>瓜子二手车 后台研发实习生 现场一二面, 给了offer邀请.</h2><ul><li><p>1面<br>  自我介绍,没准备,随便说了下<br>  唠了两句家常.</p><p>  绳子不均匀,燃烧的问题,一根绳子1个小时烧完.<br>  怎么找30分钟,75分钟.</p><p>  说下栈和队列<br>  双栈怎么实现队列</p><p>  计算机网络的几个零碎的小问题,没记住.</p><p>  然后写了两个代码题</p><ul><li>交叉的链表,找交叉的位置,<br>链表的代码思路对,但是head节点没有val这点被我忘记了</li><li>单链表找倒数第k个节点,</li></ul><p>  数据库索引怎么实现的 -&gt; b+树<br>  b+树为什么会快 -&gt; 搜索树,有剪枝<br>  非**和**的区别 -&gt; 不知道,没听说过 (告诉我是 index 和 index+data的区别,名字想不起来了)<br>  数据库事务的四个特性ACID -&gt; 我分不清那个是哪个了,就举个例子说了,<br>  还有两个数据库的问题,想不起来了,</p><p>  问问题,问了技术栈和分布式的东西.</p></li><li><p>2面<br>  领我进去的小哥哥说是总监面</p><p>  自我介绍.唠家常.</p><p>  两个集合求交,写代码 谢了归并排序+二分, 然后过了会说了个更简单的方法,</p><p>  几个小问题,没记住</p><p>  给我写了几个词,让我谈一谈</p><ul><li>set,stack,链表,数组,map,hash</li><li>tcp,udp,http,https,ftp</li></ul><p>  聊了聊最近在学习什么.说我基础薄弱..</p><p>  问问题. 问了职业规划.答:选择做技术就一直做技术.</p></li></ul><hr><p>可能因为是小公司吧,问的问题都比较简单.算法为了体现水平,学习了网上的套路,先给出一个不是很好的做法,然后再给一个优秀的做法.[斜眼笑]<br>走的时候小哥哥看了看评价表和我说不错,应该很稳,让我回去等消息就行啦.<br>面试官都很随和,出去的时候和一个工大研一的同来面试的小哥哥聊天才知道那个总监挺牛逼的.</p><h2 id="今日头条-后端研发实习生-12面-GG"><a href="#今日头条-后端研发实习生-12面-GG" class="headerlink" title="今日头条 后端研发实习生  - 12面 [GG]"></a>今日头条 后端研发实习生  - 12面 [GG]</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面直接给了一个问题,<br>S_0 = {1}<br>S_0 = {1,2,1}<br>...<br>S_n = S_{n-1},n+1,S_{n-1}</p><p>问: 1. |S_n|  开始嘴飘,想当然的就说了,,后来说对了 2^{n+1}-1<br>            然后让我证明,,, 不会证,,,</p><pre><code>2. 让实现一个函数int get_value(int n,int i) ,S_n的第i个元素,从0开始,,,,    然后我写了一个从1开始的,就被嘲讽了,,,然后一个变量打错,被指漏洞百出...    准备说的最优解还没有开始,就不理我了, (第i个数就是0~2^&#123;n+1&#125;-1的第i个数二进制小的最后一个一的长度,或者理解为lowbit(i)的二进制长度)</code></pre><p>然后有趣,hr给我打电话,委婉的告诉我挂了,,然后突然来了二面,,,,,</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>好吧,二面,啥都不会呀 ...</p><p>开始看了我一面写的代码,说风格太老了,,,现在C11已经不这么写了,,</p><p>然后问我平时用的数据结构是stl的还是C11的,,讲道理我只知道STL的,不知道c11有什么数据结构,难道是传说中的那个能重写pushup,pushdown的内个??</p><p>谈了谈我用到的那些数据结构,说我只用过基础的数据结构,,<br>然后让说了一下vector的实现,我就说了一下仅了解的它为什么能像数组那个用,,</p><p>然后问一堆c11的问题,动态指针什么的,不会</p><p>其中夹杂着问</p><p>问会计组么,,tm不会呀,说你问吧,我试试<br>问了int是反码还是补码,隐隐约约记得是补码,磨磨唧唧说了,</p><p>问socket编程, 不会, 没接触过.<br>问多线程编程, 我说接触过一点点, 只写过多线程循环打印的.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    private int a;</span><br><span class="line">    private int b;</span><br><span class="line">    int test()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">struct Test2&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    char c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sizeof(Test)是多少. 我说12 ,(不知道对错,开始答8然后他沉默就改了, **其实就是8** )</span><br><span class="line">sizeof(Test2)是多少. 我说8 , 因为要内存对齐</span><br></pre></td></tr></table></figure><p>让我写一个函数验证机器的大小端 表示不知道大小端是什么,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 1;</span><br><span class="line">    char s &#x3D; *(char *)&amp;a;</span><br><span class="line">    if(s &#x3D;&#x3D; 1) puts(&quot;small&quot;);</span><br><span class="line">    else       puts(&quot;big&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class 和 struct的区别, 只知道class默认是private,struct默认是public, 问我还有什么 不知道</p><p>问我sizeof(一个指针)是多少,不知道,叨咕了一个8,然后他告诉我32位机器是4,64位机器是8;</p><p>给了一个代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test(int *p)&#123;</span><br><span class="line">    p &#x3D; (int *)malloc(sizeof(int))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问p改没改变</p><p>蒙的改变, p指向了新开辟的那个地址.</p><p>编程题,大数加法,不让用char a[],只让用string... 写的稍墨迹</p><p>然后问string += 和 +的区别</p><p>就是 a+=b 和a=a+b<br>表示没看过string源码,也不了解string咋实现的,类比vector说了一下. 又错了</p><p>问数据库, 我说了解的不是很深入, 然后就没问. (其实以后应该说,试一试,,)</p><p>然后就问问题,唠家常了,,,,</p><p>最后再见,</p><p>结果在一个小时之内,听到了两次同一个hr小姐姐的拒绝电话,,,,</p><hr><p>体验是真几把刺激,面挂了一面还面了第二面,hhhh,于是二面的时候就很懵逼,,,</p><p>但是确实啥都不会呀....</p><p>总结就是多学习吧.</p><p>但是有个大失误,问计网,操作系统,数据库的时候,应该说试一下的,,毕竟还是看了一些的呀,多少还是能答上来一点的,,</p><h2 id="美团-后台开发-搞笑"><a href="#美团-后台开发-搞笑" class="headerlink" title="美团 后台开发 (搞笑)"></a>美团 后台开发 (搞笑)</h2><p>开始自我介绍,聊了聊最近看什么数,还有数据库啥的</p><p>十分钟过后,跟我说只要Java, 不合适, 嗯 ,然后88</p><hr><p>傻逼美团,怎么筛选的简历,岗位要求上不是写的4中语言之一吗,,,,,而且不准备培养实习生的吗,,还听说之前实习生一个转正的都没有??!</p><h2 id="吉比特-游戏开发-实习"><a href="#吉比特-游戏开发-实习" class="headerlink" title="吉比特 游戏开发(实习)"></a>吉比特 游戏开发(实习)</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>自我介绍<br>多线程<br>内联函数和宏函数<br>python闭包<br>socket编程<br>函数内的malloc 存在哪里<br>内联函数<br>右值引用<br>进程间通信<br>连续子序列最大和<br>vector<br>set 和 map的底层数据结构<br>hash冲突解决<br>内存泄漏解决<br>C++调用函数<br>虚析构函数<br>一个文本相同的行去除, 保留第一个 (内存存的下/存不下)<br>还有问题 记不起来了</p><hr><p>表现很差呀, 算法也没有问，代码都没让写，，，</p><h2 id="腾讯-后台开发-实习"><a href="#腾讯-后台开发-实习" class="headerlink" title="腾讯 后台开发(实习)"></a>腾讯 后台开发(实习)</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>自我介绍,</p><p>闲聊<br>介绍了ACM比赛<br>最近在干什么</p><p>技术上的问了<br>网络编程接触过没 -&gt;没接触过<br>数据一致性怎么保证 -&gt; 不会<br>两个文件都是100W个整数,找出相同的 -&gt; 排序,然后归并的过程<br>进程间通信 并举例说出场景 -&gt; 管道不知道,剩下三个举例了,<br>说说STL -&gt; 说了下vector怎么保证可变长度而且复杂度还是O(1),map和set都是红黑树啥啥啥的<br>new/delete 和malloc/free的区别 -&gt; 说没怎么用过后者,一直用前者,因为后者长.面试官笑..然后说了几个new/delete使用的时候需要注意的问题.<br>谈到指针,问多线程删除map元素怎么办 -&gt; 先回答把多个线程要删除的记下来,然后统一删除, 他说可以, 但是希望我在指针的方式考虑, 想了想不会, 他让我回去看下map的源码关于元素删除的部分, 看过之后会有想法.<br>多线程有什么了解 -&gt; 说了下ABC循环打印的那个, 然后就没有了<br>高并发怎么处理, -&gt; 读的不加锁,写的加锁<br>接上个问我脏读怎么办 -&gt; 我说加个时间戳,他说不太好,然后不会了<br>对安全了解多少 -&gt; 把只会的凯撒加密和RSA加密说了说<br>对称加密和非对称加密 -&gt; 忘记了,说不太清了,告诉他不强答<br>C++的封装/继承/多态-&gt; 说了说多态和继承,封装我觉得没啥说的呀,,</p><p>还有几个问题,忘了</p><p>非技术问题<br>说给我安排一个任务,一周上线,这个任务我现在不会,怎么办 -&gt; 我觉得时间够用,没有问题,2天时间学习,3天时间实现, 具体实施的时候先请教别人,翻论文<br>如果我现在时间很紧的赶一个任务,有人请教我会的东西,我怎么做 -&gt; 甩给他相关的资料让他自己学习, 如果还不懂,粗浅的指点一下  还不懂,就对不起了,(这个很坑呀,步步紧逼)</p><p>问问题<br>就问了怎么学习linux,<br>之前准备问的问题,都忘记问了</p><hr><p>面试官挺随和的, 开始挺紧张的 ,后来就不紧张了, 现场面试还是比电面/视频面舒服.<br>过程就像实在闲聊<br>还是什么都不会, 面试官让我把学习重心放在网络编程和安全这方面,说用到的多,学习的时候多看看源码.</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>问的和一面差不多,<br>多问了几个小问题而已</p><p>数据库的东西问了很多, 但不会<br>然后和一面有重复的问题,但是昨天回去查了下,答得比较完整<br>Hash处理冲突,解决办法<br>内存泄露的时候如何定位 -&gt; 说调用系统的函数监控内存<br>内存分布 -&gt; 有一个忘记了,其他的说的没问题<br>进程调度算法 -&gt; 先到先服务 , 短作业优先, 多级反馈队列<br>接上个问现在系统的调度算法 -&gt; 在提示说同时能音乐,处理网页这些 想起来时间片轮转算法,说了些,<br>std::sort()怎么实现的 -&gt; 内省排序,<br>接上个std::sort()什么时候采用插入排序,归并排序,快排 -&gt; 举了什么时候插排会更快, 和归并是为了防止快排退化 balabala</p><p>剩下的暂时想不起来了,</p><hr><p>面试官看起来挺年轻的, 数据库东西确实不太会, 而且又没让写代码, 以为凉凉了,,,<br>5点多接到明天hr面的消息,</p><h2 id="旷视-Face-后台实习生"><a href="#旷视-Face-后台实习生" class="headerlink" title="旷视 Face++   后台实习生"></a>旷视 Face++   后台实习生</h2><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><p>就两个问题<br>一个拓扑排序,拓扑序计数,<br>一个二分check的问题</p><p>开始网站打不开,只写了第二个的代码</p><p>然后就问我最近学什么, 以后的方向什么的 聊了好久</p><p>问了几个问题就结束了</p><hr><p>感觉不错,面试官说重视的就是coding能力,其他的都可以在学,<br>等消息<br><del>智障,问面试官需要什么样的人才,说我这样的,一周后问面试官,说挂了</del></p><h2 id="京东云-C-实习"><a href="#京东云-C-实习" class="headerlink" title="京东云 C++(实习)"></a>京东云 C++(实习)</h2><h3 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h3><p>刚面完腾讯的hr面回来到实验室扯了两句,就收到面试了</p><p>给了个写代码的网页死活打不开,然后就改手写发照片了<br>写了一个矩阵,一层一层输出的代码</p><p>然后说了C++的stl<br>vector的变长机制<br>平衡树</p><p>tcp的三次握手,四次挥手,为什么三次,为什么四次<br>网络分层,说了下osi的七层<br>问tcp在那层,不知道,猜了个网络层,,,然后面试官问tcp的t是什么,想起是transfer,说出了传输层</p><p>然后还有几个问题,忘了</p><h2 id="日常问面试官问题结束"><a href="#日常问面试官问题结束" class="headerlink" title="日常问面试官问题结束"></a>日常问面试官问题结束</h2><p>面试官挺nice的</p><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><p>感觉效率很高 上午面完下午5点就来二面了,</p><p>面向对象编程谈谈<br>C++ stl<br>内存分布<br>网络的那几个老生常谈的问题<br>进程间通信<br>数据库谈了谈</p><p>一个linux 操作的问题,不会</p><p>还有几个问题 忘了</p><h3 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h3><p>因为一二面是周五 周一去考科四的时候来的电话</p><p>瞎聊天 结束</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;总结下所有的面试, 这样才能&lt;strong&gt;慢慢&lt;/strong&gt;进步呀,,,,&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="求职" scheme="http://blog.tabris.top/categories/%E6%B1%82%E8%81%8C/"/>
    
    
    <category term="C++" scheme="http://blog.tabris.top/tags/c/"/>
    
    <category term="面试" scheme="http://blog.tabris.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="数据库" scheme="http://blog.tabris.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="操作系统" scheme="http://blog.tabris.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="计算机网络" scheme="http://blog.tabris.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面试学习.</title>
    <link href="http://blog.tabris.top/StudyOfInterview/"/>
    <id>http://blog.tabris.top/StudyOfInterview/</id>
    <published>2018-01-29T12:44:08.000Z</published>
    <updated>2021-05-04T11:57:14.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下我针对面试的学习</p></blockquote><span id="more"></span><h2 id="算法-编程题"><a href="#算法-编程题" class="headerlink" title="算法/编程题"></a>算法/编程题</h2><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><h4 id="√-荷兰国旗问题"><a href="#√-荷兰国旗问题" class="headerlink" title="[√] 荷兰国旗问题"></a>[√] <a href="http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=268" target="_blank" rel="noopener external nofollow noreferrer">荷兰国旗问题</a></h4><p> 噗 , 被高大上的名字给吓到了,其实就是简单的C语言入门题.</p><h4 id="实现一个LRU算法"><a href="#实现一个LRU算法" class="headerlink" title="实现一个LRU算法"></a>实现一个LRU算法</h4><h4 id="√-双栈实现一个队列"><a href="#√-双栈实现一个队列" class="headerlink" title="[√]双栈实现一个队列"></a>[√]双栈实现一个队列</h4><p><a href="https://github.com/tabris233/slove-problems/blob/master/2018-1/29/QUEUE-two%20stack.cpp" target="_blank" rel="noopener external nofollow noreferrer">实现代码</a></p><h4 id="√-编程题"><a href="#√-编程题" class="headerlink" title="[√]编程题"></a>[√]编程题</h4><p>问题: 两个数组 A 表示一串螺丝 B 表示一串螺帽 螺丝和螺帽能够配对，但是A中螺丝之间不能比较大小，B中螺帽之间也不能比较大小，螺丝和螺帽可以比较大小，返回所有螺丝和螺帽的对应关系，要求复杂度小于O(n^2)</p><p>解: 类似快速排序,一个和另一个比较就可以了.<br><a href="https://github.com/tabris233/slove-problems/blob/master/2018-1/30/%E8%9E%BA%E4%B8%9D%E5%92%8C%E8%9E%BA%E5%B8%BD.cpp" target="_blank" rel="noopener external nofollow noreferrer">code</a></p><h4 id="今日头条笔试真题"><a href="#今日头条笔试真题" class="headerlink" title="今日头条笔试真题"></a>今日头条笔试真题</h4><p><a href="https://www.nowcoder.com/test/8537140/summary" target="_blank" rel="noopener external nofollow noreferrer">https://www.nowcoder.com/test/8537140/summary</a></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="一个进程"><a href="#一个进程" class="headerlink" title="一个进程"></a>一个进程</h4><p>一个进程是<strong>PCB结构与程序与数据的组合</strong></p><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="[-]产生死锁的必要条件"></a>[-]产生死锁的必要条件</h4><ul><li><p>互斥条件: 即某个资源在一段时间内只能由一个进程占有,不能同事被两个或两个以上的进程占有.这种独占资源如CD-ROM驱动器,打印机等等,必须在占有该资源的进程主动释放它之后,其他进程才能占有该资源.这是有资源本身的属性所决定的.如独木桥就是一种独占资源,两方的人不能同时过桥.</p></li><li><p>不可抢占条件: 进程所获得的资源在未使用完毕之前,资源申请者不能强行地从资源占有者中夺取资源.而只能由该资源的占有者进程自行释放.如过独木桥的人自己不能强迫对方后退,也不能非法地将对方退下桥,必须是桥上的人自己过桥后空出桥面(即主动释放占有资源),对方的人才能过桥.</p></li><li><p>占有且申请条件: 进程至少已经占有一个资源,但又申请新的资源; 由于该资源已经被另外进程占有,此时该进程阻塞; 但是,它在等待新资源之时,扔继续占用已占有的资源.还以过独木桥为例,甲乙两人在桥上相遇. 甲走过一段桥面(即占有了一些资源),还需要走其余的桥面(申请新的资源),但那部分桥面被已占有(已走过一段桥面).甲过不去,前进不能,又不后退;乙也处于同样的状况.</p></li><li><p>循环等待条件: 存在一个进程等待序列{P1,P2, ... ,Pn}, 其中P1等待P2所占有的某一资源, P2等待P3所占有的某一源, ...... ,而Pn等待P1所占有的某一资源形成一个进程循环等待环.就像前面的过独木桥问题,甲等待乙占有的桥面,而乙有等待甲占有的桥面, 从而彼此循环等待.</p></li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="[-]死锁预防"></a>[-]死锁预防</h4><ul><li><p>打破互斥条件: 即允许进程同事访问某些资源.但是,有的资源不允许被同时访问的,像打印机等等.这是由资源本身的属性所决定的. 所以,这种办法并无实用价值</p></li><li><p>打破不可抢占条件: 即允许进程强行从占有者哪里夺取某些资源. 就是说, 当一个进程已占有了某些资源,他又申请新的资源,但不能立即被满足,它必须释放所占有的全部资源, 以后再重新申请. 他所释放的资源可以分配给其他进程.这就相当于该进程占有的资源被隐蔽性地强占了. 这种预防死锁的方法实现起来困难,会降低系统性能.</p></li><li><p>打破占有且申请条件: 可以实行资源预先分配策略. 即进程在运行前一次地向系统申请它所需要的全部资源. 如果某个进程所需的全部资源得不到满足,则不分配任何资源,此进程在不运行.只有当系统能够满足当前进程的全部资源需求时,才一次性地将所申请的资源全部分配给该进程. 由于运行的进程已占有它所需要的全部资源所以不会发生占有资源有申请资源的现象, 因此不会发生死锁. 但是,这种策略也有如下缺点:</p><ul><li>在许多情况下,一个进程在执行之前不可能知道它所需要的全部资源. 这是由于进程在执行时是动态的,不可预测的.</li><li>资源利用率低.无论所分资源何时用到,一个进程只有在占有所需要的全部资源后才能执行.即使有些资源最后才被该进程用到一次,但该进程生存期间一直占有他们,造成长期占着不用的状况.这显然是一种极大的资源浪费.</li><li>降低了进程的并发性.因为资源有限,又加上存在浪费,能分配到所需全部资源的进程个数就必然少了.</li></ul></li><li><p>打破循环等待条件:<strong>实行资源有序分配策略</strong>.采用这种策略,即把资源事先分类编号,按号分配,使进程在申请,占用资源是不会形成环路.所有进程对资源的请求必须严格按字元序号递增的顺序提出.进程占用了小号资源,才能申请大耗资源,就不会产生环路, 从而预防了死锁.这种策略与前面的策略相比, 资源的利用率和系统的吞吐量都有了很大的提高,但是也存在一下缺点:</p><ul><li>限制了进程对资源的请求,同事给系统中所有资源合理编号也是件困难时,并增加了系统的开销.</li><li>为了遵循按编号申请的次序,在不使用的资源也需要提前申请,从而增加了进程对资源的占用时间.</li></ul></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ul><li>银行家算法<br>系统给当前进程分配资源时,先检查是否安全.<br>在满足当前的进程X资源申请后,是否还能有足够的资源去满足下一个距最大资源需求最近的进程(如某进程最大需要5个单位资源,已拥有1个,还需4个),若可以满足,则继续检查下一个距最大资源需求最近的进程,若均能满足所有进程,则表示为安全,可以允许给当前进程X分配其所需的资源申请,否则让该进程X进入等待.</li><li>哲学家进餐问题</li></ul><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="[-]进程和线程的区别"></a>[-]进程和线程的区别</h4><blockquote><p>定义<br><strong>进程</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br><strong>线程</strong>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>关系<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.<br>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。<br>区别<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><blockquote><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>优缺点<br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p></blockquote></blockquote><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="[]进程间通信"></a>[]进程间通信</h4><p>####### 为什么需要进程间通信？？</p><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。</p><p>进程间通信的目的：</p><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程。</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li><li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li><li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。<br>Linux 操作系统支持的主要进程间通信的通信机制：</li></ul><p><img src="../images/StudyOfInterview/jcjtx.jpg" class="lazyload" data-srcset="../images/StudyOfInterview/jcjtx.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="进程间通信-1" title="进程间通信"></p><h6 id="进程间通信-IPC-介绍"><a href="#进程间通信-IPC-介绍" class="headerlink" title="进程间通信(IPC)介绍"></a><a href="https://www.cnblogs.com/CheeseZH/p/5264465.html" target="_blank" rel="noopener external nofollow noreferrer">进程间通信(IPC)介绍</a></h6><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="[]进程调度"></a>[]进程调度</h4><h4 id="进程的内存分布"><a href="#进程的内存分布" class="headerlink" title="[]进程的内存分布"></a>[]进程的内存分布</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>代码段</td><td>全局常量（const）、字符串常量、函数以及编译时可决定的某些东西</td></tr><tr><td>数据段</td><td>存储初始化的全局变量 和 初始化的静态变量(全局和局部)</td></tr><tr><td>BSS段</td><td>存储未初始化的全局变量 和 未初始化的静态变量(全局和局部)</td></tr><tr><td>堆</td><td>动态分配的区域（malloc、new等）</td></tr><tr><td>栈</td><td>l临时声明的局部变量(初始化以及未初始化的,但不包含静态变量),局部常量(const)</td></tr><tr><td>命令行参数和环境变量</td><td>顾名思义</td></tr></tbody></table><p><img src="https://images2015.cnblogs.com/blog/978007/201702/978007-20170208113706760-1208301174.png" class="lazyload" data-srcset="https://images2015.cnblogs.com/blog/978007/201702/978007-20170208113706760-1208301174.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li><p>先来先服务 （FCFS，first come first served）<br>在所有调度算法中，最简单的是非抢占式的FCFS算法。<br>算法原理：进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。<br>算法优点：易于理解且实现简单，只需要一个队列(FIFO)，且相当公平<br>算法缺点：比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程</p></li><li><p>最短作业优先（SJF, Shortest Job First）<br>短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。<br>算法原理：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。<br>算法优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。<br>算法缺点：对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。</p></li><li><p>最高响应比优先法(HRRN，Highest Response Ratio Next)<br>最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。<br>算法原理：响应比R定义如下： R =(W+T)/T = 1+W/T<br>其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。<br>算法优点：由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。<br>算法缺点：由于每次调度前要计算响应比，系统开销也要相应增加。</p></li><li><p>时间片轮转算法（RR，Round-Robin）<br>该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>算法原理：让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。<br>算法优点：时间片轮转调度算法的特点是简单易行、平均响应时间短。<br>算法缺点：不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当<br>怎样确定时间片的大小：</p><ul><li>时间片大小的确定<br>1.系统对响应时间的要求<br>2.就绪队列中进程的数目<br>3.系统的处理力</li></ul></li><li><p>多级反馈队列(Multilevel Feedback Queue)<br>多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。<br>多级反馈队列调度算法描述：<br>　　1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。<br>　　2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。<br>　　3、对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。<br>　　4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。<br>　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p></li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="[]TCP和UDP区别"></a>[]TCP和UDP区别</h4><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>传输</td><td>提供面向连接的、可靠地数据流传输</td><td>提供的是非面向连接的、不可靠的数据流传输</td></tr><tr><td>传输单位</td><td>TCP报文段</td><td>用户数据报</td></tr><tr><td>安全性</td><td>TCP注重数据安全性</td><td>UDP数据传输快，因为不需要链接等待，少了许多操作，但是起安全性却一般</td></tr><tr><td></td><td></td><td></td></tr><tr><td>协议</td><td>FTP:定义了文件传输协议,使用21端口;</td><td>DNS: 用于域名解析服务,将域名地址转换成IP地址.DNS用的是53号端口.</td></tr><tr><td>协议</td><td>Telnet: 一种用于远程登录的端口,使用23端口,用户可以以自己的身份远程连接到计算机上,可提供基于DOS模式下的通信服务</td><td>SNMP: 简单网络管理协议,使用161端口,是用来管理网络十倍的.由于网络设备很多,无连接的服务就体现出其优势.</td></tr><tr><td>协议</td><td>SMTP: 邮件传送协议,用于发送邮件.服务端开放的是25号端口</td><td>TFTP(Trival File Transfer Protocal): 简单文件传输协议,该协议在熟知端口69上使用UDP服务</td></tr><tr><td>协议</td><td>POP3: 它是和SMTP对应,POP3用于接收邮件.POP3协议所用的是110端口</td><td></td></tr><tr><td>协议</td><td>HTTP: 是从Web服务器传输超文本到本地浏览器的传送协议</td><td></td></tr></tbody></table><p><a href="http://blog.csdn.net/li_ning_/article/details/52117463" target="_blank" rel="noopener external nofollow noreferrer">详细介绍,戳&lt;&lt;&lt;--</a></p><blockquote><p>TCP与UDP区别总结：<br>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p></blockquote><h4 id="TCP三次握手-四次挥手"><a href="#TCP三次握手-四次挥手" class="headerlink" title="[-]TCP三次握手/四次挥手"></a>[-]TCP三次握手/四次挥手</h4><p><a href="http://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener external nofollow noreferrer">详细介绍,戳&lt;&lt;&lt;---</a><br><a href="https://www.cnblogs.com/myvin/p/4862167.html" target="_blank" rel="noopener external nofollow noreferrer">更亲民的介绍,戳&lt;&lt;&lt;---</a></p><p>建立连接的过程是利用客户服务器模式,假设主机A为客户端,主机B为服务端</p><ul><li>TCP的三次握手过程：主机Ａ向Ｂ发送链接请求; -&gt; 主机B对收到的主机A的报文段进行确认; -&gt; 主机A再次对主机B的确认进行确认</li><li>采用三次握手是为了防止失效的链接请求报文段突然有传送到主机B,因而产生错误.失效的链接请求报文段是指: 主机A出的连接请求没有收到主机B的确认,于是经过一段时间后,主机A又重新向主机B发送连接请求,且建立成功,顺序完成数据传输. 考虑这样一个特殊情况,主机A第一次发送的连接请求并没有丢失,而是因为网络节点导致延迟到达主机B,主机B以为是主机又发起的新连接,于是主机B同意连接,并向主机A发回确认,但是此时主机A根本不会理会,主机B就一直在等待主机A发送数据，导致主机Ｂ的资源浪费．</li><li>采用两次握手不行, 原因就是上面说的实效的连接请求的特殊情况.</li></ul><h4 id="TCP里的一些机制"><a href="#TCP里的一些机制" class="headerlink" title="TCP里的一些机制"></a>TCP里的一些机制</h4><h4 id="OSI-TCP-IP-五层协议的体系结构-以及各层协议"><a href="#OSI-TCP-IP-五层协议的体系结构-以及各层协议" class="headerlink" title="OSI,TCP/IP,五层协议的体系结构,以及各层协议"></a>OSI,TCP/IP,五层协议的体系结构,以及各层协议</h4><p>OSI分层(7层): 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层.<br>TCP/IP分层(4层): 网络接口层,网际层,运输层,应用层.<br>五层协议(5层): 物理层,数据链路层,网络层,运输层,应用层.</p><p>每一层的协议如下:<br>物理层: RJ45,CLOCK,IEEE802.3(中继器,集线器)<br>数据链路: POP,FR,HDLC,VLAN,MAX(网桥,交换机)<br>网络层: IP,UCMP,ARP,RARP,OSPF,IPX,RIP,IGRP(路由器)<br>传输层: TCP,UDP,SPX<br>会话层: NFS,SQL,NETBIOS,RPC<br>表示层: JPEG,MPEG,ASII<br>应用层: FTP,DNS,Telnet,SMTP,HTTP,WWW,NFS</p><p>每一层的作用如下</p><p>物理层: 通过媒介传输比特,确定机械及电器规范(比特Bit)<br>数据链路: 将比特组装成帧和点到点的传递(帧Frame)<br>网络层: 负责数据包从源到宿的传递和网际互联(包PackeT)<br>传输层: 提供端到端的可靠报文传递和错误回复(段Segment)<br>会话层: 简历,管理和中智慧化(会话协议数据单元SPDU)<br>表示层: 对数据进行翻译,加密和压缩(表示协议数据单元PPDU)<br>应用层: 允许方位OSI环境的手段(应用协议数据单元APDU)</p><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p>A类地址: 以0开头, 第一个字节范围1<del>127(1.0.0.0</del>127.255.255.255);<br>B类地址: 以10开头, 第一个字节范围128<del>191(128.0.0.0</del>191.255.255.255);<br>C类地址: 以110开头, 第一个字节范围192<del>223(192.0.0.0</del>223.255.255.255);<br>D类地址: 以1110开头, 第一个字节范围224<del>239(224.0.0.0</del>239.255.255.255);<br>E类地址: 保留</p><p>一种A,B,C是基本类,D,E类作为多播和保留使用.<br>以下是留用的内部私有地址:<br>A类 10.0.0.0  -- 10.255.255.255<br>B类 182.16.00 -- 192.31.255.255<br>C类 192.168.0.0 -- 192.168.255.255</p><p>IP地址与子网掩码相与(&amp;)得到网络号<br>ip 192.168.2.110<br>&amp;<br>submask:255.255.255.0<br>.---------------------------------<br>网络号 192.168.2.0</p><p>注: 主机号,全是0的网络号(例如192.168.2.0),主机号全为1的为广播地址(192.168.2.255)</p><h4 id="ARP是地址解析协议-简单语言解释一下工作原理"><a href="#ARP是地址解析协议-简单语言解释一下工作原理" class="headerlink" title="ARP是地址解析协议,简单语言解释一下工作原理."></a>ARP是地址解析协议,简单语言解释一下工作原理.</h4><ul><li>首先,每个主机都会在自己的ARP缓冲区中建立一个ARP列表,以表示IP地址和MAC地址之间的对应关系.</li><li>当源主机要发送数据时,首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址,如果有,则直接发送数据,如果没有,就向本网段的所有主机发送ARP数据包,该数据包包括的内容有: 源主机的IP地址,源主机的MAC地址,目的主机的IP地址.</li><li>当本网络中的所有主机收到该ARP数据包时,首先检查数据包中的IP地址是否是自己的IP地址,如果不是,则忽略该数据包,,如果是,则首先从数据包中去除源主机的IP和MAC地址写入到ARP列表中,如果已经存在,则覆盖,然后将自己的MAC地址写入ARP响应包中,告诉源主机自己是它想要找的MAC地址</li><li>源主机收到ARP响应后.将目的主机的IP和MAC地址写入ARP列表,并利用此信息发送数据. 如果源主机一直没有收到ARP相应数据包,表示ARP查询失败.</li></ul><p>广播发送ARP请求,单播发送ARP相应.</p><h4 id="RARP协议"><a href="#RARP协议" class="headerlink" title="RARP协议"></a>RARP协议</h4><p>RARP是逆地址解析协议,作用是完成硬件地址到IP地址的映射,主要用于无盘工作站,因为给无盘工作站配置的IP地址不能保存.<br>工作流畅: 在网络中配置一台RARP服务器,里面保存者IP地址和MAC地址的映射关系,当无盘工作站启动后,就封装一个RARP数据包,里面有其MAC地址,然后广播到网络上去,当服务器收到请求包后,就查找对应的MAC地址的IP地址装入响应报文中发回给请求者. 因为需要广播请求报文,因此RARP只能用于具有广播能力的网络.</p><h4 id="各种协议的介绍"><a href="#各种协议的介绍" class="headerlink" title="各种协议的介绍"></a>各种协议的介绍</h4><ul><li><strong>ICMP协议</strong>: 因特网控制报文协议.它是TCP/IP协议族的一个自协议,用于在IP主机/路由器之间传递控制消息.</li><li><strong>TFTP协议</strong>: 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议,提供不复杂,开销不大的文件传输服务.</li><li><strong>HTTP协议</strong>: 超文本传输协议,是一个属于应用层的面向对象的协议,由于其简捷,快速的方式,适用于分布式超媒体信息系统</li><li><strong>NAT协议</strong>: 网络地址转换属介入广域网(WAN)技术,是一种将私有(保留)地址转化为合法IP地址的转换技术.</li><li><strong>DHCP协议</strong>: 动态主机配置协议,给用户或者内部网络管理员作为对所有计算机作中央管理的手段.</li></ul><h4 id="在浏览器中输入www-baidu-com后执行的全部过程"><a href="#在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的全部过程"></a>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程/" target="_blank" rel="noopener external nofollow noreferrer">www.baidu.com后执行的全部过程</a></h4><ul><li><ol><li>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址为220.181.27.48/" target="_blank" rel="noopener external nofollow noreferrer">www.baidu.com的IP地址为220.181.27.48</a>, 通过这个IP地址找到客户端到服务器的路径. 客户端浏览器发起一个HTTP回话到220.181.27.48, 然后通过TCP进行封装数据包, 输入到网络层.</li></ol></li><li><ol start="2"><li>在客户端的传输层,把HTTP回话请求分成报文段,添加源和目的端口, 如服务器使用80端口监听客户端的请求, 客户端有系统随机选择一个端口如5000, 与服务器进行交换,服务器吧相应的请求返回给客户端的5000端口. 然后使用IP层的IP地址查找目的端.</li></ol></li><li><ol start="3"><li>客户端的网络层不用关心应用层或者传输层的东西, 主要做到的是通过查找路由表确定如何到达服务器,期间可能经过多个路由器,这些都是有路由器来完成的工作, 我不做过多的描述, 无非就是通过查找路由表决定通过哪个路径到达服务器.</li></ol></li><li><ol start="4"><li>客户端的链路层, 包通过链路层发送到路由器, 通过邻居协议查找给定IP地址的MAC地址,然后发送ARP请求查找到目的地址, 如果得到回应后就可以使用ARP的请求应答交换的IP数据包,现在就可以传输了,然后发送IP数据包到达服务器的地址.</li></ol></li></ul><h4 id="DNS域名系统-简单描述其工作原理"><a href="#DNS域名系统-简单描述其工作原理" class="headerlink" title="DNS域名系统,简单描述其工作原理"></a>DNS域名系统,简单描述其工作原理</h4><p>当DNS客户机需要在程序中使用名称时, 它会查询DNS服务器来解析该名称. 客户机发送的每条查询信息包括三条信息: 包括: 指定的DNS域名,DNS域名的指定类型. 基于UDP服务,端口53. 该应用一般不直接为用户使用, 而是为其他应用服务,如 HTTP,SMTO等在其中需要完成主机名到地址的转换.</p><h4 id="了解交换机-路由器-网关的概念-并知道各自的用途"><a href="#了解交换机-路由器-网关的概念-并知道各自的用途" class="headerlink" title="了解交换机,路由器,网关的概念, 并知道各自的用途"></a>了解交换机,路由器,网关的概念, 并知道各自的用途</h4><ul><li><p><strong>交换机</strong><br>在计算机网络系统中,交换机是针对共享工作模式的弱点而推出的.交换机拥有一条高带宽的背部总线和内部交换矩阵.交换机的所有的端口都挂接在这条背部总线上,当控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的端口.目的MAC若不存在,交换机才广播到所有的端口, 接手端口回应后交换机会&#39;学习&#39;新的地址,并把它添加入内部地址表中.<br>交换机工作于OSI参考模型的第二层,即数据链路层. 交换机内部的CPU会在每个端口成功连接时,通过ARP协议学习它的MAC地址,保存成一张ARP表. 在今后的通讯中, 发往该MAC地址的数据包将仅送往其对应的端口,而不是所有端口. 因此,交换机可用于划分数据链路层广播,即冲突域; 但它不能划分网络层广播, 即广播域.<br>交换机被广泛应用于二层网络交换,俗称&#39;二层交换机&#39;.<br>交换机的种类有: 二层交换机,三层交换机,四层交换机,七层交换机分别工作在OSI七层模型中的第二层,第三层,第四层和第七层,并因此而得名.</p></li><li><p>路由器<br>路由器(Router)是一种计算机网络设备,提供了路由与传送两种重要机制,可以决定数据包从来源端到目的端所经过的路由路径(host到host之间的传输路径),这个过程称为<strong>路由</strong>; 将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行),这成为<strong>传动</strong>. 路由工作在OSI模型的第三层 -&gt; 即网络层,例如网际协议.<br>路由器的一个作用是连通不同的网络另一个作用是选择信息传送的线路. 路由器与交换机的差别, 路由器是属于OSI第三层的产品,交换机是OSI第二层的产品(这里至二层交换机)</p></li><li><p>网关<br>网关(Gateway), 网关顾名思义就是连接两个网络的设备,区别与路由器(由于历史的原因,许多有关TCP/IP的文献曾经把网络层使用的路由器成为网关,在今天很多局域网采用的都是路由器来接入网络,因此现在通常指的网关就是路由器的IP),经常在家庭中或者小型企业网络中使用,用于连接局域网和Internet. 网关也经常把一种协议转成另一种协议的设备,比如语音网关.<br>在传统TCP/IP术语中,网络设备只分成两种,一种为网关(Gateway),另一种称为主机(host). 网关能在网络间传递数据包,但主机不能传送数据包.在主机(又称终端系统,end system)中,数据包需经过TCP/IP四层协议处理,但是在网关(又称中介系统,intermediate system)只需要到达网际层(Internet layer),决定路径之后就可以传送. 在当时,网关(Gateway)和路由(Router)还没有区别.<br>在现代网络术语中,网关(Gateway)和路由(Router)的定义不同,网关(Gateway)能在不同协议间移动数据,而路由器(Router)是在不同网络间移动数据,相当于传统所说的IP网关(IP Gateway).<br>网关是连接两个网络的设备,对于语音网关来说,它可以连接PSTN网络和以太网,这就相当于VOIP,把不同电话的模拟信号通过网关而转换成数字信号,而且加入协议再去传输. 在到了接收端的时候再通过网关还原成模拟的电话信号,最后才能在电话机上听到.<br>对于以太网中的网关只能转发三层以上数据包,这一点和路由是一样的.而不同的是网关中并没有路由表,他只能按照预先设定的不同网段来进行转发.网关最重要的一层就是端口映射,子网内用户在外网看来只是外网的IP地址对应着不同的端口,这样看来就会保护子网内的用户.</p></li></ul><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><h4 id="BSS段的功能"><a href="#BSS段的功能" class="headerlink" title="BSS段的功能"></a>BSS段的功能</h4><h4 id="char-p1-quot-123-quot-与char-p2-quot-123-quot-其中p1-p2区别"><a href="#char-p1-quot-123-quot-与char-p2-quot-123-quot-其中p1-p2区别" class="headerlink" title="char *p1 = &quot;123&quot; 与char p2[]=&quot;123&quot;,其中p1,p2区别"></a>char *p1 = &quot;123&quot; 与char p2[]=&quot;123&quot;,其中p1,p2区别</h4><p>答: 常量是存储在内存中的,<br>*p1 是指针 指向&quot;123&quot;中的&quot;1&quot;的地址<br>p2[] 是数组 本质是在堆栈中定义的一段内存</p><h4 id="sizeof-struct-char-c-int-a"><a href="#sizeof-struct-char-c-int-a" class="headerlink" title="sizeof(struct{char c;int a;}) = ?"></a>sizeof(struct{char c;int a;}) = ?</h4><p>答: 4</p><p>内存对其,整体占得内存一定是<strong>最大数据元素的整数倍</strong>.<br>这里最大的是int(4字节)整体就是(4*n字节)<br>大概是这个样子<br>|int|char|<br>△△△△|△---|</p><h4 id="多线程编程经验"><a href="#多线程编程经验" class="headerlink" title="多线程编程经验"></a>多线程编程经验</h4><h4 id="C-网络编程"><a href="#C-网络编程" class="headerlink" title="C++网络编程"></a>C++网络编程</h4><h4 id="C-11新增了什么-了解的有哪些"><a href="#C-11新增了什么-了解的有哪些" class="headerlink" title="C++11新增了什么,了解的有哪些."></a>C++11新增了什么,了解的有哪些.</h4><h4 id="√-const关键字作用"><a href="#√-const关键字作用" class="headerlink" title="[√]const关键字作用."></a>[√]const关键字作用.</h4><p><a href="https://www.cnblogs.com/chogen/p/4574118.html" target="_blank" rel="noopener external nofollow noreferrer">好文</a></p><h4 id="多态-虚函数"><a href="#多态-虚函数" class="headerlink" title="[-]多态/虚函数"></a>[-]多态/虚函数</h4><p><a href="https://www.cnblogs.com/qiaoconglovelife/p/5128523.html" target="_blank" rel="noopener external nofollow noreferrer">介绍</a></p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="√-HashMap"><a href="#√-HashMap" class="headerlink" title="[√]HashMap"></a>[√]HashMap</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=38#wechat_redirect" target="_blank" rel="noopener external nofollow noreferrer">介绍链接</a></p><h4 id="Synchronze-和-Lock的区别和用法"><a href="#Synchronze-和-Lock的区别和用法" class="headerlink" title="Synchronze 和 Lock的区别和用法"></a>Synchronze 和 Lock的区别和用法</h4><table><thead><tr><th>Synchronze(隐式锁)</th><th>Lock(显示锁)</th></tr></thead><tbody><tr><td>在需要同步的对象中加入此控制,synchronize可以加在方法上,也可以加在特定代码块中,括号中表示需要所得对象</td><td>需要显示指定起始位置和终止位置.一般使用ReentrantLock类作为锁,多个线程中必须要使用一个ReentrantLock类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出.所以一般会在finally块中写unlock()以防死锁</td></tr><tr><td>托管给JVM执行的</td><td>java写的控制锁代码</td></tr><tr><td>采用的的CPU的悲观锁机制,即线程获得的是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁</td><td>乐观锁方式,每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.乐观锁实现的机制就是CAS操作(Compare and Swap)</td></tr></tbody></table><p>Ps: 在Java1.5中, syncchronize是性能低效的,因为这是一个重量级操作,需要调用操作接口,导致有可能加锁消耗的系统时间比加锁以外的操作还多. 相比之下使用Java提供的Lock对象,性能更高一些.但是到了Java1.6,发生了变化. synchronize在语义上很清晰,可以进行很多优化,有适应自旋,锁消除,锁粗化,轻量级锁,偏向锁等等. 导致在Java1.6上synchronize的性能并不比Lock差.</p><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁,悲观锁"></a>乐观锁,悲观锁</h4><ul><li><strong>乐观锁（ Optimistic Locking ）</strong> 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</li><li><strong>悲观锁（Pessimistic Lock）</strong>，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="进程的内存分布-1"><a href="#进程的内存分布-1" class="headerlink" title="进程的内存分布"></a>进程的内存分布</h4><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>代码段</td><td>可执行代码</td></tr><tr><td>数据段</td><td>已初始化全局变量,已初始化全局静态变量,局部静态变量,常量数据</td></tr><tr><td>BSS段</td><td>未初始化全局变量,未初始化全局静态变量</td></tr><tr><td>栈</td><td>局部变量,函数参数</td></tr><tr><td>堆</td><td>动态内存分配</td></tr></tbody></table><h4 id="那个命令可以常看内存使用情况"><a href="#那个命令可以常看内存使用情况" class="headerlink" title="那个命令可以常看内存使用情况"></a>那个命令可以常看内存使用情况</h4><p>答:<br>top<br>free [-h]</p><!-- ps aux --sort -rss --><h4 id="touch有什么用"><a href="#touch有什么用" class="headerlink" title="touch有什么用"></a>touch有什么用</h4><p>答: 两个作用</p><ul><li>一,用于吧已存在文件的时间标签更新为系统当前的时间(默认方式),它们的数据将原封不动地保留下来;</li><li>二,用来创建新的空文件</li></ul><h4 id="僵尸进程-孤儿进程-守护进程"><a href="#僵尸进程-孤儿进程-守护进程" class="headerlink" title="僵尸进程,孤儿进程,守护进程"></a>僵尸进程,孤儿进程,守护进程</h4><p><a href="https://blog.csdn.net/gogokongyin/article/details/51340432" target="_blank" rel="noopener external nofollow noreferrer">详细介绍</a></p><ul><li><p><strong>僵尸进程:</strong> 在fork()/execve()过程中,假设子进程结束时父进程仍存在,而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束,又没有显示忽略该信号,则子进程成为僵尸进程.</p></li><li><p><strong>孤儿进程:</strong> 一个父进程退出,而它的一个或多个子进程还在运行,那么那些子进程将成为孤儿进程. 孤儿进程将被init进程(进程号为1)所收养,并由init进程对他们完成状态收集工作.</p></li><li><p><strong>守护进程:</strong> Linux系统中的守护进程是一种运行在后台的进程. 而守护进程,也就是通常说的Daemon进程. 它通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件. Linux大多数服务器进程就是用这种守护进程实现的, 例如Web服务.守护进程常常在系统引导装入时启动, 在系统关闭时终止. 守护进程最大的特点是运行在后台,与终端无连接, 除非特殊情况下, 用户不能操作守护进程.</p></li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><h4 id="MongoDB-vs-Redis"><a href="#MongoDB-vs-Redis" class="headerlink" title="MongoDB vs Redis"></a>MongoDB vs Redis</h4><p>MongoDB和Redis都是NoSQL，采用结构型数据存储。二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。</p><p> MongoDB建议集群部署，更多的考虑到集群方案，Redis更偏重于进程顺序写入，虽然支持集群，也仅限于主-从模式。</p><table><thead><tr><th>比较指标</th><th>MongoDB(v2.4.9)</th><th>Redis(v2.4.17)</th><th>比较说明</th></tr></thead><tbody><tr><td>实现语言</td><td>c++</td><td>c/c++</td><td>-</td></tr><tr><td>协议</td><td>BSON,自定义二进制</td><td>类telnet</td><td>-</td></tr><tr><td>性能</td><td>依赖内存,TPS{(transaction per second)代表每秒执行的事务数量}较高</td><td>依赖内存,TPS非常高</td><td>Redis优于MongoDB</td></tr><tr><td>可操作性</td><td>丰富的数据表达,索引;最类似于关系型数据库,支持丰富的查询语句</td><td>数据丰富,较少的IO</td><td>MongoDB优于Redis</td></tr><tr><td>内存及存储</td><td>适合大数据量存储,依赖系统虚拟内存,采用镜像文件存储;内存占用率比较高,官方建议独立部署在64位系统</td><td>Redis2.0后支持虚拟内存特性(VM) 突破物理内存限制;数据可以设置时效性,类似于memcache</td><td>不同的应用场景,各有千秋</td></tr><tr><td>可用性</td><td>支持master-slave,replicatset(内部采用paxos选举算法,自动故障恢复),auto sharding机制,对客户端屏蔽了故障转移和切片机制</td><td>依赖客户端来实现分布式读写;主从复制时,每次从节点重新连接主节点都要依赖整个快照,无增量复制;不支持auto sharding,需要依赖程序设定一致性hash机制</td><td>MongoDB优于Redis；单点问题上,MongoDB应用简单,相对用户透明,Redis比较复杂,需要客户端主动解决.(MongoDB一般使用replicasets和sharding相结合,replicasets侧重高可用性以及高可靠,sharding侧重性能,水平扩展)</td></tr><tr><td>可靠性</td><td>从1.8版本后,采用binlog方式(类似Mysql) 支持持久化</td><td>依赖快照进行持久化;AOF增强可靠性;增强性的同时,影响访问性能</td><td>-</td></tr><tr><td>一致性</td><td>不支持事务,靠客户端保证</td><td>支持事务,比较脆,仅能保证事务中的操作按顺序执行</td><td>Redis优于MongoDB</td></tr><tr><td>数据分析</td><td>内置数据分析功能(mapreduce)</td><td>不支持</td><td>MongoDB优于Redis</td></tr><tr><td>应用场景</td><td>海量数据的访问效率提升</td><td>较小数据量的性能和运算</td><td>MongoDB优于Redis</td></tr></tbody></table><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="数据库事务的四大特性-ACID"><a href="#数据库事务的四大特性-ACID" class="headerlink" title="数据库事务的四大特性(ACID)"></a>数据库事务的四大特性(ACID)</h4><ul><li><strong>原子性(Atomicity)</strong><br>事务是数据库的逻辑工作单位,它对数据库的修改要么全部执行,要么全部不执行.</li><li><strong>一致性(Consistemcy)</strong><br>事务前后,数据库的状态都满足所有的完整性约束</li><li><strong>隔离性(lsolation)</strong><br>并发执行的事务是隔离的,一个不影响一个.如果有两个事务,运行在相同的时间内,执行相同的功能,事务的隔离性将确保每一事务在系统中认为只有该事物在使用系统. 这种属性有时称为串行化,为了防止事务操作间的混淆,必须串行化或序列化请求,使得在同一时间仅有y一个请求用于统一数据.通过设置数据库的<strong>隔离级别</strong>,可以达到不同的隔离效果.</li><li>持久性(Durability)<br>在事务完成后,该事务所对数据库所作的更改便持久的保存在数据库之中,并不会被回滚.</li></ul><h4 id="并发事务引起的问题"><a href="#并发事务引起的问题" class="headerlink" title="并发事务引起的问题"></a>并发事务引起的问题</h4><ul><li><p><strong>更新丢失</strong><br>两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。</p></li><li><p><strong>脏读</strong><br>脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。<br>例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。</p></li></ul><h2 id="设计题-系统题"><a href="#设计题-系统题" class="headerlink" title="设计题/系统题"></a>设计题/系统题</h2><h3 id=""><a href="#" class="headerlink" title="."></a>.</h3><h4 id="设计一个ID分配器"><a href="#设计一个ID分配器" class="headerlink" title="[]设计一个ID分配器"></a>[]设计一个ID分配器</h4><h4 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h4><h2 id="技术无关"><a href="#技术无关" class="headerlink" title="技术无关"></a>技术无关</h2><h3 id="-2"><a href="#-2" class="headerlink" title="."></a>.</h3><h4 id="能抗住压力么"><a href="#能抗住压力么" class="headerlink" title="能抗住压力么"></a>能抗住压力么</h4><p>答:作为应届生,本就应该吃苦耐劳学技术,人都是逼出来的,有压力才有动力,这点压力不算什么.</p><h4 id="有女朋友么"><a href="#有女朋友么" class="headerlink" title="有女朋友么"></a>有女朋友么</h4><p>答: 没有,一心向学,不找女朋友浪费时间.(TM是找不到好不2333)</p><h4 id="你有什么问题吗"><a href="#你有什么问题吗" class="headerlink" title="你有什么问题吗"></a>你有什么问题吗</h4><ol><li>这个岗位做的主要业务是什么</li><li>岗位的技术栈</li><li>招这个岗位的校招或者实习生更看重哪方面的能力</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录下我针对面试的学习&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="求职" scheme="http://blog.tabris.top/categories/%E6%B1%82%E8%81%8C/"/>
    
    
    <category term="C++" scheme="http://blog.tabris.top/tags/c/"/>
    
    <category term="面试" scheme="http://blog.tabris.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="操作系统" scheme="http://blog.tabris.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="计算机网络" scheme="http://blog.tabris.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="大数据" scheme="http://blog.tabris.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
